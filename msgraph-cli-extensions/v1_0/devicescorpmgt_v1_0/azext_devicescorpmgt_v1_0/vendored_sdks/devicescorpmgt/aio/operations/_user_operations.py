# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class UserOperations:
    """UserOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~devices_corporate_management.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_device_management_troubleshooting_event(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum140"]]] = None,
        select: Optional[List[Union[str, "models.Enum141"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDeviceManagementTroubleshootingEvent"]:
        """Get deviceManagementTroubleshootingEvents from users.

        Get deviceManagementTroubleshootingEvents from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum140]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum141]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDeviceManagementTroubleshootingEvent or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfDeviceManagementTroubleshootingEvent]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDeviceManagementTroubleshootingEvent"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_device_management_troubleshooting_event.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDeviceManagementTroubleshootingEvent', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_device_management_troubleshooting_event.metadata = {'url': '/users/{user-id}/deviceManagementTroubleshootingEvents'}  # type: ignore

    async def create_device_management_troubleshooting_event(
        self,
        user_id: str,
        id: Optional[str] = None,
        correlation_id: Optional[str] = None,
        event_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDeviceManagementTroubleshootingEvent":
        """Create new navigation property to deviceManagementTroubleshootingEvents for users.

        Create new navigation property to deviceManagementTroubleshootingEvents for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param correlation_id: Id used for tracing the failure in the service.
        :type correlation_id: str
        :param event_date_time: Time when the event occurred .
        :type event_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDeviceManagementTroubleshootingEvent, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphDeviceManagementTroubleshootingEvent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDeviceManagementTroubleshootingEvent"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDeviceManagementTroubleshootingEvent(id=id, correlation_id=correlation_id, event_date_time=event_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_device_management_troubleshooting_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDeviceManagementTroubleshootingEvent')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDeviceManagementTroubleshootingEvent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_device_management_troubleshooting_event.metadata = {'url': '/users/{user-id}/deviceManagementTroubleshootingEvents'}  # type: ignore

    async def get_device_management_troubleshooting_event(
        self,
        user_id: str,
        device_management_troubleshooting_event_id: str,
        select: Optional[List[Union[str, "models.Enum142"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDeviceManagementTroubleshootingEvent":
        """Get deviceManagementTroubleshootingEvents from users.

        Get deviceManagementTroubleshootingEvents from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param device_management_troubleshooting_event_id: key: id of
         deviceManagementTroubleshootingEvent.
        :type device_management_troubleshooting_event_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum142]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDeviceManagementTroubleshootingEvent, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphDeviceManagementTroubleshootingEvent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDeviceManagementTroubleshootingEvent"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_device_management_troubleshooting_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'deviceManagementTroubleshootingEvent-id': self._serialize.url("device_management_troubleshooting_event_id", device_management_troubleshooting_event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDeviceManagementTroubleshootingEvent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_device_management_troubleshooting_event.metadata = {'url': '/users/{user-id}/deviceManagementTroubleshootingEvents/{deviceManagementTroubleshootingEvent-id}'}  # type: ignore

    async def update_device_management_troubleshooting_event(
        self,
        user_id: str,
        device_management_troubleshooting_event_id: str,
        id: Optional[str] = None,
        correlation_id: Optional[str] = None,
        event_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property deviceManagementTroubleshootingEvents in users.

        Update the navigation property deviceManagementTroubleshootingEvents in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param device_management_troubleshooting_event_id: key: id of
         deviceManagementTroubleshootingEvent.
        :type device_management_troubleshooting_event_id: str
        :param id: Read-only.
        :type id: str
        :param correlation_id: Id used for tracing the failure in the service.
        :type correlation_id: str
        :param event_date_time: Time when the event occurred .
        :type event_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDeviceManagementTroubleshootingEvent(id=id, correlation_id=correlation_id, event_date_time=event_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_device_management_troubleshooting_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'deviceManagementTroubleshootingEvent-id': self._serialize.url("device_management_troubleshooting_event_id", device_management_troubleshooting_event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDeviceManagementTroubleshootingEvent')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_device_management_troubleshooting_event.metadata = {'url': '/users/{user-id}/deviceManagementTroubleshootingEvents/{deviceManagementTroubleshootingEvent-id}'}  # type: ignore

    async def delete_device_management_troubleshooting_event(
        self,
        user_id: str,
        device_management_troubleshooting_event_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property deviceManagementTroubleshootingEvents for users.

        Delete navigation property deviceManagementTroubleshootingEvents for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param device_management_troubleshooting_event_id: key: id of
         deviceManagementTroubleshootingEvent.
        :type device_management_troubleshooting_event_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_device_management_troubleshooting_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'deviceManagementTroubleshootingEvent-id': self._serialize.url("device_management_troubleshooting_event_id", device_management_troubleshooting_event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_device_management_troubleshooting_event.metadata = {'url': '/users/{user-id}/deviceManagementTroubleshootingEvents/{deviceManagementTroubleshootingEvent-id}'}  # type: ignore

    def list_managed_app_registration(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum143"]]] = None,
        select: Optional[List[Union[str, "models.Enum144"]]] = None,
        expand: Optional[List[Union[str, "models.Enum145"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedAppRegistration0"]:
        """Get managedAppRegistrations from users.

        Get managedAppRegistrations from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum143]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum144]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum145]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedAppRegistration0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedAppRegistration0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedAppRegistration0"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_managed_app_registration.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedAppRegistration0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_managed_app_registration.metadata = {'url': '/users/{user-id}/managedAppRegistrations'}  # type: ignore

    def list_ref_managed_app_registration(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum146"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfManagedAppRegistration"]:
        """Get ref of managedAppRegistrations from users.

        Get ref of managedAppRegistrations from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum146]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfManagedAppRegistration or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfLinksOfManagedAppRegistration]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfManagedAppRegistration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_ref_managed_app_registration.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfManagedAppRegistration', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_managed_app_registration.metadata = {'url': '/users/{user-id}/managedAppRegistrations/$ref'}  # type: ignore

    async def create_ref_managed_app_registration(
        self,
        user_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to managedAppRegistrations for users.

        Create new navigation property ref to managedAppRegistrations for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_managed_app_registration.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_managed_app_registration.metadata = {'url': '/users/{user-id}/managedAppRegistrations/$ref'}  # type: ignore

    def list_managed_device(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum147"]]] = None,
        select: Optional[List[Union[str, "models.Enum148"]]] = None,
        expand: Optional[List[Union[str, "models.Enum149"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedDevice"]:
        """Get managedDevices from users.

        Get managedDevices from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum147]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum148]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum149]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedDevice or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedDevice]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedDevice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_managed_device.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedDevice', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_managed_device.metadata = {'url': '/users/{user-id}/managedDevices'}  # type: ignore

    async def create_managed_device(
        self,
        user_id: str,
        id: Optional[str] = None,
        activation_lock_bypass_code: Optional[str] = None,
        android_security_patch_level: Optional[str] = None,
        azure_ad_device_id: Optional[str] = None,
        azure_ad_registered: Optional[bool] = None,
        compliance_grace_period_expiration_date_time: Optional[datetime.datetime] = None,
        compliance_state: Optional[Union[str, "models.MicrosoftGraphComplianceState"]] = None,
        configuration_manager_client_enabled_features: Optional["models.MicrosoftGraphConfigurationManagerClientEnabledFeatures"] = None,
        device_action_results: Optional[List["models.MicrosoftGraphDeviceActionResult"]] = None,
        device_category_display_name: Optional[str] = None,
        device_enrollment_type: Optional[Union[str, "models.MicrosoftGraphDeviceEnrollmentType"]] = None,
        device_health_attestation_state: Optional["models.MicrosoftGraphDeviceHealthAttestationState"] = None,
        device_name: Optional[str] = None,
        device_registration_state: Optional[Union[str, "models.MicrosoftGraphDeviceRegistrationState"]] = None,
        eas_activated: Optional[bool] = None,
        eas_activation_date_time: Optional[datetime.datetime] = None,
        eas_device_id: Optional[str] = None,
        email_address: Optional[str] = None,
        enrolled_date_time: Optional[datetime.datetime] = None,
        exchange_access_state: Optional[Union[str, "models.MicrosoftGraphDeviceManagementExchangeAccessState"]] = None,
        exchange_access_state_reason: Optional[Union[str, "models.MicrosoftGraphDeviceManagementExchangeAccessStateReason"]] = None,
        exchange_last_successful_sync_date_time: Optional[datetime.datetime] = None,
        free_storage_space_in_bytes: Optional[int] = None,
        imei: Optional[str] = None,
        is_encrypted: Optional[bool] = None,
        is_supervised: Optional[bool] = None,
        jail_broken: Optional[str] = None,
        last_sync_date_time: Optional[datetime.datetime] = None,
        managed_device_name: Optional[str] = None,
        managed_device_owner_type: Optional[Union[str, "models.MicrosoftGraphManagedDeviceOwnerType"]] = None,
        management_agent: Optional[Union[str, "models.MicrosoftGraphManagementAgentType"]] = None,
        manufacturer: Optional[str] = None,
        meid: Optional[str] = None,
        model: Optional[str] = None,
        operating_system: Optional[str] = None,
        os_version: Optional[str] = None,
        partner_reported_threat_state: Optional[Union[str, "models.MicrosoftGraphManagedDevicePartnerReportedHealthState"]] = None,
        phone_number: Optional[str] = None,
        remote_assistance_session_error_details: Optional[str] = None,
        remote_assistance_session_url: Optional[str] = None,
        serial_number: Optional[str] = None,
        subscriber_carrier: Optional[str] = None,
        total_storage_space_in_bytes: Optional[int] = None,
        user_display_name: Optional[str] = None,
        microsoft_graph_managed_device_user_id: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        wi_fi_mac_address: Optional[str] = None,
        device_compliance_policy_states: Optional[List["models.MicrosoftGraphDeviceCompliancePolicyState"]] = None,
        device_configuration_states: Optional[List["models.MicrosoftGraphDeviceConfigurationState"]] = None,
        device_category: Optional["models.MicrosoftGraphDeviceCategory"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedDevice":
        """Create new navigation property to managedDevices for users.

        Create new navigation property to managedDevices for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param activation_lock_bypass_code: Code that allows the Activation Lock on a device to be
         bypassed.
        :type activation_lock_bypass_code: str
        :param android_security_patch_level: Android security patch level.
        :type android_security_patch_level: str
        :param azure_ad_device_id: The unique identifier for the Azure Active Directory device. Read
         only.
        :type azure_ad_device_id: str
        :param azure_ad_registered: Whether the device is Azure Active Directory registered.
        :type azure_ad_registered: bool
        :param compliance_grace_period_expiration_date_time: The DateTime when device compliance grace
         period expires.
        :type compliance_grace_period_expiration_date_time: ~datetime.datetime
        :param compliance_state:
        :type compliance_state: str or ~devices_corporate_management.models.MicrosoftGraphComplianceState
        :param configuration_manager_client_enabled_features: configuration Manager client enabled
         features.
        :type configuration_manager_client_enabled_features: ~devices_corporate_management.models.MicrosoftGraphConfigurationManagerClientEnabledFeatures
        :param device_action_results: List of ComplexType deviceActionResult objects.
        :type device_action_results: list[~devices_corporate_management.models.MicrosoftGraphDeviceActionResult]
        :param device_category_display_name: Device category display name.
        :type device_category_display_name: str
        :param device_enrollment_type:
        :type device_enrollment_type: str or ~devices_corporate_management.models.MicrosoftGraphDeviceEnrollmentType
        :param device_health_attestation_state: deviceHealthAttestationState.
        :type device_health_attestation_state: ~devices_corporate_management.models.MicrosoftGraphDeviceHealthAttestationState
        :param device_name: Name of the device.
        :type device_name: str
        :param device_registration_state:
        :type device_registration_state: str or ~devices_corporate_management.models.MicrosoftGraphDeviceRegistrationState
        :param eas_activated: Whether the device is Exchange ActiveSync activated.
        :type eas_activated: bool
        :param eas_activation_date_time: Exchange ActivationSync activation time of the device.
        :type eas_activation_date_time: ~datetime.datetime
        :param eas_device_id: Exchange ActiveSync Id of the device.
        :type eas_device_id: str
        :param email_address: Email(s) for the user associated with the device.
        :type email_address: str
        :param enrolled_date_time: Enrollment time of the device.
        :type enrolled_date_time: ~datetime.datetime
        :param exchange_access_state:
        :type exchange_access_state: str or ~devices_corporate_management.models.MicrosoftGraphDeviceManagementExchangeAccessState
        :param exchange_access_state_reason:
        :type exchange_access_state_reason: str or ~devices_corporate_management.models.MicrosoftGraphDeviceManagementExchangeAccessStateReason
        :param exchange_last_successful_sync_date_time: Last time the device contacted Exchange.
        :type exchange_last_successful_sync_date_time: ~datetime.datetime
        :param free_storage_space_in_bytes: Free Storage in Bytes.
        :type free_storage_space_in_bytes: long
        :param imei: IMEI.
        :type imei: str
        :param is_encrypted: Device encryption status.
        :type is_encrypted: bool
        :param is_supervised: Device supervised status.
        :type is_supervised: bool
        :param jail_broken: whether the device is jail broken or rooted.
        :type jail_broken: str
        :param last_sync_date_time: The date and time that the device last completed a successful sync
         with Intune.
        :type last_sync_date_time: ~datetime.datetime
        :param managed_device_name: Automatically generated name to identify a device. Can be
         overwritten to a user friendly name.
        :type managed_device_name: str
        :param managed_device_owner_type:
        :type managed_device_owner_type: str or ~devices_corporate_management.models.MicrosoftGraphManagedDeviceOwnerType
        :param management_agent:
        :type management_agent: str or ~devices_corporate_management.models.MicrosoftGraphManagementAgentType
        :param manufacturer: Manufacturer of the device.
        :type manufacturer: str
        :param meid: MEID.
        :type meid: str
        :param model: Model of the device.
        :type model: str
        :param operating_system: Operating system of the device. Windows, iOS, etc.
        :type operating_system: str
        :param os_version: Operating system version of the device.
        :type os_version: str
        :param partner_reported_threat_state:
        :type partner_reported_threat_state: str or ~devices_corporate_management.models.MicrosoftGraphManagedDevicePartnerReportedHealthState
        :param phone_number: Phone number of the device.
        :type phone_number: str
        :param remote_assistance_session_error_details: An error string that identifies issues when
         creating Remote Assistance session objects.
        :type remote_assistance_session_error_details: str
        :param remote_assistance_session_url: Url that allows a Remote Assistance session to be
         established with the device.
        :type remote_assistance_session_url: str
        :param serial_number: SerialNumber.
        :type serial_number: str
        :param subscriber_carrier: Subscriber Carrier.
        :type subscriber_carrier: str
        :param total_storage_space_in_bytes: Total Storage in Bytes.
        :type total_storage_space_in_bytes: long
        :param user_display_name: User display name.
        :type user_display_name: str
        :param microsoft_graph_managed_device_user_id: Unique Identifier for the user associated with
         the device.
        :type microsoft_graph_managed_device_user_id: str
        :param user_principal_name: Device user principal name.
        :type user_principal_name: str
        :param wi_fi_mac_address: Wi-Fi MAC.
        :type wi_fi_mac_address: str
        :param device_compliance_policy_states: Device compliance policy states for this device.
        :type device_compliance_policy_states: list[~devices_corporate_management.models.MicrosoftGraphDeviceCompliancePolicyState]
        :param device_configuration_states: Device configuration states for this device.
        :type device_configuration_states: list[~devices_corporate_management.models.MicrosoftGraphDeviceConfigurationState]
        :param device_category: Device categories provides a way to organize your devices. Using device
         categories, company administrators can define their own categories that make sense to their
         company. These categories can then be applied to a device in the Intune Azure console or
         selected by a user during device enrollment. You can filter reports and create dynamic Azure
         Active Directory device groups based on device categories.
        :type device_category: ~devices_corporate_management.models.MicrosoftGraphDeviceCategory
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedDevice, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedDevice
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedDevice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedDevice(id=id, activation_lock_bypass_code=activation_lock_bypass_code, android_security_patch_level=android_security_patch_level, azure_ad_device_id=azure_ad_device_id, azure_ad_registered=azure_ad_registered, compliance_grace_period_expiration_date_time=compliance_grace_period_expiration_date_time, compliance_state=compliance_state, configuration_manager_client_enabled_features=configuration_manager_client_enabled_features, device_action_results=device_action_results, device_category_display_name=device_category_display_name, device_enrollment_type=device_enrollment_type, device_health_attestation_state=device_health_attestation_state, device_name=device_name, device_registration_state=device_registration_state, eas_activated=eas_activated, eas_activation_date_time=eas_activation_date_time, eas_device_id=eas_device_id, email_address=email_address, enrolled_date_time=enrolled_date_time, exchange_access_state=exchange_access_state, exchange_access_state_reason=exchange_access_state_reason, exchange_last_successful_sync_date_time=exchange_last_successful_sync_date_time, free_storage_space_in_bytes=free_storage_space_in_bytes, imei=imei, is_encrypted=is_encrypted, is_supervised=is_supervised, jail_broken=jail_broken, last_sync_date_time=last_sync_date_time, managed_device_name=managed_device_name, managed_device_owner_type=managed_device_owner_type, management_agent=management_agent, manufacturer=manufacturer, meid=meid, model=model, operating_system=operating_system, os_version=os_version, partner_reported_threat_state=partner_reported_threat_state, phone_number=phone_number, remote_assistance_session_error_details=remote_assistance_session_error_details, remote_assistance_session_url=remote_assistance_session_url, serial_number=serial_number, subscriber_carrier=subscriber_carrier, total_storage_space_in_bytes=total_storage_space_in_bytes, user_display_name=user_display_name, user_id=microsoft_graph_managed_device_user_id, user_principal_name=user_principal_name, wi_fi_mac_address=wi_fi_mac_address, device_compliance_policy_states=device_compliance_policy_states, device_configuration_states=device_configuration_states, device_category=device_category)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_managed_device.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedDevice')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedDevice', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_managed_device.metadata = {'url': '/users/{user-id}/managedDevices'}  # type: ignore

    async def get_managed_device(
        self,
        user_id: str,
        managed_device_id: str,
        select: Optional[List[Union[str, "models.Enum160"]]] = None,
        expand: Optional[List[Union[str, "models.Enum161"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedDevice":
        """Get managedDevices from users.

        Get managedDevices from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param managed_device_id: key: id of managedDevice.
        :type managed_device_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum160]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum161]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedDevice, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedDevice
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedDevice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_managed_device.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'managedDevice-id': self._serialize.url("managed_device_id", managed_device_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedDevice', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_managed_device.metadata = {'url': '/users/{user-id}/managedDevices/{managedDevice-id}'}  # type: ignore

    async def update_managed_device(
        self,
        user_id: str,
        managed_device_id: str,
        id: Optional[str] = None,
        activation_lock_bypass_code: Optional[str] = None,
        android_security_patch_level: Optional[str] = None,
        azure_ad_device_id: Optional[str] = None,
        azure_ad_registered: Optional[bool] = None,
        compliance_grace_period_expiration_date_time: Optional[datetime.datetime] = None,
        compliance_state: Optional[Union[str, "models.MicrosoftGraphComplianceState"]] = None,
        configuration_manager_client_enabled_features: Optional["models.MicrosoftGraphConfigurationManagerClientEnabledFeatures"] = None,
        device_action_results: Optional[List["models.MicrosoftGraphDeviceActionResult"]] = None,
        device_category_display_name: Optional[str] = None,
        device_enrollment_type: Optional[Union[str, "models.MicrosoftGraphDeviceEnrollmentType"]] = None,
        device_health_attestation_state: Optional["models.MicrosoftGraphDeviceHealthAttestationState"] = None,
        device_name: Optional[str] = None,
        device_registration_state: Optional[Union[str, "models.MicrosoftGraphDeviceRegistrationState"]] = None,
        eas_activated: Optional[bool] = None,
        eas_activation_date_time: Optional[datetime.datetime] = None,
        eas_device_id: Optional[str] = None,
        email_address: Optional[str] = None,
        enrolled_date_time: Optional[datetime.datetime] = None,
        exchange_access_state: Optional[Union[str, "models.MicrosoftGraphDeviceManagementExchangeAccessState"]] = None,
        exchange_access_state_reason: Optional[Union[str, "models.MicrosoftGraphDeviceManagementExchangeAccessStateReason"]] = None,
        exchange_last_successful_sync_date_time: Optional[datetime.datetime] = None,
        free_storage_space_in_bytes: Optional[int] = None,
        imei: Optional[str] = None,
        is_encrypted: Optional[bool] = None,
        is_supervised: Optional[bool] = None,
        jail_broken: Optional[str] = None,
        last_sync_date_time: Optional[datetime.datetime] = None,
        managed_device_name: Optional[str] = None,
        managed_device_owner_type: Optional[Union[str, "models.MicrosoftGraphManagedDeviceOwnerType"]] = None,
        management_agent: Optional[Union[str, "models.MicrosoftGraphManagementAgentType"]] = None,
        manufacturer: Optional[str] = None,
        meid: Optional[str] = None,
        model: Optional[str] = None,
        operating_system: Optional[str] = None,
        os_version: Optional[str] = None,
        partner_reported_threat_state: Optional[Union[str, "models.MicrosoftGraphManagedDevicePartnerReportedHealthState"]] = None,
        phone_number: Optional[str] = None,
        remote_assistance_session_error_details: Optional[str] = None,
        remote_assistance_session_url: Optional[str] = None,
        serial_number: Optional[str] = None,
        subscriber_carrier: Optional[str] = None,
        total_storage_space_in_bytes: Optional[int] = None,
        user_display_name: Optional[str] = None,
        microsoft_graph_managed_device_user_id: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        wi_fi_mac_address: Optional[str] = None,
        device_compliance_policy_states: Optional[List["models.MicrosoftGraphDeviceCompliancePolicyState"]] = None,
        device_configuration_states: Optional[List["models.MicrosoftGraphDeviceConfigurationState"]] = None,
        device_category: Optional["models.MicrosoftGraphDeviceCategory"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property managedDevices in users.

        Update the navigation property managedDevices in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param managed_device_id: key: id of managedDevice.
        :type managed_device_id: str
        :param id: Read-only.
        :type id: str
        :param activation_lock_bypass_code: Code that allows the Activation Lock on a device to be
         bypassed.
        :type activation_lock_bypass_code: str
        :param android_security_patch_level: Android security patch level.
        :type android_security_patch_level: str
        :param azure_ad_device_id: The unique identifier for the Azure Active Directory device. Read
         only.
        :type azure_ad_device_id: str
        :param azure_ad_registered: Whether the device is Azure Active Directory registered.
        :type azure_ad_registered: bool
        :param compliance_grace_period_expiration_date_time: The DateTime when device compliance grace
         period expires.
        :type compliance_grace_period_expiration_date_time: ~datetime.datetime
        :param compliance_state:
        :type compliance_state: str or ~devices_corporate_management.models.MicrosoftGraphComplianceState
        :param configuration_manager_client_enabled_features: configuration Manager client enabled
         features.
        :type configuration_manager_client_enabled_features: ~devices_corporate_management.models.MicrosoftGraphConfigurationManagerClientEnabledFeatures
        :param device_action_results: List of ComplexType deviceActionResult objects.
        :type device_action_results: list[~devices_corporate_management.models.MicrosoftGraphDeviceActionResult]
        :param device_category_display_name: Device category display name.
        :type device_category_display_name: str
        :param device_enrollment_type:
        :type device_enrollment_type: str or ~devices_corporate_management.models.MicrosoftGraphDeviceEnrollmentType
        :param device_health_attestation_state: deviceHealthAttestationState.
        :type device_health_attestation_state: ~devices_corporate_management.models.MicrosoftGraphDeviceHealthAttestationState
        :param device_name: Name of the device.
        :type device_name: str
        :param device_registration_state:
        :type device_registration_state: str or ~devices_corporate_management.models.MicrosoftGraphDeviceRegistrationState
        :param eas_activated: Whether the device is Exchange ActiveSync activated.
        :type eas_activated: bool
        :param eas_activation_date_time: Exchange ActivationSync activation time of the device.
        :type eas_activation_date_time: ~datetime.datetime
        :param eas_device_id: Exchange ActiveSync Id of the device.
        :type eas_device_id: str
        :param email_address: Email(s) for the user associated with the device.
        :type email_address: str
        :param enrolled_date_time: Enrollment time of the device.
        :type enrolled_date_time: ~datetime.datetime
        :param exchange_access_state:
        :type exchange_access_state: str or ~devices_corporate_management.models.MicrosoftGraphDeviceManagementExchangeAccessState
        :param exchange_access_state_reason:
        :type exchange_access_state_reason: str or ~devices_corporate_management.models.MicrosoftGraphDeviceManagementExchangeAccessStateReason
        :param exchange_last_successful_sync_date_time: Last time the device contacted Exchange.
        :type exchange_last_successful_sync_date_time: ~datetime.datetime
        :param free_storage_space_in_bytes: Free Storage in Bytes.
        :type free_storage_space_in_bytes: long
        :param imei: IMEI.
        :type imei: str
        :param is_encrypted: Device encryption status.
        :type is_encrypted: bool
        :param is_supervised: Device supervised status.
        :type is_supervised: bool
        :param jail_broken: whether the device is jail broken or rooted.
        :type jail_broken: str
        :param last_sync_date_time: The date and time that the device last completed a successful sync
         with Intune.
        :type last_sync_date_time: ~datetime.datetime
        :param managed_device_name: Automatically generated name to identify a device. Can be
         overwritten to a user friendly name.
        :type managed_device_name: str
        :param managed_device_owner_type:
        :type managed_device_owner_type: str or ~devices_corporate_management.models.MicrosoftGraphManagedDeviceOwnerType
        :param management_agent:
        :type management_agent: str or ~devices_corporate_management.models.MicrosoftGraphManagementAgentType
        :param manufacturer: Manufacturer of the device.
        :type manufacturer: str
        :param meid: MEID.
        :type meid: str
        :param model: Model of the device.
        :type model: str
        :param operating_system: Operating system of the device. Windows, iOS, etc.
        :type operating_system: str
        :param os_version: Operating system version of the device.
        :type os_version: str
        :param partner_reported_threat_state:
        :type partner_reported_threat_state: str or ~devices_corporate_management.models.MicrosoftGraphManagedDevicePartnerReportedHealthState
        :param phone_number: Phone number of the device.
        :type phone_number: str
        :param remote_assistance_session_error_details: An error string that identifies issues when
         creating Remote Assistance session objects.
        :type remote_assistance_session_error_details: str
        :param remote_assistance_session_url: Url that allows a Remote Assistance session to be
         established with the device.
        :type remote_assistance_session_url: str
        :param serial_number: SerialNumber.
        :type serial_number: str
        :param subscriber_carrier: Subscriber Carrier.
        :type subscriber_carrier: str
        :param total_storage_space_in_bytes: Total Storage in Bytes.
        :type total_storage_space_in_bytes: long
        :param user_display_name: User display name.
        :type user_display_name: str
        :param microsoft_graph_managed_device_user_id: Unique Identifier for the user associated with
         the device.
        :type microsoft_graph_managed_device_user_id: str
        :param user_principal_name: Device user principal name.
        :type user_principal_name: str
        :param wi_fi_mac_address: Wi-Fi MAC.
        :type wi_fi_mac_address: str
        :param device_compliance_policy_states: Device compliance policy states for this device.
        :type device_compliance_policy_states: list[~devices_corporate_management.models.MicrosoftGraphDeviceCompliancePolicyState]
        :param device_configuration_states: Device configuration states for this device.
        :type device_configuration_states: list[~devices_corporate_management.models.MicrosoftGraphDeviceConfigurationState]
        :param device_category: Device categories provides a way to organize your devices. Using device
         categories, company administrators can define their own categories that make sense to their
         company. These categories can then be applied to a device in the Intune Azure console or
         selected by a user during device enrollment. You can filter reports and create dynamic Azure
         Active Directory device groups based on device categories.
        :type device_category: ~devices_corporate_management.models.MicrosoftGraphDeviceCategory
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedDevice(id=id, activation_lock_bypass_code=activation_lock_bypass_code, android_security_patch_level=android_security_patch_level, azure_ad_device_id=azure_ad_device_id, azure_ad_registered=azure_ad_registered, compliance_grace_period_expiration_date_time=compliance_grace_period_expiration_date_time, compliance_state=compliance_state, configuration_manager_client_enabled_features=configuration_manager_client_enabled_features, device_action_results=device_action_results, device_category_display_name=device_category_display_name, device_enrollment_type=device_enrollment_type, device_health_attestation_state=device_health_attestation_state, device_name=device_name, device_registration_state=device_registration_state, eas_activated=eas_activated, eas_activation_date_time=eas_activation_date_time, eas_device_id=eas_device_id, email_address=email_address, enrolled_date_time=enrolled_date_time, exchange_access_state=exchange_access_state, exchange_access_state_reason=exchange_access_state_reason, exchange_last_successful_sync_date_time=exchange_last_successful_sync_date_time, free_storage_space_in_bytes=free_storage_space_in_bytes, imei=imei, is_encrypted=is_encrypted, is_supervised=is_supervised, jail_broken=jail_broken, last_sync_date_time=last_sync_date_time, managed_device_name=managed_device_name, managed_device_owner_type=managed_device_owner_type, management_agent=management_agent, manufacturer=manufacturer, meid=meid, model=model, operating_system=operating_system, os_version=os_version, partner_reported_threat_state=partner_reported_threat_state, phone_number=phone_number, remote_assistance_session_error_details=remote_assistance_session_error_details, remote_assistance_session_url=remote_assistance_session_url, serial_number=serial_number, subscriber_carrier=subscriber_carrier, total_storage_space_in_bytes=total_storage_space_in_bytes, user_display_name=user_display_name, user_id=microsoft_graph_managed_device_user_id, user_principal_name=user_principal_name, wi_fi_mac_address=wi_fi_mac_address, device_compliance_policy_states=device_compliance_policy_states, device_configuration_states=device_configuration_states, device_category=device_category)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_managed_device.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'managedDevice-id': self._serialize.url("managed_device_id", managed_device_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedDevice')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_managed_device.metadata = {'url': '/users/{user-id}/managedDevices/{managedDevice-id}'}  # type: ignore

    async def delete_managed_device(
        self,
        user_id: str,
        managed_device_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property managedDevices for users.

        Delete navigation property managedDevices for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param managed_device_id: key: id of managedDevice.
        :type managed_device_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_managed_device.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'managedDevice-id': self._serialize.url("managed_device_id", managed_device_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_managed_device.metadata = {'url': '/users/{user-id}/managedDevices/{managedDevice-id}'}  # type: ignore
