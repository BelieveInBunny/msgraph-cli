# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class DeviceAppManagementOperations:
    """DeviceAppManagementOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~devices_corporate_management.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_android_managed_app_protection(
        self,
        orderby: Optional[List[Union[str, "models.Get5ItemsItem"]]] = None,
        select: Optional[List[Union[str, "models.Get6ItemsItem"]]] = None,
        expand: Optional[List[Union[str, "models.Get7ItemsItem"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAndroidManagedAppProtection"]:
        """Get androidManagedAppProtections from deviceAppManagement.

        Get androidManagedAppProtections from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Get7ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAndroidManagedAppProtection or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfAndroidManagedAppProtection]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAndroidManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_android_managed_app_protection.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAndroidManagedAppProtection', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_android_managed_app_protection.metadata = {'url': '/deviceAppManagement/androidManagedAppProtections'}  # type: ignore

    async def create_android_managed_app_protection(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        allowed_data_storage_locations: Optional[List[Union[str, "models.MicrosoftGraphManagedAppDataStorageLocation"]]] = None,
        allowed_inbound_data_transfer_sources: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        allowed_outbound_clipboard_sharing_level: Optional[Union[str, "models.MicrosoftGraphManagedAppClipboardSharingLevel"]] = None,
        allowed_outbound_data_transfer_destinations: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        contact_sync_blocked: Optional[bool] = None,
        data_backup_blocked: Optional[bool] = None,
        device_compliance_required: Optional[bool] = None,
        disable_app_pin_if_device_pin_is_set: Optional[bool] = None,
        fingerprint_blocked: Optional[bool] = None,
        managed_browser: Optional[Union[str, "models.MicrosoftGraphManagedBrowserType"]] = None,
        managed_browser_to_open_links_required: Optional[bool] = None,
        maximum_pin_retries: Optional[int] = None,
        minimum_pin_length: Optional[int] = None,
        minimum_required_app_version: Optional[str] = None,
        minimum_required_os_version: Optional[str] = None,
        minimum_warning_app_version: Optional[str] = None,
        minimum_warning_os_version: Optional[str] = None,
        organizational_credentials_required: Optional[bool] = None,
        period_before_pin_reset: Optional[datetime.timedelta] = None,
        period_offline_before_access_check: Optional[datetime.timedelta] = None,
        period_offline_before_wipe_is_enforced: Optional[datetime.timedelta] = None,
        period_online_before_access_check: Optional[datetime.timedelta] = None,
        pin_character_set: Optional[Union[str, "models.MicrosoftGraphManagedAppPinCharacterSet"]] = None,
        pin_required: Optional[bool] = None,
        print_blocked: Optional[bool] = None,
        save_as_blocked: Optional[bool] = None,
        simple_pin_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        custom_browser_display_name: Optional[str] = None,
        custom_browser_package_id: Optional[str] = None,
        deployed_app_count: Optional[int] = None,
        disable_app_encryption_if_device_encryption_is_enabled: Optional[bool] = None,
        encrypt_app_data: Optional[bool] = None,
        minimum_required_patch_version: Optional[str] = None,
        minimum_warning_patch_version: Optional[str] = None,
        screen_capture_blocked: Optional[bool] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAndroidManagedAppProtection":
        """Create new navigation property to androidManagedAppProtections for deviceAppManagement.

        Create new navigation property to androidManagedAppProtections for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param allowed_data_storage_locations: Data storage locations where a user may store managed
         data.
        :type allowed_data_storage_locations: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataStorageLocation]
        :param allowed_inbound_data_transfer_sources:
        :type allowed_inbound_data_transfer_sources: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param allowed_outbound_clipboard_sharing_level:
        :type allowed_outbound_clipboard_sharing_level: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppClipboardSharingLevel
        :param allowed_outbound_data_transfer_destinations:
        :type allowed_outbound_data_transfer_destinations: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param contact_sync_blocked: Indicates whether contacts can be synced to the user's device.
        :type contact_sync_blocked: bool
        :param data_backup_blocked: Indicates whether the backup of a managed app's data is blocked.
        :type data_backup_blocked: bool
        :param device_compliance_required: Indicates whether device compliance is required.
        :type device_compliance_required: bool
        :param disable_app_pin_if_device_pin_is_set: Indicates whether use of the app pin is required
         if the device pin is set.
        :type disable_app_pin_if_device_pin_is_set: bool
        :param fingerprint_blocked: Indicates whether use of the fingerprint reader is allowed in place
         of a pin if PinRequired is set to True.
        :type fingerprint_blocked: bool
        :param managed_browser:
        :type managed_browser: str or ~devices_corporate_management.models.MicrosoftGraphManagedBrowserType
        :param managed_browser_to_open_links_required: Indicates whether internet links should be
         opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol
         (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android).
        :type managed_browser_to_open_links_required: bool
        :param maximum_pin_retries: Maximum number of incorrect pin retry attempts before the managed
         app is either blocked or wiped.
        :type maximum_pin_retries: int
        :param minimum_pin_length: Minimum pin length required for an app-level pin if PinRequired is
         set to True.
        :type minimum_pin_length: int
        :param minimum_required_app_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_app_version: str
        :param minimum_required_os_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_os_version: str
        :param minimum_warning_app_version: Versions less than the specified version will result in
         warning message on the managed app.
        :type minimum_warning_app_version: str
        :param minimum_warning_os_version: Versions less than the specified version will result in
         warning message on the managed app from accessing company data.
        :type minimum_warning_os_version: str
        :param organizational_credentials_required: Indicates whether organizational credentials are
         required for app use.
        :type organizational_credentials_required: bool
        :param period_before_pin_reset: TimePeriod before the all-level pin must be reset if
         PinRequired is set to True.
        :type period_before_pin_reset: ~datetime.timedelta
        :param period_offline_before_access_check: The period after which access is checked when the
         device is not connected to the internet.
        :type period_offline_before_access_check: ~datetime.timedelta
        :param period_offline_before_wipe_is_enforced: The amount of time an app is allowed to remain
         disconnected from the internet before all managed data it is wiped.
        :type period_offline_before_wipe_is_enforced: ~datetime.timedelta
        :param period_online_before_access_check: The period after which access is checked when the
         device is connected to the internet.
        :type period_online_before_access_check: ~datetime.timedelta
        :param pin_character_set:
        :type pin_character_set: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppPinCharacterSet
        :param pin_required: Indicates whether an app-level pin is required.
        :type pin_required: bool
        :param print_blocked: Indicates whether printing is allowed from managed apps.
        :type print_blocked: bool
        :param save_as_blocked: Indicates whether users may use the 'Save As' menu item to save a copy
         of protected files.
        :type save_as_blocked: bool
        :param simple_pin_blocked: Indicates whether simplePin is blocked.
        :type simple_pin_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param assignments: Navigation property to list of inclusion and exclusion groups to which the
         policy is deployed.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param custom_browser_display_name: Friendly name of the preferred custom browser to open
         weblink on Android. When this property is configured, ManagedBrowserToOpenLinksRequired should
         be true.
        :type custom_browser_display_name: str
        :param custom_browser_package_id: Unique identifier of the preferred custom browser to open
         weblink on Android. When this property is configured, ManagedBrowserToOpenLinksRequired should
         be true.
        :type custom_browser_package_id: str
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param disable_app_encryption_if_device_encryption_is_enabled: When this setting is enabled,
         app level encryption is disabled if device level encryption is enabled.
        :type disable_app_encryption_if_device_encryption_is_enabled: bool
        :param encrypt_app_data: Indicates whether application data for managed apps should be
         encrypted.
        :type encrypt_app_data: bool
        :param minimum_required_patch_version: Define the oldest required Android security patch level
         a user can have to gain secure access to the app.
        :type minimum_required_patch_version: str
        :param minimum_warning_patch_version: Define the oldest recommended Android security patch
         level a user can have for secure access to the app.
        :type minimum_warning_patch_version: str
        :param screen_capture_blocked: Indicates whether a managed user can take screen captures of
         managed apps.
        :type screen_capture_blocked: bool
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAndroidManagedAppProtection, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphAndroidManagedAppProtection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAndroidManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAndroidManagedAppProtection(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, allowed_data_storage_locations=allowed_data_storage_locations, allowed_inbound_data_transfer_sources=allowed_inbound_data_transfer_sources, allowed_outbound_clipboard_sharing_level=allowed_outbound_clipboard_sharing_level, allowed_outbound_data_transfer_destinations=allowed_outbound_data_transfer_destinations, contact_sync_blocked=contact_sync_blocked, data_backup_blocked=data_backup_blocked, device_compliance_required=device_compliance_required, disable_app_pin_if_device_pin_is_set=disable_app_pin_if_device_pin_is_set, fingerprint_blocked=fingerprint_blocked, managed_browser=managed_browser, managed_browser_to_open_links_required=managed_browser_to_open_links_required, maximum_pin_retries=maximum_pin_retries, minimum_pin_length=minimum_pin_length, minimum_required_app_version=minimum_required_app_version, minimum_required_os_version=minimum_required_os_version, minimum_warning_app_version=minimum_warning_app_version, minimum_warning_os_version=minimum_warning_os_version, organizational_credentials_required=organizational_credentials_required, period_before_pin_reset=period_before_pin_reset, period_offline_before_access_check=period_offline_before_access_check, period_offline_before_wipe_is_enforced=period_offline_before_wipe_is_enforced, period_online_before_access_check=period_online_before_access_check, pin_character_set=pin_character_set, pin_required=pin_required, print_blocked=print_blocked, save_as_blocked=save_as_blocked, simple_pin_blocked=simple_pin_blocked, is_assigned=is_assigned, assignments=assignments, custom_browser_display_name=custom_browser_display_name, custom_browser_package_id=custom_browser_package_id, deployed_app_count=deployed_app_count, disable_app_encryption_if_device_encryption_is_enabled=disable_app_encryption_if_device_encryption_is_enabled, encrypt_app_data=encrypt_app_data, minimum_required_patch_version=minimum_required_patch_version, minimum_warning_patch_version=minimum_warning_patch_version, screen_capture_blocked=screen_capture_blocked, apps=apps, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_android_managed_app_protection.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAndroidManagedAppProtection')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAndroidManagedAppProtection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_android_managed_app_protection.metadata = {'url': '/deviceAppManagement/androidManagedAppProtections'}  # type: ignore

    async def get_android_managed_app_protection(
        self,
        android_managed_app_protection_id: str,
        select: Optional[List[Union[str, "models.Enum21"]]] = None,
        expand: Optional[List[Union[str, "models.Get2ItemsItem"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAndroidManagedAppProtection":
        """Get androidManagedAppProtections from deviceAppManagement.

        Get androidManagedAppProtections from deviceAppManagement.

        :param android_managed_app_protection_id: key: id of androidManagedAppProtection.
        :type android_managed_app_protection_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum21]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Get2ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAndroidManagedAppProtection, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphAndroidManagedAppProtection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAndroidManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_android_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'androidManagedAppProtection-id': self._serialize.url("android_managed_app_protection_id", android_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAndroidManagedAppProtection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_android_managed_app_protection.metadata = {'url': '/deviceAppManagement/androidManagedAppProtections/{androidManagedAppProtection-id}'}  # type: ignore

    async def update_android_managed_app_protection(
        self,
        android_managed_app_protection_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        allowed_data_storage_locations: Optional[List[Union[str, "models.MicrosoftGraphManagedAppDataStorageLocation"]]] = None,
        allowed_inbound_data_transfer_sources: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        allowed_outbound_clipboard_sharing_level: Optional[Union[str, "models.MicrosoftGraphManagedAppClipboardSharingLevel"]] = None,
        allowed_outbound_data_transfer_destinations: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        contact_sync_blocked: Optional[bool] = None,
        data_backup_blocked: Optional[bool] = None,
        device_compliance_required: Optional[bool] = None,
        disable_app_pin_if_device_pin_is_set: Optional[bool] = None,
        fingerprint_blocked: Optional[bool] = None,
        managed_browser: Optional[Union[str, "models.MicrosoftGraphManagedBrowserType"]] = None,
        managed_browser_to_open_links_required: Optional[bool] = None,
        maximum_pin_retries: Optional[int] = None,
        minimum_pin_length: Optional[int] = None,
        minimum_required_app_version: Optional[str] = None,
        minimum_required_os_version: Optional[str] = None,
        minimum_warning_app_version: Optional[str] = None,
        minimum_warning_os_version: Optional[str] = None,
        organizational_credentials_required: Optional[bool] = None,
        period_before_pin_reset: Optional[datetime.timedelta] = None,
        period_offline_before_access_check: Optional[datetime.timedelta] = None,
        period_offline_before_wipe_is_enforced: Optional[datetime.timedelta] = None,
        period_online_before_access_check: Optional[datetime.timedelta] = None,
        pin_character_set: Optional[Union[str, "models.MicrosoftGraphManagedAppPinCharacterSet"]] = None,
        pin_required: Optional[bool] = None,
        print_blocked: Optional[bool] = None,
        save_as_blocked: Optional[bool] = None,
        simple_pin_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        custom_browser_display_name: Optional[str] = None,
        custom_browser_package_id: Optional[str] = None,
        deployed_app_count: Optional[int] = None,
        disable_app_encryption_if_device_encryption_is_enabled: Optional[bool] = None,
        encrypt_app_data: Optional[bool] = None,
        minimum_required_patch_version: Optional[str] = None,
        minimum_warning_patch_version: Optional[str] = None,
        screen_capture_blocked: Optional[bool] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property androidManagedAppProtections in deviceAppManagement.

        Update the navigation property androidManagedAppProtections in deviceAppManagement.

        :param android_managed_app_protection_id: key: id of androidManagedAppProtection.
        :type android_managed_app_protection_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param allowed_data_storage_locations: Data storage locations where a user may store managed
         data.
        :type allowed_data_storage_locations: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataStorageLocation]
        :param allowed_inbound_data_transfer_sources:
        :type allowed_inbound_data_transfer_sources: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param allowed_outbound_clipboard_sharing_level:
        :type allowed_outbound_clipboard_sharing_level: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppClipboardSharingLevel
        :param allowed_outbound_data_transfer_destinations:
        :type allowed_outbound_data_transfer_destinations: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param contact_sync_blocked: Indicates whether contacts can be synced to the user's device.
        :type contact_sync_blocked: bool
        :param data_backup_blocked: Indicates whether the backup of a managed app's data is blocked.
        :type data_backup_blocked: bool
        :param device_compliance_required: Indicates whether device compliance is required.
        :type device_compliance_required: bool
        :param disable_app_pin_if_device_pin_is_set: Indicates whether use of the app pin is required
         if the device pin is set.
        :type disable_app_pin_if_device_pin_is_set: bool
        :param fingerprint_blocked: Indicates whether use of the fingerprint reader is allowed in place
         of a pin if PinRequired is set to True.
        :type fingerprint_blocked: bool
        :param managed_browser:
        :type managed_browser: str or ~devices_corporate_management.models.MicrosoftGraphManagedBrowserType
        :param managed_browser_to_open_links_required: Indicates whether internet links should be
         opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol
         (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android).
        :type managed_browser_to_open_links_required: bool
        :param maximum_pin_retries: Maximum number of incorrect pin retry attempts before the managed
         app is either blocked or wiped.
        :type maximum_pin_retries: int
        :param minimum_pin_length: Minimum pin length required for an app-level pin if PinRequired is
         set to True.
        :type minimum_pin_length: int
        :param minimum_required_app_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_app_version: str
        :param minimum_required_os_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_os_version: str
        :param minimum_warning_app_version: Versions less than the specified version will result in
         warning message on the managed app.
        :type minimum_warning_app_version: str
        :param minimum_warning_os_version: Versions less than the specified version will result in
         warning message on the managed app from accessing company data.
        :type minimum_warning_os_version: str
        :param organizational_credentials_required: Indicates whether organizational credentials are
         required for app use.
        :type organizational_credentials_required: bool
        :param period_before_pin_reset: TimePeriod before the all-level pin must be reset if
         PinRequired is set to True.
        :type period_before_pin_reset: ~datetime.timedelta
        :param period_offline_before_access_check: The period after which access is checked when the
         device is not connected to the internet.
        :type period_offline_before_access_check: ~datetime.timedelta
        :param period_offline_before_wipe_is_enforced: The amount of time an app is allowed to remain
         disconnected from the internet before all managed data it is wiped.
        :type period_offline_before_wipe_is_enforced: ~datetime.timedelta
        :param period_online_before_access_check: The period after which access is checked when the
         device is connected to the internet.
        :type period_online_before_access_check: ~datetime.timedelta
        :param pin_character_set:
        :type pin_character_set: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppPinCharacterSet
        :param pin_required: Indicates whether an app-level pin is required.
        :type pin_required: bool
        :param print_blocked: Indicates whether printing is allowed from managed apps.
        :type print_blocked: bool
        :param save_as_blocked: Indicates whether users may use the 'Save As' menu item to save a copy
         of protected files.
        :type save_as_blocked: bool
        :param simple_pin_blocked: Indicates whether simplePin is blocked.
        :type simple_pin_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param assignments: Navigation property to list of inclusion and exclusion groups to which the
         policy is deployed.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param custom_browser_display_name: Friendly name of the preferred custom browser to open
         weblink on Android. When this property is configured, ManagedBrowserToOpenLinksRequired should
         be true.
        :type custom_browser_display_name: str
        :param custom_browser_package_id: Unique identifier of the preferred custom browser to open
         weblink on Android. When this property is configured, ManagedBrowserToOpenLinksRequired should
         be true.
        :type custom_browser_package_id: str
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param disable_app_encryption_if_device_encryption_is_enabled: When this setting is enabled,
         app level encryption is disabled if device level encryption is enabled.
        :type disable_app_encryption_if_device_encryption_is_enabled: bool
        :param encrypt_app_data: Indicates whether application data for managed apps should be
         encrypted.
        :type encrypt_app_data: bool
        :param minimum_required_patch_version: Define the oldest required Android security patch level
         a user can have to gain secure access to the app.
        :type minimum_required_patch_version: str
        :param minimum_warning_patch_version: Define the oldest recommended Android security patch
         level a user can have for secure access to the app.
        :type minimum_warning_patch_version: str
        :param screen_capture_blocked: Indicates whether a managed user can take screen captures of
         managed apps.
        :type screen_capture_blocked: bool
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAndroidManagedAppProtection(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, allowed_data_storage_locations=allowed_data_storage_locations, allowed_inbound_data_transfer_sources=allowed_inbound_data_transfer_sources, allowed_outbound_clipboard_sharing_level=allowed_outbound_clipboard_sharing_level, allowed_outbound_data_transfer_destinations=allowed_outbound_data_transfer_destinations, contact_sync_blocked=contact_sync_blocked, data_backup_blocked=data_backup_blocked, device_compliance_required=device_compliance_required, disable_app_pin_if_device_pin_is_set=disable_app_pin_if_device_pin_is_set, fingerprint_blocked=fingerprint_blocked, managed_browser=managed_browser, managed_browser_to_open_links_required=managed_browser_to_open_links_required, maximum_pin_retries=maximum_pin_retries, minimum_pin_length=minimum_pin_length, minimum_required_app_version=minimum_required_app_version, minimum_required_os_version=minimum_required_os_version, minimum_warning_app_version=minimum_warning_app_version, minimum_warning_os_version=minimum_warning_os_version, organizational_credentials_required=organizational_credentials_required, period_before_pin_reset=period_before_pin_reset, period_offline_before_access_check=period_offline_before_access_check, period_offline_before_wipe_is_enforced=period_offline_before_wipe_is_enforced, period_online_before_access_check=period_online_before_access_check, pin_character_set=pin_character_set, pin_required=pin_required, print_blocked=print_blocked, save_as_blocked=save_as_blocked, simple_pin_blocked=simple_pin_blocked, is_assigned=is_assigned, assignments=assignments, custom_browser_display_name=custom_browser_display_name, custom_browser_package_id=custom_browser_package_id, deployed_app_count=deployed_app_count, disable_app_encryption_if_device_encryption_is_enabled=disable_app_encryption_if_device_encryption_is_enabled, encrypt_app_data=encrypt_app_data, minimum_required_patch_version=minimum_required_patch_version, minimum_warning_patch_version=minimum_warning_patch_version, screen_capture_blocked=screen_capture_blocked, apps=apps, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_android_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'androidManagedAppProtection-id': self._serialize.url("android_managed_app_protection_id", android_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAndroidManagedAppProtection')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_android_managed_app_protection.metadata = {'url': '/deviceAppManagement/androidManagedAppProtections/{androidManagedAppProtection-id}'}  # type: ignore

    async def delete_android_managed_app_protection(
        self,
        android_managed_app_protection_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property androidManagedAppProtections for deviceAppManagement.

        Delete navigation property androidManagedAppProtections for deviceAppManagement.

        :param android_managed_app_protection_id: key: id of androidManagedAppProtection.
        :type android_managed_app_protection_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_android_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'androidManagedAppProtection-id': self._serialize.url("android_managed_app_protection_id", android_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_android_managed_app_protection.metadata = {'url': '/deviceAppManagement/androidManagedAppProtections/{androidManagedAppProtection-id}'}  # type: ignore

    def list_default_managed_app_protection(
        self,
        orderby: Optional[List[Union[str, "models.Enum27"]]] = None,
        select: Optional[List[Union[str, "models.Enum28"]]] = None,
        expand: Optional[List[Union[str, "models.Enum29"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDefaultManagedAppProtection"]:
        """Get defaultManagedAppProtections from deviceAppManagement.

        Get defaultManagedAppProtections from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum27]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum28]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum29]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDefaultManagedAppProtection or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfDefaultManagedAppProtection]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDefaultManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_default_managed_app_protection.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDefaultManagedAppProtection', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_default_managed_app_protection.metadata = {'url': '/deviceAppManagement/defaultManagedAppProtections'}  # type: ignore

    async def create_default_managed_app_protection(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        allowed_data_storage_locations: Optional[List[Union[str, "models.MicrosoftGraphManagedAppDataStorageLocation"]]] = None,
        allowed_inbound_data_transfer_sources: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        allowed_outbound_clipboard_sharing_level: Optional[Union[str, "models.MicrosoftGraphManagedAppClipboardSharingLevel"]] = None,
        allowed_outbound_data_transfer_destinations: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        contact_sync_blocked: Optional[bool] = None,
        data_backup_blocked: Optional[bool] = None,
        device_compliance_required: Optional[bool] = None,
        disable_app_pin_if_device_pin_is_set: Optional[bool] = None,
        fingerprint_blocked: Optional[bool] = None,
        managed_browser: Optional[Union[str, "models.MicrosoftGraphManagedBrowserType"]] = None,
        managed_browser_to_open_links_required: Optional[bool] = None,
        maximum_pin_retries: Optional[int] = None,
        minimum_pin_length: Optional[int] = None,
        minimum_required_app_version: Optional[str] = None,
        minimum_required_os_version: Optional[str] = None,
        minimum_warning_app_version: Optional[str] = None,
        minimum_warning_os_version: Optional[str] = None,
        organizational_credentials_required: Optional[bool] = None,
        period_before_pin_reset: Optional[datetime.timedelta] = None,
        period_offline_before_access_check: Optional[datetime.timedelta] = None,
        period_offline_before_wipe_is_enforced: Optional[datetime.timedelta] = None,
        period_online_before_access_check: Optional[datetime.timedelta] = None,
        pin_character_set: Optional[Union[str, "models.MicrosoftGraphManagedAppPinCharacterSet"]] = None,
        pin_required: Optional[bool] = None,
        print_blocked: Optional[bool] = None,
        save_as_blocked: Optional[bool] = None,
        simple_pin_blocked: Optional[bool] = None,
        app_data_encryption_type: Optional[Union[str, "models.MicrosoftGraphManagedAppDataEncryptionType"]] = None,
        custom_settings: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        deployed_app_count: Optional[int] = None,
        disable_app_encryption_if_device_encryption_is_enabled: Optional[bool] = None,
        encrypt_app_data: Optional[bool] = None,
        face_id_blocked: Optional[bool] = None,
        minimum_required_patch_version: Optional[str] = None,
        minimum_required_sdk_version: Optional[str] = None,
        minimum_warning_patch_version: Optional[str] = None,
        screen_capture_blocked: Optional[bool] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDefaultManagedAppProtection":
        """Create new navigation property to defaultManagedAppProtections for deviceAppManagement.

        Create new navigation property to defaultManagedAppProtections for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param allowed_data_storage_locations: Data storage locations where a user may store managed
         data.
        :type allowed_data_storage_locations: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataStorageLocation]
        :param allowed_inbound_data_transfer_sources:
        :type allowed_inbound_data_transfer_sources: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param allowed_outbound_clipboard_sharing_level:
        :type allowed_outbound_clipboard_sharing_level: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppClipboardSharingLevel
        :param allowed_outbound_data_transfer_destinations:
        :type allowed_outbound_data_transfer_destinations: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param contact_sync_blocked: Indicates whether contacts can be synced to the user's device.
        :type contact_sync_blocked: bool
        :param data_backup_blocked: Indicates whether the backup of a managed app's data is blocked.
        :type data_backup_blocked: bool
        :param device_compliance_required: Indicates whether device compliance is required.
        :type device_compliance_required: bool
        :param disable_app_pin_if_device_pin_is_set: Indicates whether use of the app pin is required
         if the device pin is set.
        :type disable_app_pin_if_device_pin_is_set: bool
        :param fingerprint_blocked: Indicates whether use of the fingerprint reader is allowed in place
         of a pin if PinRequired is set to True.
        :type fingerprint_blocked: bool
        :param managed_browser:
        :type managed_browser: str or ~devices_corporate_management.models.MicrosoftGraphManagedBrowserType
        :param managed_browser_to_open_links_required: Indicates whether internet links should be
         opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol
         (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android).
        :type managed_browser_to_open_links_required: bool
        :param maximum_pin_retries: Maximum number of incorrect pin retry attempts before the managed
         app is either blocked or wiped.
        :type maximum_pin_retries: int
        :param minimum_pin_length: Minimum pin length required for an app-level pin if PinRequired is
         set to True.
        :type minimum_pin_length: int
        :param minimum_required_app_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_app_version: str
        :param minimum_required_os_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_os_version: str
        :param minimum_warning_app_version: Versions less than the specified version will result in
         warning message on the managed app.
        :type minimum_warning_app_version: str
        :param minimum_warning_os_version: Versions less than the specified version will result in
         warning message on the managed app from accessing company data.
        :type minimum_warning_os_version: str
        :param organizational_credentials_required: Indicates whether organizational credentials are
         required for app use.
        :type organizational_credentials_required: bool
        :param period_before_pin_reset: TimePeriod before the all-level pin must be reset if
         PinRequired is set to True.
        :type period_before_pin_reset: ~datetime.timedelta
        :param period_offline_before_access_check: The period after which access is checked when the
         device is not connected to the internet.
        :type period_offline_before_access_check: ~datetime.timedelta
        :param period_offline_before_wipe_is_enforced: The amount of time an app is allowed to remain
         disconnected from the internet before all managed data it is wiped.
        :type period_offline_before_wipe_is_enforced: ~datetime.timedelta
        :param period_online_before_access_check: The period after which access is checked when the
         device is connected to the internet.
        :type period_online_before_access_check: ~datetime.timedelta
        :param pin_character_set:
        :type pin_character_set: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppPinCharacterSet
        :param pin_required: Indicates whether an app-level pin is required.
        :type pin_required: bool
        :param print_blocked: Indicates whether printing is allowed from managed apps.
        :type print_blocked: bool
        :param save_as_blocked: Indicates whether users may use the 'Save As' menu item to save a copy
         of protected files.
        :type save_as_blocked: bool
        :param simple_pin_blocked: Indicates whether simplePin is blocked.
        :type simple_pin_blocked: bool
        :param app_data_encryption_type:
        :type app_data_encryption_type: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataEncryptionType
        :param custom_settings: A set of string key and string value pairs to be sent to the affected
         users, unalterned by this service.
        :type custom_settings: list[~devices_corporate_management.models.MicrosoftGraphKeyValuePair]
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param disable_app_encryption_if_device_encryption_is_enabled: When this setting is enabled,
         app level encryption is disabled if device level encryption is enabled. (Android only).
        :type disable_app_encryption_if_device_encryption_is_enabled: bool
        :param encrypt_app_data: Indicates whether managed-app data should be encrypted. (Android
         only).
        :type encrypt_app_data: bool
        :param face_id_blocked: Indicates whether use of the FaceID is allowed in place of a pin if
         PinRequired is set to True. (iOS Only).
        :type face_id_blocked: bool
        :param minimum_required_patch_version: Define the oldest required Android security patch level
         a user can have to gain secure access to the app. (Android only).
        :type minimum_required_patch_version: str
        :param minimum_required_sdk_version: Versions less than the specified version will block the
         managed app from accessing company data. (iOS Only).
        :type minimum_required_sdk_version: str
        :param minimum_warning_patch_version: Define the oldest recommended Android security patch
         level a user can have for secure access to the app. (Android only).
        :type minimum_warning_patch_version: str
        :param screen_capture_blocked: Indicates whether screen capture is blocked. (Android only).
        :type screen_capture_blocked: bool
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDefaultManagedAppProtection, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphDefaultManagedAppProtection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDefaultManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDefaultManagedAppProtection(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, allowed_data_storage_locations=allowed_data_storage_locations, allowed_inbound_data_transfer_sources=allowed_inbound_data_transfer_sources, allowed_outbound_clipboard_sharing_level=allowed_outbound_clipboard_sharing_level, allowed_outbound_data_transfer_destinations=allowed_outbound_data_transfer_destinations, contact_sync_blocked=contact_sync_blocked, data_backup_blocked=data_backup_blocked, device_compliance_required=device_compliance_required, disable_app_pin_if_device_pin_is_set=disable_app_pin_if_device_pin_is_set, fingerprint_blocked=fingerprint_blocked, managed_browser=managed_browser, managed_browser_to_open_links_required=managed_browser_to_open_links_required, maximum_pin_retries=maximum_pin_retries, minimum_pin_length=minimum_pin_length, minimum_required_app_version=minimum_required_app_version, minimum_required_os_version=minimum_required_os_version, minimum_warning_app_version=minimum_warning_app_version, minimum_warning_os_version=minimum_warning_os_version, organizational_credentials_required=organizational_credentials_required, period_before_pin_reset=period_before_pin_reset, period_offline_before_access_check=period_offline_before_access_check, period_offline_before_wipe_is_enforced=period_offline_before_wipe_is_enforced, period_online_before_access_check=period_online_before_access_check, pin_character_set=pin_character_set, pin_required=pin_required, print_blocked=print_blocked, save_as_blocked=save_as_blocked, simple_pin_blocked=simple_pin_blocked, app_data_encryption_type=app_data_encryption_type, custom_settings=custom_settings, deployed_app_count=deployed_app_count, disable_app_encryption_if_device_encryption_is_enabled=disable_app_encryption_if_device_encryption_is_enabled, encrypt_app_data=encrypt_app_data, face_id_blocked=face_id_blocked, minimum_required_patch_version=minimum_required_patch_version, minimum_required_sdk_version=minimum_required_sdk_version, minimum_warning_patch_version=minimum_warning_patch_version, screen_capture_blocked=screen_capture_blocked, apps=apps, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_default_managed_app_protection.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDefaultManagedAppProtection')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDefaultManagedAppProtection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_default_managed_app_protection.metadata = {'url': '/deviceAppManagement/defaultManagedAppProtections'}  # type: ignore

    async def get_default_managed_app_protection(
        self,
        default_managed_app_protection_id: str,
        select: Optional[List[Union[str, "models.Enum30"]]] = None,
        expand: Optional[List[Union[str, "models.Enum31"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDefaultManagedAppProtection":
        """Get defaultManagedAppProtections from deviceAppManagement.

        Get defaultManagedAppProtections from deviceAppManagement.

        :param default_managed_app_protection_id: key: id of defaultManagedAppProtection.
        :type default_managed_app_protection_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum30]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum31]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDefaultManagedAppProtection, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphDefaultManagedAppProtection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDefaultManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_default_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'defaultManagedAppProtection-id': self._serialize.url("default_managed_app_protection_id", default_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDefaultManagedAppProtection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_default_managed_app_protection.metadata = {'url': '/deviceAppManagement/defaultManagedAppProtections/{defaultManagedAppProtection-id}'}  # type: ignore

    async def update_default_managed_app_protection(
        self,
        default_managed_app_protection_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        allowed_data_storage_locations: Optional[List[Union[str, "models.MicrosoftGraphManagedAppDataStorageLocation"]]] = None,
        allowed_inbound_data_transfer_sources: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        allowed_outbound_clipboard_sharing_level: Optional[Union[str, "models.MicrosoftGraphManagedAppClipboardSharingLevel"]] = None,
        allowed_outbound_data_transfer_destinations: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        contact_sync_blocked: Optional[bool] = None,
        data_backup_blocked: Optional[bool] = None,
        device_compliance_required: Optional[bool] = None,
        disable_app_pin_if_device_pin_is_set: Optional[bool] = None,
        fingerprint_blocked: Optional[bool] = None,
        managed_browser: Optional[Union[str, "models.MicrosoftGraphManagedBrowserType"]] = None,
        managed_browser_to_open_links_required: Optional[bool] = None,
        maximum_pin_retries: Optional[int] = None,
        minimum_pin_length: Optional[int] = None,
        minimum_required_app_version: Optional[str] = None,
        minimum_required_os_version: Optional[str] = None,
        minimum_warning_app_version: Optional[str] = None,
        minimum_warning_os_version: Optional[str] = None,
        organizational_credentials_required: Optional[bool] = None,
        period_before_pin_reset: Optional[datetime.timedelta] = None,
        period_offline_before_access_check: Optional[datetime.timedelta] = None,
        period_offline_before_wipe_is_enforced: Optional[datetime.timedelta] = None,
        period_online_before_access_check: Optional[datetime.timedelta] = None,
        pin_character_set: Optional[Union[str, "models.MicrosoftGraphManagedAppPinCharacterSet"]] = None,
        pin_required: Optional[bool] = None,
        print_blocked: Optional[bool] = None,
        save_as_blocked: Optional[bool] = None,
        simple_pin_blocked: Optional[bool] = None,
        app_data_encryption_type: Optional[Union[str, "models.MicrosoftGraphManagedAppDataEncryptionType"]] = None,
        custom_settings: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        deployed_app_count: Optional[int] = None,
        disable_app_encryption_if_device_encryption_is_enabled: Optional[bool] = None,
        encrypt_app_data: Optional[bool] = None,
        face_id_blocked: Optional[bool] = None,
        minimum_required_patch_version: Optional[str] = None,
        minimum_required_sdk_version: Optional[str] = None,
        minimum_warning_patch_version: Optional[str] = None,
        screen_capture_blocked: Optional[bool] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property defaultManagedAppProtections in deviceAppManagement.

        Update the navigation property defaultManagedAppProtections in deviceAppManagement.

        :param default_managed_app_protection_id: key: id of defaultManagedAppProtection.
        :type default_managed_app_protection_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param allowed_data_storage_locations: Data storage locations where a user may store managed
         data.
        :type allowed_data_storage_locations: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataStorageLocation]
        :param allowed_inbound_data_transfer_sources:
        :type allowed_inbound_data_transfer_sources: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param allowed_outbound_clipboard_sharing_level:
        :type allowed_outbound_clipboard_sharing_level: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppClipboardSharingLevel
        :param allowed_outbound_data_transfer_destinations:
        :type allowed_outbound_data_transfer_destinations: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param contact_sync_blocked: Indicates whether contacts can be synced to the user's device.
        :type contact_sync_blocked: bool
        :param data_backup_blocked: Indicates whether the backup of a managed app's data is blocked.
        :type data_backup_blocked: bool
        :param device_compliance_required: Indicates whether device compliance is required.
        :type device_compliance_required: bool
        :param disable_app_pin_if_device_pin_is_set: Indicates whether use of the app pin is required
         if the device pin is set.
        :type disable_app_pin_if_device_pin_is_set: bool
        :param fingerprint_blocked: Indicates whether use of the fingerprint reader is allowed in place
         of a pin if PinRequired is set to True.
        :type fingerprint_blocked: bool
        :param managed_browser:
        :type managed_browser: str or ~devices_corporate_management.models.MicrosoftGraphManagedBrowserType
        :param managed_browser_to_open_links_required: Indicates whether internet links should be
         opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol
         (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android).
        :type managed_browser_to_open_links_required: bool
        :param maximum_pin_retries: Maximum number of incorrect pin retry attempts before the managed
         app is either blocked or wiped.
        :type maximum_pin_retries: int
        :param minimum_pin_length: Minimum pin length required for an app-level pin if PinRequired is
         set to True.
        :type minimum_pin_length: int
        :param minimum_required_app_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_app_version: str
        :param minimum_required_os_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_os_version: str
        :param minimum_warning_app_version: Versions less than the specified version will result in
         warning message on the managed app.
        :type minimum_warning_app_version: str
        :param minimum_warning_os_version: Versions less than the specified version will result in
         warning message on the managed app from accessing company data.
        :type minimum_warning_os_version: str
        :param organizational_credentials_required: Indicates whether organizational credentials are
         required for app use.
        :type organizational_credentials_required: bool
        :param period_before_pin_reset: TimePeriod before the all-level pin must be reset if
         PinRequired is set to True.
        :type period_before_pin_reset: ~datetime.timedelta
        :param period_offline_before_access_check: The period after which access is checked when the
         device is not connected to the internet.
        :type period_offline_before_access_check: ~datetime.timedelta
        :param period_offline_before_wipe_is_enforced: The amount of time an app is allowed to remain
         disconnected from the internet before all managed data it is wiped.
        :type period_offline_before_wipe_is_enforced: ~datetime.timedelta
        :param period_online_before_access_check: The period after which access is checked when the
         device is connected to the internet.
        :type period_online_before_access_check: ~datetime.timedelta
        :param pin_character_set:
        :type pin_character_set: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppPinCharacterSet
        :param pin_required: Indicates whether an app-level pin is required.
        :type pin_required: bool
        :param print_blocked: Indicates whether printing is allowed from managed apps.
        :type print_blocked: bool
        :param save_as_blocked: Indicates whether users may use the 'Save As' menu item to save a copy
         of protected files.
        :type save_as_blocked: bool
        :param simple_pin_blocked: Indicates whether simplePin is blocked.
        :type simple_pin_blocked: bool
        :param app_data_encryption_type:
        :type app_data_encryption_type: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataEncryptionType
        :param custom_settings: A set of string key and string value pairs to be sent to the affected
         users, unalterned by this service.
        :type custom_settings: list[~devices_corporate_management.models.MicrosoftGraphKeyValuePair]
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param disable_app_encryption_if_device_encryption_is_enabled: When this setting is enabled,
         app level encryption is disabled if device level encryption is enabled. (Android only).
        :type disable_app_encryption_if_device_encryption_is_enabled: bool
        :param encrypt_app_data: Indicates whether managed-app data should be encrypted. (Android
         only).
        :type encrypt_app_data: bool
        :param face_id_blocked: Indicates whether use of the FaceID is allowed in place of a pin if
         PinRequired is set to True. (iOS Only).
        :type face_id_blocked: bool
        :param minimum_required_patch_version: Define the oldest required Android security patch level
         a user can have to gain secure access to the app. (Android only).
        :type minimum_required_patch_version: str
        :param minimum_required_sdk_version: Versions less than the specified version will block the
         managed app from accessing company data. (iOS Only).
        :type minimum_required_sdk_version: str
        :param minimum_warning_patch_version: Define the oldest recommended Android security patch
         level a user can have for secure access to the app. (Android only).
        :type minimum_warning_patch_version: str
        :param screen_capture_blocked: Indicates whether screen capture is blocked. (Android only).
        :type screen_capture_blocked: bool
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDefaultManagedAppProtection(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, allowed_data_storage_locations=allowed_data_storage_locations, allowed_inbound_data_transfer_sources=allowed_inbound_data_transfer_sources, allowed_outbound_clipboard_sharing_level=allowed_outbound_clipboard_sharing_level, allowed_outbound_data_transfer_destinations=allowed_outbound_data_transfer_destinations, contact_sync_blocked=contact_sync_blocked, data_backup_blocked=data_backup_blocked, device_compliance_required=device_compliance_required, disable_app_pin_if_device_pin_is_set=disable_app_pin_if_device_pin_is_set, fingerprint_blocked=fingerprint_blocked, managed_browser=managed_browser, managed_browser_to_open_links_required=managed_browser_to_open_links_required, maximum_pin_retries=maximum_pin_retries, minimum_pin_length=minimum_pin_length, minimum_required_app_version=minimum_required_app_version, minimum_required_os_version=minimum_required_os_version, minimum_warning_app_version=minimum_warning_app_version, minimum_warning_os_version=minimum_warning_os_version, organizational_credentials_required=organizational_credentials_required, period_before_pin_reset=period_before_pin_reset, period_offline_before_access_check=period_offline_before_access_check, period_offline_before_wipe_is_enforced=period_offline_before_wipe_is_enforced, period_online_before_access_check=period_online_before_access_check, pin_character_set=pin_character_set, pin_required=pin_required, print_blocked=print_blocked, save_as_blocked=save_as_blocked, simple_pin_blocked=simple_pin_blocked, app_data_encryption_type=app_data_encryption_type, custom_settings=custom_settings, deployed_app_count=deployed_app_count, disable_app_encryption_if_device_encryption_is_enabled=disable_app_encryption_if_device_encryption_is_enabled, encrypt_app_data=encrypt_app_data, face_id_blocked=face_id_blocked, minimum_required_patch_version=minimum_required_patch_version, minimum_required_sdk_version=minimum_required_sdk_version, minimum_warning_patch_version=minimum_warning_patch_version, screen_capture_blocked=screen_capture_blocked, apps=apps, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_default_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'defaultManagedAppProtection-id': self._serialize.url("default_managed_app_protection_id", default_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDefaultManagedAppProtection')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_default_managed_app_protection.metadata = {'url': '/deviceAppManagement/defaultManagedAppProtections/{defaultManagedAppProtection-id}'}  # type: ignore

    async def delete_default_managed_app_protection(
        self,
        default_managed_app_protection_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property defaultManagedAppProtections for deviceAppManagement.

        Delete navigation property defaultManagedAppProtections for deviceAppManagement.

        :param default_managed_app_protection_id: key: id of defaultManagedAppProtection.
        :type default_managed_app_protection_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_default_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'defaultManagedAppProtection-id': self._serialize.url("default_managed_app_protection_id", default_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_default_managed_app_protection.metadata = {'url': '/deviceAppManagement/defaultManagedAppProtections/{defaultManagedAppProtection-id}'}  # type: ignore

    def list_io_managed_app_protection(
        self,
        orderby: Optional[List[Union[str, "models.Enum36"]]] = None,
        select: Optional[List[Union[str, "models.Enum37"]]] = None,
        expand: Optional[List[Union[str, "models.Enum38"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfIosManagedAppProtection"]:
        """Get iosManagedAppProtections from deviceAppManagement.

        Get iosManagedAppProtections from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum36]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum37]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum38]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfIosManagedAppProtection or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfIosManagedAppProtection]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfIosManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_io_managed_app_protection.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfIosManagedAppProtection', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_io_managed_app_protection.metadata = {'url': '/deviceAppManagement/iosManagedAppProtections'}  # type: ignore

    async def create_io_managed_app_protection(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        allowed_data_storage_locations: Optional[List[Union[str, "models.MicrosoftGraphManagedAppDataStorageLocation"]]] = None,
        allowed_inbound_data_transfer_sources: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        allowed_outbound_clipboard_sharing_level: Optional[Union[str, "models.MicrosoftGraphManagedAppClipboardSharingLevel"]] = None,
        allowed_outbound_data_transfer_destinations: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        contact_sync_blocked: Optional[bool] = None,
        data_backup_blocked: Optional[bool] = None,
        device_compliance_required: Optional[bool] = None,
        disable_app_pin_if_device_pin_is_set: Optional[bool] = None,
        fingerprint_blocked: Optional[bool] = None,
        managed_browser: Optional[Union[str, "models.MicrosoftGraphManagedBrowserType"]] = None,
        managed_browser_to_open_links_required: Optional[bool] = None,
        maximum_pin_retries: Optional[int] = None,
        minimum_pin_length: Optional[int] = None,
        minimum_required_app_version: Optional[str] = None,
        minimum_required_os_version: Optional[str] = None,
        minimum_warning_app_version: Optional[str] = None,
        minimum_warning_os_version: Optional[str] = None,
        organizational_credentials_required: Optional[bool] = None,
        period_before_pin_reset: Optional[datetime.timedelta] = None,
        period_offline_before_access_check: Optional[datetime.timedelta] = None,
        period_offline_before_wipe_is_enforced: Optional[datetime.timedelta] = None,
        period_online_before_access_check: Optional[datetime.timedelta] = None,
        pin_character_set: Optional[Union[str, "models.MicrosoftGraphManagedAppPinCharacterSet"]] = None,
        pin_required: Optional[bool] = None,
        print_blocked: Optional[bool] = None,
        save_as_blocked: Optional[bool] = None,
        simple_pin_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        app_data_encryption_type: Optional[Union[str, "models.MicrosoftGraphManagedAppDataEncryptionType"]] = None,
        custom_browser_protocol: Optional[str] = None,
        deployed_app_count: Optional[int] = None,
        face_id_blocked: Optional[bool] = None,
        minimum_required_sdk_version: Optional[str] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphIosManagedAppProtection":
        """Create new navigation property to iosManagedAppProtections for deviceAppManagement.

        Create new navigation property to iosManagedAppProtections for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param allowed_data_storage_locations: Data storage locations where a user may store managed
         data.
        :type allowed_data_storage_locations: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataStorageLocation]
        :param allowed_inbound_data_transfer_sources:
        :type allowed_inbound_data_transfer_sources: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param allowed_outbound_clipboard_sharing_level:
        :type allowed_outbound_clipboard_sharing_level: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppClipboardSharingLevel
        :param allowed_outbound_data_transfer_destinations:
        :type allowed_outbound_data_transfer_destinations: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param contact_sync_blocked: Indicates whether contacts can be synced to the user's device.
        :type contact_sync_blocked: bool
        :param data_backup_blocked: Indicates whether the backup of a managed app's data is blocked.
        :type data_backup_blocked: bool
        :param device_compliance_required: Indicates whether device compliance is required.
        :type device_compliance_required: bool
        :param disable_app_pin_if_device_pin_is_set: Indicates whether use of the app pin is required
         if the device pin is set.
        :type disable_app_pin_if_device_pin_is_set: bool
        :param fingerprint_blocked: Indicates whether use of the fingerprint reader is allowed in place
         of a pin if PinRequired is set to True.
        :type fingerprint_blocked: bool
        :param managed_browser:
        :type managed_browser: str or ~devices_corporate_management.models.MicrosoftGraphManagedBrowserType
        :param managed_browser_to_open_links_required: Indicates whether internet links should be
         opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol
         (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android).
        :type managed_browser_to_open_links_required: bool
        :param maximum_pin_retries: Maximum number of incorrect pin retry attempts before the managed
         app is either blocked or wiped.
        :type maximum_pin_retries: int
        :param minimum_pin_length: Minimum pin length required for an app-level pin if PinRequired is
         set to True.
        :type minimum_pin_length: int
        :param minimum_required_app_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_app_version: str
        :param minimum_required_os_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_os_version: str
        :param minimum_warning_app_version: Versions less than the specified version will result in
         warning message on the managed app.
        :type minimum_warning_app_version: str
        :param minimum_warning_os_version: Versions less than the specified version will result in
         warning message on the managed app from accessing company data.
        :type minimum_warning_os_version: str
        :param organizational_credentials_required: Indicates whether organizational credentials are
         required for app use.
        :type organizational_credentials_required: bool
        :param period_before_pin_reset: TimePeriod before the all-level pin must be reset if
         PinRequired is set to True.
        :type period_before_pin_reset: ~datetime.timedelta
        :param period_offline_before_access_check: The period after which access is checked when the
         device is not connected to the internet.
        :type period_offline_before_access_check: ~datetime.timedelta
        :param period_offline_before_wipe_is_enforced: The amount of time an app is allowed to remain
         disconnected from the internet before all managed data it is wiped.
        :type period_offline_before_wipe_is_enforced: ~datetime.timedelta
        :param period_online_before_access_check: The period after which access is checked when the
         device is connected to the internet.
        :type period_online_before_access_check: ~datetime.timedelta
        :param pin_character_set:
        :type pin_character_set: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppPinCharacterSet
        :param pin_required: Indicates whether an app-level pin is required.
        :type pin_required: bool
        :param print_blocked: Indicates whether printing is allowed from managed apps.
        :type print_blocked: bool
        :param save_as_blocked: Indicates whether users may use the 'Save As' menu item to save a copy
         of protected files.
        :type save_as_blocked: bool
        :param simple_pin_blocked: Indicates whether simplePin is blocked.
        :type simple_pin_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param assignments: Navigation property to list of inclusion and exclusion groups to which the
         policy is deployed.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param app_data_encryption_type:
        :type app_data_encryption_type: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataEncryptionType
        :param custom_browser_protocol: A custom browser protocol to open weblink on iOS. When this
         property is configured, ManagedBrowserToOpenLinksRequired should be true.
        :type custom_browser_protocol: str
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param face_id_blocked: Indicates whether use of the FaceID is allowed in place of a pin if
         PinRequired is set to True.
        :type face_id_blocked: bool
        :param minimum_required_sdk_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_sdk_version: str
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIosManagedAppProtection, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphIosManagedAppProtection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIosManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphIosManagedAppProtection(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, allowed_data_storage_locations=allowed_data_storage_locations, allowed_inbound_data_transfer_sources=allowed_inbound_data_transfer_sources, allowed_outbound_clipboard_sharing_level=allowed_outbound_clipboard_sharing_level, allowed_outbound_data_transfer_destinations=allowed_outbound_data_transfer_destinations, contact_sync_blocked=contact_sync_blocked, data_backup_blocked=data_backup_blocked, device_compliance_required=device_compliance_required, disable_app_pin_if_device_pin_is_set=disable_app_pin_if_device_pin_is_set, fingerprint_blocked=fingerprint_blocked, managed_browser=managed_browser, managed_browser_to_open_links_required=managed_browser_to_open_links_required, maximum_pin_retries=maximum_pin_retries, minimum_pin_length=minimum_pin_length, minimum_required_app_version=minimum_required_app_version, minimum_required_os_version=minimum_required_os_version, minimum_warning_app_version=minimum_warning_app_version, minimum_warning_os_version=minimum_warning_os_version, organizational_credentials_required=organizational_credentials_required, period_before_pin_reset=period_before_pin_reset, period_offline_before_access_check=period_offline_before_access_check, period_offline_before_wipe_is_enforced=period_offline_before_wipe_is_enforced, period_online_before_access_check=period_online_before_access_check, pin_character_set=pin_character_set, pin_required=pin_required, print_blocked=print_blocked, save_as_blocked=save_as_blocked, simple_pin_blocked=simple_pin_blocked, is_assigned=is_assigned, assignments=assignments, app_data_encryption_type=app_data_encryption_type, custom_browser_protocol=custom_browser_protocol, deployed_app_count=deployed_app_count, face_id_blocked=face_id_blocked, minimum_required_sdk_version=minimum_required_sdk_version, apps=apps, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_io_managed_app_protection.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphIosManagedAppProtection')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIosManagedAppProtection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_io_managed_app_protection.metadata = {'url': '/deviceAppManagement/iosManagedAppProtections'}  # type: ignore

    async def get_io_managed_app_protection(
        self,
        ios_managed_app_protection_id: str,
        select: Optional[List[Union[str, "models.Enum39"]]] = None,
        expand: Optional[List[Union[str, "models.Enum40"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphIosManagedAppProtection":
        """Get iosManagedAppProtections from deviceAppManagement.

        Get iosManagedAppProtections from deviceAppManagement.

        :param ios_managed_app_protection_id: key: id of iosManagedAppProtection.
        :type ios_managed_app_protection_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum39]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum40]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIosManagedAppProtection, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphIosManagedAppProtection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIosManagedAppProtection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_io_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'iosManagedAppProtection-id': self._serialize.url("ios_managed_app_protection_id", ios_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIosManagedAppProtection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_io_managed_app_protection.metadata = {'url': '/deviceAppManagement/iosManagedAppProtections/{iosManagedAppProtection-id}'}  # type: ignore

    async def update_io_managed_app_protection(
        self,
        ios_managed_app_protection_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        allowed_data_storage_locations: Optional[List[Union[str, "models.MicrosoftGraphManagedAppDataStorageLocation"]]] = None,
        allowed_inbound_data_transfer_sources: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        allowed_outbound_clipboard_sharing_level: Optional[Union[str, "models.MicrosoftGraphManagedAppClipboardSharingLevel"]] = None,
        allowed_outbound_data_transfer_destinations: Optional[Union[str, "models.MicrosoftGraphManagedAppDataTransferLevel"]] = None,
        contact_sync_blocked: Optional[bool] = None,
        data_backup_blocked: Optional[bool] = None,
        device_compliance_required: Optional[bool] = None,
        disable_app_pin_if_device_pin_is_set: Optional[bool] = None,
        fingerprint_blocked: Optional[bool] = None,
        managed_browser: Optional[Union[str, "models.MicrosoftGraphManagedBrowserType"]] = None,
        managed_browser_to_open_links_required: Optional[bool] = None,
        maximum_pin_retries: Optional[int] = None,
        minimum_pin_length: Optional[int] = None,
        minimum_required_app_version: Optional[str] = None,
        minimum_required_os_version: Optional[str] = None,
        minimum_warning_app_version: Optional[str] = None,
        minimum_warning_os_version: Optional[str] = None,
        organizational_credentials_required: Optional[bool] = None,
        period_before_pin_reset: Optional[datetime.timedelta] = None,
        period_offline_before_access_check: Optional[datetime.timedelta] = None,
        period_offline_before_wipe_is_enforced: Optional[datetime.timedelta] = None,
        period_online_before_access_check: Optional[datetime.timedelta] = None,
        pin_character_set: Optional[Union[str, "models.MicrosoftGraphManagedAppPinCharacterSet"]] = None,
        pin_required: Optional[bool] = None,
        print_blocked: Optional[bool] = None,
        save_as_blocked: Optional[bool] = None,
        simple_pin_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        app_data_encryption_type: Optional[Union[str, "models.MicrosoftGraphManagedAppDataEncryptionType"]] = None,
        custom_browser_protocol: Optional[str] = None,
        deployed_app_count: Optional[int] = None,
        face_id_blocked: Optional[bool] = None,
        minimum_required_sdk_version: Optional[str] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property iosManagedAppProtections in deviceAppManagement.

        Update the navigation property iosManagedAppProtections in deviceAppManagement.

        :param ios_managed_app_protection_id: key: id of iosManagedAppProtection.
        :type ios_managed_app_protection_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param allowed_data_storage_locations: Data storage locations where a user may store managed
         data.
        :type allowed_data_storage_locations: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataStorageLocation]
        :param allowed_inbound_data_transfer_sources:
        :type allowed_inbound_data_transfer_sources: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param allowed_outbound_clipboard_sharing_level:
        :type allowed_outbound_clipboard_sharing_level: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppClipboardSharingLevel
        :param allowed_outbound_data_transfer_destinations:
        :type allowed_outbound_data_transfer_destinations: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataTransferLevel
        :param contact_sync_blocked: Indicates whether contacts can be synced to the user's device.
        :type contact_sync_blocked: bool
        :param data_backup_blocked: Indicates whether the backup of a managed app's data is blocked.
        :type data_backup_blocked: bool
        :param device_compliance_required: Indicates whether device compliance is required.
        :type device_compliance_required: bool
        :param disable_app_pin_if_device_pin_is_set: Indicates whether use of the app pin is required
         if the device pin is set.
        :type disable_app_pin_if_device_pin_is_set: bool
        :param fingerprint_blocked: Indicates whether use of the fingerprint reader is allowed in place
         of a pin if PinRequired is set to True.
        :type fingerprint_blocked: bool
        :param managed_browser:
        :type managed_browser: str or ~devices_corporate_management.models.MicrosoftGraphManagedBrowserType
        :param managed_browser_to_open_links_required: Indicates whether internet links should be
         opened in the managed browser app, or any custom browser specified by CustomBrowserProtocol
         (for iOS) or CustomBrowserPackageId/CustomBrowserDisplayName (for Android).
        :type managed_browser_to_open_links_required: bool
        :param maximum_pin_retries: Maximum number of incorrect pin retry attempts before the managed
         app is either blocked or wiped.
        :type maximum_pin_retries: int
        :param minimum_pin_length: Minimum pin length required for an app-level pin if PinRequired is
         set to True.
        :type minimum_pin_length: int
        :param minimum_required_app_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_app_version: str
        :param minimum_required_os_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_os_version: str
        :param minimum_warning_app_version: Versions less than the specified version will result in
         warning message on the managed app.
        :type minimum_warning_app_version: str
        :param minimum_warning_os_version: Versions less than the specified version will result in
         warning message on the managed app from accessing company data.
        :type minimum_warning_os_version: str
        :param organizational_credentials_required: Indicates whether organizational credentials are
         required for app use.
        :type organizational_credentials_required: bool
        :param period_before_pin_reset: TimePeriod before the all-level pin must be reset if
         PinRequired is set to True.
        :type period_before_pin_reset: ~datetime.timedelta
        :param period_offline_before_access_check: The period after which access is checked when the
         device is not connected to the internet.
        :type period_offline_before_access_check: ~datetime.timedelta
        :param period_offline_before_wipe_is_enforced: The amount of time an app is allowed to remain
         disconnected from the internet before all managed data it is wiped.
        :type period_offline_before_wipe_is_enforced: ~datetime.timedelta
        :param period_online_before_access_check: The period after which access is checked when the
         device is connected to the internet.
        :type period_online_before_access_check: ~datetime.timedelta
        :param pin_character_set:
        :type pin_character_set: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppPinCharacterSet
        :param pin_required: Indicates whether an app-level pin is required.
        :type pin_required: bool
        :param print_blocked: Indicates whether printing is allowed from managed apps.
        :type print_blocked: bool
        :param save_as_blocked: Indicates whether users may use the 'Save As' menu item to save a copy
         of protected files.
        :type save_as_blocked: bool
        :param simple_pin_blocked: Indicates whether simplePin is blocked.
        :type simple_pin_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param assignments: Navigation property to list of inclusion and exclusion groups to which the
         policy is deployed.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param app_data_encryption_type:
        :type app_data_encryption_type: str or ~devices_corporate_management.models.MicrosoftGraphManagedAppDataEncryptionType
        :param custom_browser_protocol: A custom browser protocol to open weblink on iOS. When this
         property is configured, ManagedBrowserToOpenLinksRequired should be true.
        :type custom_browser_protocol: str
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param face_id_blocked: Indicates whether use of the FaceID is allowed in place of a pin if
         PinRequired is set to True.
        :type face_id_blocked: bool
        :param minimum_required_sdk_version: Versions less than the specified version will block the
         managed app from accessing company data.
        :type minimum_required_sdk_version: str
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphIosManagedAppProtection(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, allowed_data_storage_locations=allowed_data_storage_locations, allowed_inbound_data_transfer_sources=allowed_inbound_data_transfer_sources, allowed_outbound_clipboard_sharing_level=allowed_outbound_clipboard_sharing_level, allowed_outbound_data_transfer_destinations=allowed_outbound_data_transfer_destinations, contact_sync_blocked=contact_sync_blocked, data_backup_blocked=data_backup_blocked, device_compliance_required=device_compliance_required, disable_app_pin_if_device_pin_is_set=disable_app_pin_if_device_pin_is_set, fingerprint_blocked=fingerprint_blocked, managed_browser=managed_browser, managed_browser_to_open_links_required=managed_browser_to_open_links_required, maximum_pin_retries=maximum_pin_retries, minimum_pin_length=minimum_pin_length, minimum_required_app_version=minimum_required_app_version, minimum_required_os_version=minimum_required_os_version, minimum_warning_app_version=minimum_warning_app_version, minimum_warning_os_version=minimum_warning_os_version, organizational_credentials_required=organizational_credentials_required, period_before_pin_reset=period_before_pin_reset, period_offline_before_access_check=period_offline_before_access_check, period_offline_before_wipe_is_enforced=period_offline_before_wipe_is_enforced, period_online_before_access_check=period_online_before_access_check, pin_character_set=pin_character_set, pin_required=pin_required, print_blocked=print_blocked, save_as_blocked=save_as_blocked, simple_pin_blocked=simple_pin_blocked, is_assigned=is_assigned, assignments=assignments, app_data_encryption_type=app_data_encryption_type, custom_browser_protocol=custom_browser_protocol, deployed_app_count=deployed_app_count, face_id_blocked=face_id_blocked, minimum_required_sdk_version=minimum_required_sdk_version, apps=apps, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_io_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'iosManagedAppProtection-id': self._serialize.url("ios_managed_app_protection_id", ios_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphIosManagedAppProtection')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_io_managed_app_protection.metadata = {'url': '/deviceAppManagement/iosManagedAppProtections/{iosManagedAppProtection-id}'}  # type: ignore

    async def delete_io_managed_app_protection(
        self,
        ios_managed_app_protection_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property iosManagedAppProtections for deviceAppManagement.

        Delete navigation property iosManagedAppProtections for deviceAppManagement.

        :param ios_managed_app_protection_id: key: id of iosManagedAppProtection.
        :type ios_managed_app_protection_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_io_managed_app_protection.metadata['url']  # type: ignore
        path_format_arguments = {
            'iosManagedAppProtection-id': self._serialize.url("ios_managed_app_protection_id", ios_managed_app_protection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_io_managed_app_protection.metadata = {'url': '/deviceAppManagement/iosManagedAppProtections/{iosManagedAppProtection-id}'}  # type: ignore

    def list_managed_app_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum45"]]] = None,
        select: Optional[List[Union[str, "models.Enum46"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedAppPolicy"]:
        """Get managedAppPolicies from deviceAppManagement.

        Get managedAppPolicies from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum45]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum46]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedAppPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedAppPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedAppPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_managed_app_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedAppPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_managed_app_policy.metadata = {'url': '/deviceAppManagement/managedAppPolicies'}  # type: ignore

    async def create_managed_app_policy(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedAppPolicy":
        """Create new navigation property to managedAppPolicies for deviceAppManagement.

        Create new navigation property to managedAppPolicies for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedAppPolicy, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedAppPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedAppPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedAppPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_managed_app_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedAppPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedAppPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_managed_app_policy.metadata = {'url': '/deviceAppManagement/managedAppPolicies'}  # type: ignore

    async def get_managed_app_policy(
        self,
        managed_app_policy_id: str,
        select: Optional[List[Union[str, "models.Enum47"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedAppPolicy":
        """Get managedAppPolicies from deviceAppManagement.

        Get managedAppPolicies from deviceAppManagement.

        :param managed_app_policy_id: key: id of managedAppPolicy.
        :type managed_app_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum47]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedAppPolicy, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedAppPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedAppPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_managed_app_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppPolicy-id': self._serialize.url("managed_app_policy_id", managed_app_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedAppPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_managed_app_policy.metadata = {'url': '/deviceAppManagement/managedAppPolicies/{managedAppPolicy-id}'}  # type: ignore

    async def update_managed_app_policy(
        self,
        managed_app_policy_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property managedAppPolicies in deviceAppManagement.

        Update the navigation property managedAppPolicies in deviceAppManagement.

        :param managed_app_policy_id: key: id of managedAppPolicy.
        :type managed_app_policy_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedAppPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_managed_app_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppPolicy-id': self._serialize.url("managed_app_policy_id", managed_app_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedAppPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_managed_app_policy.metadata = {'url': '/deviceAppManagement/managedAppPolicies/{managedAppPolicy-id}'}  # type: ignore

    async def delete_managed_app_policy(
        self,
        managed_app_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property managedAppPolicies for deviceAppManagement.

        Delete navigation property managedAppPolicies for deviceAppManagement.

        :param managed_app_policy_id: key: id of managedAppPolicy.
        :type managed_app_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_managed_app_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppPolicy-id': self._serialize.url("managed_app_policy_id", managed_app_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_managed_app_policy.metadata = {'url': '/deviceAppManagement/managedAppPolicies/{managedAppPolicy-id}'}  # type: ignore

    def list_managed_app_registration(
        self,
        orderby: Optional[List[Union[str, "models.Enum48"]]] = None,
        select: Optional[List[Union[str, "models.Enum49"]]] = None,
        expand: Optional[List[Union[str, "models.Enum50"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedAppRegistration"]:
        """Get managedAppRegistrations from deviceAppManagement.

        Get managedAppRegistrations from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum48]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum49]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum50]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedAppRegistration or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedAppRegistration]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedAppRegistration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_managed_app_registration.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedAppRegistration', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_managed_app_registration.metadata = {'url': '/deviceAppManagement/managedAppRegistrations'}  # type: ignore

    async def create_managed_app_registration(
        self,
        id: Optional[str] = None,
        app_identifier: Optional[Dict[str, object]] = None,
        application_version: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        device_name: Optional[str] = None,
        device_tag: Optional[str] = None,
        device_type: Optional[str] = None,
        flagged_reasons: Optional[List[Union[str, "models.MicrosoftGraphManagedAppFlaggedReason"]]] = None,
        last_sync_date_time: Optional[datetime.datetime] = None,
        management_sdk_version: Optional[str] = None,
        platform_version: Optional[str] = None,
        user_id: Optional[str] = None,
        version: Optional[str] = None,
        applied_policies: Optional[List["models.MicrosoftGraphManagedAppPolicy"]] = None,
        intended_policies: Optional[List["models.MicrosoftGraphManagedAppPolicy"]] = None,
        operations: Optional[List["models.MicrosoftGraphManagedAppOperation"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedAppRegistration":
        """Create new navigation property to managedAppRegistrations for deviceAppManagement.

        Create new navigation property to managedAppRegistrations for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param app_identifier: The identifier for a mobile app.
        :type app_identifier: dict[str, object]
        :param application_version: App version.
        :type application_version: str
        :param created_date_time: Date and time of creation.
        :type created_date_time: ~datetime.datetime
        :param device_name: Host device name.
        :type device_name: str
        :param device_tag: App management SDK generated tag, which helps relate apps hosted on the same
         device. Not guaranteed to relate apps in all conditions.
        :type device_tag: str
        :param device_type: Host device type.
        :type device_type: str
        :param flagged_reasons: Zero or more reasons an app registration is flagged. E.g. app running
         on rooted device.
        :type flagged_reasons: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppFlaggedReason]
        :param last_sync_date_time: Date and time of last the app synced with management service.
        :type last_sync_date_time: ~datetime.datetime
        :param management_sdk_version: App management SDK version.
        :type management_sdk_version: str
        :param platform_version: Operating System version.
        :type platform_version: str
        :param user_id: The user Id to who this app registration belongs.
        :type user_id: str
        :param version: Version of the entity.
        :type version: str
        :param applied_policies: Zero or more policys already applied on the registered app when it
         last synchronized with managment service.
        :type applied_policies: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicy]
        :param intended_policies: Zero or more policies admin intended for the app as of now.
        :type intended_policies: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicy]
        :param operations: Zero or more long running operations triggered on the app registration.
        :type operations: list[~devices_corporate_management.models.MicrosoftGraphManagedAppOperation]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedAppRegistration, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedAppRegistration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedAppRegistration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedAppRegistration(id=id, app_identifier=app_identifier, application_version=application_version, created_date_time=created_date_time, device_name=device_name, device_tag=device_tag, device_type=device_type, flagged_reasons=flagged_reasons, last_sync_date_time=last_sync_date_time, management_sdk_version=management_sdk_version, platform_version=platform_version, user_id=user_id, version=version, applied_policies=applied_policies, intended_policies=intended_policies, operations=operations)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_managed_app_registration.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedAppRegistration')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedAppRegistration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_managed_app_registration.metadata = {'url': '/deviceAppManagement/managedAppRegistrations'}  # type: ignore

    async def get_managed_app_registration(
        self,
        managed_app_registration_id: str,
        select: Optional[List[Union[str, "models.Enum51"]]] = None,
        expand: Optional[List[Union[str, "models.Enum52"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedAppRegistration":
        """Get managedAppRegistrations from deviceAppManagement.

        Get managedAppRegistrations from deviceAppManagement.

        :param managed_app_registration_id: key: id of managedAppRegistration.
        :type managed_app_registration_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum51]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum52]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedAppRegistration, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedAppRegistration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedAppRegistration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_managed_app_registration.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppRegistration-id': self._serialize.url("managed_app_registration_id", managed_app_registration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedAppRegistration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_managed_app_registration.metadata = {'url': '/deviceAppManagement/managedAppRegistrations/{managedAppRegistration-id}'}  # type: ignore

    async def update_managed_app_registration(
        self,
        managed_app_registration_id: str,
        id: Optional[str] = None,
        app_identifier: Optional[Dict[str, object]] = None,
        application_version: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        device_name: Optional[str] = None,
        device_tag: Optional[str] = None,
        device_type: Optional[str] = None,
        flagged_reasons: Optional[List[Union[str, "models.MicrosoftGraphManagedAppFlaggedReason"]]] = None,
        last_sync_date_time: Optional[datetime.datetime] = None,
        management_sdk_version: Optional[str] = None,
        platform_version: Optional[str] = None,
        user_id: Optional[str] = None,
        version: Optional[str] = None,
        applied_policies: Optional[List["models.MicrosoftGraphManagedAppPolicy"]] = None,
        intended_policies: Optional[List["models.MicrosoftGraphManagedAppPolicy"]] = None,
        operations: Optional[List["models.MicrosoftGraphManagedAppOperation"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property managedAppRegistrations in deviceAppManagement.

        Update the navigation property managedAppRegistrations in deviceAppManagement.

        :param managed_app_registration_id: key: id of managedAppRegistration.
        :type managed_app_registration_id: str
        :param id: Read-only.
        :type id: str
        :param app_identifier: The identifier for a mobile app.
        :type app_identifier: dict[str, object]
        :param application_version: App version.
        :type application_version: str
        :param created_date_time: Date and time of creation.
        :type created_date_time: ~datetime.datetime
        :param device_name: Host device name.
        :type device_name: str
        :param device_tag: App management SDK generated tag, which helps relate apps hosted on the same
         device. Not guaranteed to relate apps in all conditions.
        :type device_tag: str
        :param device_type: Host device type.
        :type device_type: str
        :param flagged_reasons: Zero or more reasons an app registration is flagged. E.g. app running
         on rooted device.
        :type flagged_reasons: list[str or ~devices_corporate_management.models.MicrosoftGraphManagedAppFlaggedReason]
        :param last_sync_date_time: Date and time of last the app synced with management service.
        :type last_sync_date_time: ~datetime.datetime
        :param management_sdk_version: App management SDK version.
        :type management_sdk_version: str
        :param platform_version: Operating System version.
        :type platform_version: str
        :param user_id: The user Id to who this app registration belongs.
        :type user_id: str
        :param version: Version of the entity.
        :type version: str
        :param applied_policies: Zero or more policys already applied on the registered app when it
         last synchronized with managment service.
        :type applied_policies: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicy]
        :param intended_policies: Zero or more policies admin intended for the app as of now.
        :type intended_policies: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicy]
        :param operations: Zero or more long running operations triggered on the app registration.
        :type operations: list[~devices_corporate_management.models.MicrosoftGraphManagedAppOperation]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedAppRegistration(id=id, app_identifier=app_identifier, application_version=application_version, created_date_time=created_date_time, device_name=device_name, device_tag=device_tag, device_type=device_type, flagged_reasons=flagged_reasons, last_sync_date_time=last_sync_date_time, management_sdk_version=management_sdk_version, platform_version=platform_version, user_id=user_id, version=version, applied_policies=applied_policies, intended_policies=intended_policies, operations=operations)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_managed_app_registration.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppRegistration-id': self._serialize.url("managed_app_registration_id", managed_app_registration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedAppRegistration')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_managed_app_registration.metadata = {'url': '/deviceAppManagement/managedAppRegistrations/{managedAppRegistration-id}'}  # type: ignore

    async def delete_managed_app_registration(
        self,
        managed_app_registration_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property managedAppRegistrations for deviceAppManagement.

        Delete navigation property managedAppRegistrations for deviceAppManagement.

        :param managed_app_registration_id: key: id of managedAppRegistration.
        :type managed_app_registration_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_managed_app_registration.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppRegistration-id': self._serialize.url("managed_app_registration_id", managed_app_registration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_managed_app_registration.metadata = {'url': '/deviceAppManagement/managedAppRegistrations/{managedAppRegistration-id}'}  # type: ignore

    def list_managed_app_statuses(
        self,
        orderby: Optional[List[Union[str, "models.Enum62"]]] = None,
        select: Optional[List[Union[str, "models.Enum63"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedAppStatus"]:
        """Get managedAppStatuses from deviceAppManagement.

        Get managedAppStatuses from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum62]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum63]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedAppStatus or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedAppStatus]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedAppStatus"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_managed_app_statuses.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedAppStatus', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_managed_app_statuses.metadata = {'url': '/deviceAppManagement/managedAppStatuses'}  # type: ignore

    async def create_managed_app_statuses(
        self,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedAppStatus":
        """Create new navigation property to managedAppStatuses for deviceAppManagement.

        Create new navigation property to managedAppStatuses for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param display_name: Friendly name of the status report.
        :type display_name: str
        :param version: Version of the entity.
        :type version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedAppStatus, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedAppStatus
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedAppStatus"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedAppStatus(id=id, display_name=display_name, version=version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_managed_app_statuses.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedAppStatus')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedAppStatus', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_managed_app_statuses.metadata = {'url': '/deviceAppManagement/managedAppStatuses'}  # type: ignore

    async def get_managed_app_statuses(
        self,
        managed_app_status_id: str,
        select: Optional[List[Union[str, "models.Enum64"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedAppStatus":
        """Get managedAppStatuses from deviceAppManagement.

        Get managedAppStatuses from deviceAppManagement.

        :param managed_app_status_id: key: id of managedAppStatus.
        :type managed_app_status_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum64]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedAppStatus, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedAppStatus
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedAppStatus"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_managed_app_statuses.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppStatus-id': self._serialize.url("managed_app_status_id", managed_app_status_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedAppStatus', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_managed_app_statuses.metadata = {'url': '/deviceAppManagement/managedAppStatuses/{managedAppStatus-id}'}  # type: ignore

    async def update_managed_app_statuses(
        self,
        managed_app_status_id: str,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        version: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property managedAppStatuses in deviceAppManagement.

        Update the navigation property managedAppStatuses in deviceAppManagement.

        :param managed_app_status_id: key: id of managedAppStatus.
        :type managed_app_status_id: str
        :param id: Read-only.
        :type id: str
        :param display_name: Friendly name of the status report.
        :type display_name: str
        :param version: Version of the entity.
        :type version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedAppStatus(id=id, display_name=display_name, version=version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_managed_app_statuses.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppStatus-id': self._serialize.url("managed_app_status_id", managed_app_status_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedAppStatus')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_managed_app_statuses.metadata = {'url': '/deviceAppManagement/managedAppStatuses/{managedAppStatus-id}'}  # type: ignore

    async def delete_managed_app_statuses(
        self,
        managed_app_status_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property managedAppStatuses for deviceAppManagement.

        Delete navigation property managedAppStatuses for deviceAppManagement.

        :param managed_app_status_id: key: id of managedAppStatus.
        :type managed_app_status_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_managed_app_statuses.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedAppStatus-id': self._serialize.url("managed_app_status_id", managed_app_status_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_managed_app_statuses.metadata = {'url': '/deviceAppManagement/managedAppStatuses/{managedAppStatus-id}'}  # type: ignore

    def list_managed_e_book(
        self,
        orderby: Optional[List[Union[str, "models.Enum65"]]] = None,
        select: Optional[List[Union[str, "models.Enum66"]]] = None,
        expand: Optional[List[Union[str, "models.Enum67"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedEBook"]:
        """Get managedEBooks from deviceAppManagement.

        Get managedEBooks from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum65]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum66]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum67]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedEBook or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedEBook]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedEBook"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_managed_e_book.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedEBook', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_managed_e_book.metadata = {'url': '/deviceAppManagement/managedEBooks'}  # type: ignore

    async def create_managed_e_book(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        information_url: Optional[str] = None,
        large_cover: Optional["models.MicrosoftGraphMimeContent"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        privacy_information_url: Optional[str] = None,
        published_date_time: Optional[datetime.datetime] = None,
        publisher: Optional[str] = None,
        assignments: Optional[List["models.MicrosoftGraphManagedEBookAssignment"]] = None,
        device_states: Optional[List["models.MicrosoftGraphDeviceInstallState"]] = None,
        install_summary: Optional["models.MicrosoftGraphEBookInstallSummary"] = None,
        user_state_summary: Optional[List["models.MicrosoftGraphUserInstallStateSummary"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedEBook":
        """Create new navigation property to managedEBooks for deviceAppManagement.

        Create new navigation property to managedEBooks for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time when the eBook file was created.
        :type created_date_time: ~datetime.datetime
        :param description: Description.
        :type description: str
        :param display_name: Name of the eBook.
        :type display_name: str
        :param information_url: The more information Url.
        :type information_url: str
        :param large_cover: Contains properties for a generic mime content.
        :type large_cover: ~devices_corporate_management.models.MicrosoftGraphMimeContent
        :param last_modified_date_time: The date and time when the eBook was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :param privacy_information_url: The privacy statement Url.
        :type privacy_information_url: str
        :param published_date_time: The date and time when the eBook was published.
        :type published_date_time: ~datetime.datetime
        :param publisher: Publisher.
        :type publisher: str
        :param assignments: The list of assignments for this eBook.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphManagedEBookAssignment]
        :param device_states: The list of installation states for this eBook.
        :type device_states: list[~devices_corporate_management.models.MicrosoftGraphDeviceInstallState]
        :param install_summary: Contains properties for the installation summary of a book for a
         device.
        :type install_summary: ~devices_corporate_management.models.MicrosoftGraphEBookInstallSummary
        :param user_state_summary: The list of installation states for this eBook.
        :type user_state_summary: list[~devices_corporate_management.models.MicrosoftGraphUserInstallStateSummary]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedEBook, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedEBook
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedEBook"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedEBook(id=id, created_date_time=created_date_time, description=description, display_name=display_name, information_url=information_url, large_cover=large_cover, last_modified_date_time=last_modified_date_time, privacy_information_url=privacy_information_url, published_date_time=published_date_time, publisher=publisher, assignments=assignments, device_states=device_states, install_summary=install_summary, user_state_summary=user_state_summary)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_managed_e_book.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedEBook')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedEBook', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_managed_e_book.metadata = {'url': '/deviceAppManagement/managedEBooks'}  # type: ignore

    async def get_managed_e_book(
        self,
        managed_e_book_id: str,
        select: Optional[List[Union[str, "models.Enum68"]]] = None,
        expand: Optional[List[Union[str, "models.Enum69"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedEBook":
        """Get managedEBooks from deviceAppManagement.

        Get managedEBooks from deviceAppManagement.

        :param managed_e_book_id: key: id of managedEBook.
        :type managed_e_book_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum68]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum69]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedEBook, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedEBook
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedEBook"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_managed_e_book.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedEBook-id': self._serialize.url("managed_e_book_id", managed_e_book_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedEBook', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_managed_e_book.metadata = {'url': '/deviceAppManagement/managedEBooks/{managedEBook-id}'}  # type: ignore

    async def update_managed_e_book(
        self,
        managed_e_book_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        information_url: Optional[str] = None,
        large_cover: Optional["models.MicrosoftGraphMimeContent"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        privacy_information_url: Optional[str] = None,
        published_date_time: Optional[datetime.datetime] = None,
        publisher: Optional[str] = None,
        assignments: Optional[List["models.MicrosoftGraphManagedEBookAssignment"]] = None,
        device_states: Optional[List["models.MicrosoftGraphDeviceInstallState"]] = None,
        install_summary: Optional["models.MicrosoftGraphEBookInstallSummary"] = None,
        user_state_summary: Optional[List["models.MicrosoftGraphUserInstallStateSummary"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property managedEBooks in deviceAppManagement.

        Update the navigation property managedEBooks in deviceAppManagement.

        :param managed_e_book_id: key: id of managedEBook.
        :type managed_e_book_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time when the eBook file was created.
        :type created_date_time: ~datetime.datetime
        :param description: Description.
        :type description: str
        :param display_name: Name of the eBook.
        :type display_name: str
        :param information_url: The more information Url.
        :type information_url: str
        :param large_cover: Contains properties for a generic mime content.
        :type large_cover: ~devices_corporate_management.models.MicrosoftGraphMimeContent
        :param last_modified_date_time: The date and time when the eBook was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :param privacy_information_url: The privacy statement Url.
        :type privacy_information_url: str
        :param published_date_time: The date and time when the eBook was published.
        :type published_date_time: ~datetime.datetime
        :param publisher: Publisher.
        :type publisher: str
        :param assignments: The list of assignments for this eBook.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphManagedEBookAssignment]
        :param device_states: The list of installation states for this eBook.
        :type device_states: list[~devices_corporate_management.models.MicrosoftGraphDeviceInstallState]
        :param install_summary: Contains properties for the installation summary of a book for a
         device.
        :type install_summary: ~devices_corporate_management.models.MicrosoftGraphEBookInstallSummary
        :param user_state_summary: The list of installation states for this eBook.
        :type user_state_summary: list[~devices_corporate_management.models.MicrosoftGraphUserInstallStateSummary]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedEBook(id=id, created_date_time=created_date_time, description=description, display_name=display_name, information_url=information_url, large_cover=large_cover, last_modified_date_time=last_modified_date_time, privacy_information_url=privacy_information_url, published_date_time=published_date_time, publisher=publisher, assignments=assignments, device_states=device_states, install_summary=install_summary, user_state_summary=user_state_summary)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_managed_e_book.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedEBook-id': self._serialize.url("managed_e_book_id", managed_e_book_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedEBook')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_managed_e_book.metadata = {'url': '/deviceAppManagement/managedEBooks/{managedEBook-id}'}  # type: ignore

    async def delete_managed_e_book(
        self,
        managed_e_book_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property managedEBooks for deviceAppManagement.

        Delete navigation property managedEBooks for deviceAppManagement.

        :param managed_e_book_id: key: id of managedEBook.
        :type managed_e_book_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_managed_e_book.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedEBook-id': self._serialize.url("managed_e_book_id", managed_e_book_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_managed_e_book.metadata = {'url': '/deviceAppManagement/managedEBooks/{managedEBook-id}'}  # type: ignore

    def list_mdm_window_information_protection_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum85"]]] = None,
        select: Optional[List[Union[str, "models.Enum86"]]] = None,
        expand: Optional[List[Union[str, "models.Enum87"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfMdmWindowsInformationProtectionPolicy"]:
        """Get mdmWindowsInformationProtectionPolicies from deviceAppManagement.

        Get mdmWindowsInformationProtectionPolicies from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum85]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum86]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum87]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfMdmWindowsInformationProtectionPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfMdmWindowsInformationProtectionPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfMdmWindowsInformationProtectionPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_mdm_window_information_protection_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfMdmWindowsInformationProtectionPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_mdm_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/mdmWindowsInformationProtectionPolicies'}  # type: ignore

    async def create_mdm_window_information_protection_policy(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        azure_rights_management_services_allowed: Optional[bool] = None,
        data_recovery_certificate: Optional["models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate"] = None,
        enforcement_level: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel"]] = None,
        enterprise_domain: Optional[str] = None,
        enterprise_internal_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_ip_ranges: Optional[List["models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection"]] = None,
        enterprise_ip_ranges_are_authoritative: Optional[bool] = None,
        enterprise_network_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_protected_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxied_domains: Optional[List["models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection"]] = None,
        enterprise_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxy_servers_are_authoritative: Optional[bool] = None,
        exempt_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        icons_visible: Optional[bool] = None,
        indexing_encrypted_stores_or_items_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        neutral_domain_resources: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        protected_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        protection_under_lock_config_required: Optional[bool] = None,
        revoke_on_unenroll_disabled: Optional[bool] = None,
        rights_management_services_template_id: Optional[str] = None,
        smb_auto_encrypted_file_extensions: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        exempt_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        protected_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphMdmWindowsInformationProtectionPolicy":
        """Create new navigation property to mdmWindowsInformationProtectionPolicies for deviceAppManagement.

        Create new navigation property to mdmWindowsInformationProtectionPolicies for
        deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param azure_rights_management_services_allowed: Specifies whether to allow Azure RMS
         encryption for WIP.
        :type azure_rights_management_services_allowed: bool
        :param data_recovery_certificate: Windows Information Protection DataRecoveryCertificate.
        :type data_recovery_certificate: ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate
        :param enforcement_level:
        :type enforcement_level: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel
        :param enterprise_domain: Primary enterprise domain.
        :type enterprise_domain: str
        :param enterprise_internal_proxy_servers: This is the comma-separated list of internal proxy
         servers. For example, '157.54.14.28, 157.54.11.118, 10.202.14.167, 157.53.14.163,
         157.69.210.59'. These proxies have been configured by the admin to connect to specific
         resources on the Internet. They are considered to be enterprise network locations. The proxies
         are only leveraged in configuring the EnterpriseProxiedDomains policy to force traffic to the
         matched domains through these proxies.
        :type enterprise_internal_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_ip_ranges: Sets the enterprise IP ranges that define the computers in the
         enterprise network. Data that comes from those computers will be considered part of the
         enterprise and protected. These locations will be considered a safe destination for enterprise
         data to be shared to.
        :type enterprise_ip_ranges: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection]
        :param enterprise_ip_ranges_are_authoritative: Boolean value that tells the client to accept
         the configured list and not to use heuristics to attempt to find other subnets. Default is
         false.
        :type enterprise_ip_ranges_are_authoritative: bool
        :param enterprise_network_domain_names: This is the list of domains that comprise the
         boundaries of the enterprise. Data from one of these domains that is sent to a device will be
         considered enterprise data and protected These locations will be considered a safe destination
         for enterprise data to be shared to.
        :type enterprise_network_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_protected_domain_names: List of enterprise domains to be protected.
        :type enterprise_protected_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxied_domains: Contains a list of Enterprise resource domains hosted in the
         cloud that need to be protected. Connections to these resources are considered enterprise data.
         If a proxy is paired with a cloud resource, traffic to the cloud resource will be routed
         through the enterprise network via the denoted proxy server (on Port 80). A proxy server used
         for this purpose must also be configured using the EnterpriseInternalProxyServers policy.
        :type enterprise_proxied_domains: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection]
        :param enterprise_proxy_servers: This is a list of proxy servers. Any server not on this list
         is considered non-enterprise.
        :type enterprise_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxy_servers_are_authoritative: Boolean value that tells the client to
         accept the configured list of proxies and not try to detect other work proxies. Default is
         false.
        :type enterprise_proxy_servers_are_authoritative: bool
        :param exempt_apps: Exempt applications can also access enterprise data, but the data handled
         by those applications are not protected. This is because some critical enterprise applications
         may have compatibility problems with encrypted data.
        :type exempt_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param icons_visible: Determines whether overlays are added to icons for WIP protected files in
         Explorer and enterprise only app tiles in the Start menu. Starting in Windows 10, version 1703
         this setting also configures the visibility of the WIP icon in the title bar of a WIP-protected
         app.
        :type icons_visible: bool
        :param indexing_encrypted_stores_or_items_blocked: This switch is for the Windows Search
         Indexer, to allow or disallow indexing of items.
        :type indexing_encrypted_stores_or_items_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param neutral_domain_resources: List of domain names that can used for work or personal
         resource.
        :type neutral_domain_resources: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param protected_apps: Protected applications can access enterprise data and the data handled
         by those applications are protected with encryption.
        :type protected_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param protection_under_lock_config_required: Specifies whether the protection under lock
         feature (also known as encrypt under pin) should be configured.
        :type protection_under_lock_config_required: bool
        :param revoke_on_unenroll_disabled: This policy controls whether to revoke the WIP keys when a
         device unenrolls from the management service. If set to 1 (Don't revoke keys), the keys will
         not be revoked and the user will continue to have access to protected files after unenrollment.
         If the keys are not revoked, there will be no revoked file cleanup subsequently.
        :type revoke_on_unenroll_disabled: bool
        :param rights_management_services_template_id: TemplateID GUID to use for RMS encryption. The
         RMS template allows the IT admin to configure the details about who has access to RMS-protected
         file and how long they have access.
        :type rights_management_services_template_id: str
        :param smb_auto_encrypted_file_extensions: Specifies a list of file extensions, so that files
         with these extensions are encrypted when copying from an SMB share within the corporate
         boundary.
        :type smb_auto_encrypted_file_extensions: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param assignments: Navigation property to list of security groups targeted for policy.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param exempt_app_locker_files: Another way to input exempt apps through xml files.
        :type exempt_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :param protected_app_locker_files: Another way to input protected apps through xml files.
        :type protected_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMdmWindowsInformationProtectionPolicy, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphMdmWindowsInformationProtectionPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMdmWindowsInformationProtectionPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphMdmWindowsInformationProtectionPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, azure_rights_management_services_allowed=azure_rights_management_services_allowed, data_recovery_certificate=data_recovery_certificate, enforcement_level=enforcement_level, enterprise_domain=enterprise_domain, enterprise_internal_proxy_servers=enterprise_internal_proxy_servers, enterprise_ip_ranges=enterprise_ip_ranges, enterprise_ip_ranges_are_authoritative=enterprise_ip_ranges_are_authoritative, enterprise_network_domain_names=enterprise_network_domain_names, enterprise_protected_domain_names=enterprise_protected_domain_names, enterprise_proxied_domains=enterprise_proxied_domains, enterprise_proxy_servers=enterprise_proxy_servers, enterprise_proxy_servers_are_authoritative=enterprise_proxy_servers_are_authoritative, exempt_apps=exempt_apps, icons_visible=icons_visible, indexing_encrypted_stores_or_items_blocked=indexing_encrypted_stores_or_items_blocked, is_assigned=is_assigned, neutral_domain_resources=neutral_domain_resources, protected_apps=protected_apps, protection_under_lock_config_required=protection_under_lock_config_required, revoke_on_unenroll_disabled=revoke_on_unenroll_disabled, rights_management_services_template_id=rights_management_services_template_id, smb_auto_encrypted_file_extensions=smb_auto_encrypted_file_extensions, assignments=assignments, exempt_app_locker_files=exempt_app_locker_files, protected_app_locker_files=protected_app_locker_files)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_mdm_window_information_protection_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphMdmWindowsInformationProtectionPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMdmWindowsInformationProtectionPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_mdm_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/mdmWindowsInformationProtectionPolicies'}  # type: ignore

    async def get_mdm_window_information_protection_policy(
        self,
        mdm_windows_information_protection_policy_id: str,
        select: Optional[List[Union[str, "models.Enum88"]]] = None,
        expand: Optional[List[Union[str, "models.Enum89"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphMdmWindowsInformationProtectionPolicy":
        """Get mdmWindowsInformationProtectionPolicies from deviceAppManagement.

        Get mdmWindowsInformationProtectionPolicies from deviceAppManagement.

        :param mdm_windows_information_protection_policy_id: key: id of
         mdmWindowsInformationProtectionPolicy.
        :type mdm_windows_information_protection_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum88]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum89]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMdmWindowsInformationProtectionPolicy, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphMdmWindowsInformationProtectionPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMdmWindowsInformationProtectionPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mdm_window_information_protection_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'mdmWindowsInformationProtectionPolicy-id': self._serialize.url("mdm_windows_information_protection_policy_id", mdm_windows_information_protection_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMdmWindowsInformationProtectionPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mdm_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/mdmWindowsInformationProtectionPolicies/{mdmWindowsInformationProtectionPolicy-id}'}  # type: ignore

    async def update_mdm_window_information_protection_policy(
        self,
        mdm_windows_information_protection_policy_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        azure_rights_management_services_allowed: Optional[bool] = None,
        data_recovery_certificate: Optional["models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate"] = None,
        enforcement_level: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel"]] = None,
        enterprise_domain: Optional[str] = None,
        enterprise_internal_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_ip_ranges: Optional[List["models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection"]] = None,
        enterprise_ip_ranges_are_authoritative: Optional[bool] = None,
        enterprise_network_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_protected_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxied_domains: Optional[List["models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection"]] = None,
        enterprise_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxy_servers_are_authoritative: Optional[bool] = None,
        exempt_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        icons_visible: Optional[bool] = None,
        indexing_encrypted_stores_or_items_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        neutral_domain_resources: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        protected_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        protection_under_lock_config_required: Optional[bool] = None,
        revoke_on_unenroll_disabled: Optional[bool] = None,
        rights_management_services_template_id: Optional[str] = None,
        smb_auto_encrypted_file_extensions: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        exempt_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        protected_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property mdmWindowsInformationProtectionPolicies in deviceAppManagement.

        Update the navigation property mdmWindowsInformationProtectionPolicies in deviceAppManagement.

        :param mdm_windows_information_protection_policy_id: key: id of
         mdmWindowsInformationProtectionPolicy.
        :type mdm_windows_information_protection_policy_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param azure_rights_management_services_allowed: Specifies whether to allow Azure RMS
         encryption for WIP.
        :type azure_rights_management_services_allowed: bool
        :param data_recovery_certificate: Windows Information Protection DataRecoveryCertificate.
        :type data_recovery_certificate: ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate
        :param enforcement_level:
        :type enforcement_level: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel
        :param enterprise_domain: Primary enterprise domain.
        :type enterprise_domain: str
        :param enterprise_internal_proxy_servers: This is the comma-separated list of internal proxy
         servers. For example, '157.54.14.28, 157.54.11.118, 10.202.14.167, 157.53.14.163,
         157.69.210.59'. These proxies have been configured by the admin to connect to specific
         resources on the Internet. They are considered to be enterprise network locations. The proxies
         are only leveraged in configuring the EnterpriseProxiedDomains policy to force traffic to the
         matched domains through these proxies.
        :type enterprise_internal_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_ip_ranges: Sets the enterprise IP ranges that define the computers in the
         enterprise network. Data that comes from those computers will be considered part of the
         enterprise and protected. These locations will be considered a safe destination for enterprise
         data to be shared to.
        :type enterprise_ip_ranges: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection]
        :param enterprise_ip_ranges_are_authoritative: Boolean value that tells the client to accept
         the configured list and not to use heuristics to attempt to find other subnets. Default is
         false.
        :type enterprise_ip_ranges_are_authoritative: bool
        :param enterprise_network_domain_names: This is the list of domains that comprise the
         boundaries of the enterprise. Data from one of these domains that is sent to a device will be
         considered enterprise data and protected These locations will be considered a safe destination
         for enterprise data to be shared to.
        :type enterprise_network_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_protected_domain_names: List of enterprise domains to be protected.
        :type enterprise_protected_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxied_domains: Contains a list of Enterprise resource domains hosted in the
         cloud that need to be protected. Connections to these resources are considered enterprise data.
         If a proxy is paired with a cloud resource, traffic to the cloud resource will be routed
         through the enterprise network via the denoted proxy server (on Port 80). A proxy server used
         for this purpose must also be configured using the EnterpriseInternalProxyServers policy.
        :type enterprise_proxied_domains: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection]
        :param enterprise_proxy_servers: This is a list of proxy servers. Any server not on this list
         is considered non-enterprise.
        :type enterprise_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxy_servers_are_authoritative: Boolean value that tells the client to
         accept the configured list of proxies and not try to detect other work proxies. Default is
         false.
        :type enterprise_proxy_servers_are_authoritative: bool
        :param exempt_apps: Exempt applications can also access enterprise data, but the data handled
         by those applications are not protected. This is because some critical enterprise applications
         may have compatibility problems with encrypted data.
        :type exempt_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param icons_visible: Determines whether overlays are added to icons for WIP protected files in
         Explorer and enterprise only app tiles in the Start menu. Starting in Windows 10, version 1703
         this setting also configures the visibility of the WIP icon in the title bar of a WIP-protected
         app.
        :type icons_visible: bool
        :param indexing_encrypted_stores_or_items_blocked: This switch is for the Windows Search
         Indexer, to allow or disallow indexing of items.
        :type indexing_encrypted_stores_or_items_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param neutral_domain_resources: List of domain names that can used for work or personal
         resource.
        :type neutral_domain_resources: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param protected_apps: Protected applications can access enterprise data and the data handled
         by those applications are protected with encryption.
        :type protected_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param protection_under_lock_config_required: Specifies whether the protection under lock
         feature (also known as encrypt under pin) should be configured.
        :type protection_under_lock_config_required: bool
        :param revoke_on_unenroll_disabled: This policy controls whether to revoke the WIP keys when a
         device unenrolls from the management service. If set to 1 (Don't revoke keys), the keys will
         not be revoked and the user will continue to have access to protected files after unenrollment.
         If the keys are not revoked, there will be no revoked file cleanup subsequently.
        :type revoke_on_unenroll_disabled: bool
        :param rights_management_services_template_id: TemplateID GUID to use for RMS encryption. The
         RMS template allows the IT admin to configure the details about who has access to RMS-protected
         file and how long they have access.
        :type rights_management_services_template_id: str
        :param smb_auto_encrypted_file_extensions: Specifies a list of file extensions, so that files
         with these extensions are encrypted when copying from an SMB share within the corporate
         boundary.
        :type smb_auto_encrypted_file_extensions: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param assignments: Navigation property to list of security groups targeted for policy.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param exempt_app_locker_files: Another way to input exempt apps through xml files.
        :type exempt_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :param protected_app_locker_files: Another way to input protected apps through xml files.
        :type protected_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphMdmWindowsInformationProtectionPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, azure_rights_management_services_allowed=azure_rights_management_services_allowed, data_recovery_certificate=data_recovery_certificate, enforcement_level=enforcement_level, enterprise_domain=enterprise_domain, enterprise_internal_proxy_servers=enterprise_internal_proxy_servers, enterprise_ip_ranges=enterprise_ip_ranges, enterprise_ip_ranges_are_authoritative=enterprise_ip_ranges_are_authoritative, enterprise_network_domain_names=enterprise_network_domain_names, enterprise_protected_domain_names=enterprise_protected_domain_names, enterprise_proxied_domains=enterprise_proxied_domains, enterprise_proxy_servers=enterprise_proxy_servers, enterprise_proxy_servers_are_authoritative=enterprise_proxy_servers_are_authoritative, exempt_apps=exempt_apps, icons_visible=icons_visible, indexing_encrypted_stores_or_items_blocked=indexing_encrypted_stores_or_items_blocked, is_assigned=is_assigned, neutral_domain_resources=neutral_domain_resources, protected_apps=protected_apps, protection_under_lock_config_required=protection_under_lock_config_required, revoke_on_unenroll_disabled=revoke_on_unenroll_disabled, rights_management_services_template_id=rights_management_services_template_id, smb_auto_encrypted_file_extensions=smb_auto_encrypted_file_extensions, assignments=assignments, exempt_app_locker_files=exempt_app_locker_files, protected_app_locker_files=protected_app_locker_files)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_mdm_window_information_protection_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'mdmWindowsInformationProtectionPolicy-id': self._serialize.url("mdm_windows_information_protection_policy_id", mdm_windows_information_protection_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphMdmWindowsInformationProtectionPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_mdm_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/mdmWindowsInformationProtectionPolicies/{mdmWindowsInformationProtectionPolicy-id}'}  # type: ignore

    async def delete_mdm_window_information_protection_policy(
        self,
        mdm_windows_information_protection_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property mdmWindowsInformationProtectionPolicies for deviceAppManagement.

        Delete navigation property mdmWindowsInformationProtectionPolicies for deviceAppManagement.

        :param mdm_windows_information_protection_policy_id: key: id of
         mdmWindowsInformationProtectionPolicy.
        :type mdm_windows_information_protection_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_mdm_window_information_protection_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'mdmWindowsInformationProtectionPolicy-id': self._serialize.url("mdm_windows_information_protection_policy_id", mdm_windows_information_protection_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mdm_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/mdmWindowsInformationProtectionPolicies/{mdmWindowsInformationProtectionPolicy-id}'}  # type: ignore

    async def sync_microsoft_store_for_business_app(
        self,
        **kwargs
    ) -> None:
        """Invoke action syncMicrosoftStoreForBusinessApps.

        Invoke action syncMicrosoftStoreForBusinessApps.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.sync_microsoft_store_for_business_app.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    sync_microsoft_store_for_business_app.metadata = {'url': '/deviceAppManagement/microsoft.graph.syncMicrosoftStoreForBusinessApps'}  # type: ignore

    def list_mobile_app_category(
        self,
        orderby: Optional[List[Union[str, "models.Enum90"]]] = None,
        select: Optional[List[Union[str, "models.Enum91"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfMobileAppCategory"]:
        """Get mobileAppCategories from deviceAppManagement.

        Get mobileAppCategories from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum90]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum91]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfMobileAppCategory or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfMobileAppCategory]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfMobileAppCategory"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_mobile_app_category.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfMobileAppCategory', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_mobile_app_category.metadata = {'url': '/deviceAppManagement/mobileAppCategories'}  # type: ignore

    async def create_mobile_app_category(
        self,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphMobileAppCategory":
        """Create new navigation property to mobileAppCategories for deviceAppManagement.

        Create new navigation property to mobileAppCategories for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param display_name: The name of the app category.
        :type display_name: str
        :param last_modified_date_time: The date and time the mobileAppCategory was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMobileAppCategory, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphMobileAppCategory
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMobileAppCategory"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphMobileAppCategory(id=id, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_mobile_app_category.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphMobileAppCategory')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMobileAppCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_mobile_app_category.metadata = {'url': '/deviceAppManagement/mobileAppCategories'}  # type: ignore

    async def get_mobile_app_category(
        self,
        mobile_app_category_id: str,
        select: Optional[List[Union[str, "models.Enum92"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphMobileAppCategory":
        """Get mobileAppCategories from deviceAppManagement.

        Get mobileAppCategories from deviceAppManagement.

        :param mobile_app_category_id: key: id of mobileAppCategory.
        :type mobile_app_category_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum92]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMobileAppCategory, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphMobileAppCategory
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMobileAppCategory"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mobile_app_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'mobileAppCategory-id': self._serialize.url("mobile_app_category_id", mobile_app_category_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMobileAppCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mobile_app_category.metadata = {'url': '/deviceAppManagement/mobileAppCategories/{mobileAppCategory-id}'}  # type: ignore

    async def update_mobile_app_category(
        self,
        mobile_app_category_id: str,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property mobileAppCategories in deviceAppManagement.

        Update the navigation property mobileAppCategories in deviceAppManagement.

        :param mobile_app_category_id: key: id of mobileAppCategory.
        :type mobile_app_category_id: str
        :param id: Read-only.
        :type id: str
        :param display_name: The name of the app category.
        :type display_name: str
        :param last_modified_date_time: The date and time the mobileAppCategory was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphMobileAppCategory(id=id, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_mobile_app_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'mobileAppCategory-id': self._serialize.url("mobile_app_category_id", mobile_app_category_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphMobileAppCategory')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_mobile_app_category.metadata = {'url': '/deviceAppManagement/mobileAppCategories/{mobileAppCategory-id}'}  # type: ignore

    async def delete_mobile_app_category(
        self,
        mobile_app_category_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property mobileAppCategories for deviceAppManagement.

        Delete navigation property mobileAppCategories for deviceAppManagement.

        :param mobile_app_category_id: key: id of mobileAppCategory.
        :type mobile_app_category_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_mobile_app_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'mobileAppCategory-id': self._serialize.url("mobile_app_category_id", mobile_app_category_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mobile_app_category.metadata = {'url': '/deviceAppManagement/mobileAppCategories/{mobileAppCategory-id}'}  # type: ignore

    def list_mobile_app_configuration(
        self,
        orderby: Optional[List[Union[str, "models.Enum93"]]] = None,
        select: Optional[List[Union[str, "models.Enum94"]]] = None,
        expand: Optional[List[Union[str, "models.Enum95"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfManagedDeviceMobileAppConfiguration"]:
        """Get mobileAppConfigurations from deviceAppManagement.

        Get mobileAppConfigurations from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum93]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum94]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum95]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfManagedDeviceMobileAppConfiguration or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfManagedDeviceMobileAppConfiguration]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfManagedDeviceMobileAppConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_mobile_app_configuration.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfManagedDeviceMobileAppConfiguration', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_mobile_app_configuration.metadata = {'url': '/deviceAppManagement/mobileAppConfigurations'}  # type: ignore

    async def create_mobile_app_configuration(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        targeted_mobile_apps: Optional[List[str]] = None,
        version: Optional[int] = None,
        assignments: Optional[List["models.MicrosoftGraphManagedDeviceMobileAppConfigurationAssignment"]] = None,
        device_statuses: Optional[List["models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceStatus"]] = None,
        device_status_summary: Optional["models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceSummary"] = None,
        user_statuses: Optional[List["models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserStatus"]] = None,
        user_status_summary: Optional["models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserSummary"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedDeviceMobileAppConfiguration":
        """Create new navigation property to mobileAppConfigurations for deviceAppManagement.

        Create new navigation property to mobileAppConfigurations for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: DateTime the object was created.
        :type created_date_time: ~datetime.datetime
        :param description: Admin provided description of the Device Configuration.
        :type description: str
        :param display_name: Admin provided name of the device configuration.
        :type display_name: str
        :param last_modified_date_time: DateTime the object was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :param targeted_mobile_apps: the associated app.
        :type targeted_mobile_apps: list[str]
        :param version: Version of the device configuration.
        :type version: int
        :param assignments: The list of group assignemenets for app configration.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationAssignment]
        :param device_statuses: List of ManagedDeviceMobileAppConfigurationDeviceStatus.
        :type device_statuses: list[~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceStatus]
        :param device_status_summary: Contains properties, inherited properties and actions for an MDM
         mobile app configuration device status summary.
        :type device_status_summary: ~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceSummary
        :param user_statuses: List of ManagedDeviceMobileAppConfigurationUserStatus.
        :type user_statuses: list[~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserStatus]
        :param user_status_summary: Contains properties, inherited properties and actions for an MDM
         mobile app configuration user status summary.
        :type user_status_summary: ~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserSummary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedDeviceMobileAppConfiguration, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedDeviceMobileAppConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedDeviceMobileAppConfiguration(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, targeted_mobile_apps=targeted_mobile_apps, version=version, assignments=assignments, device_statuses=device_statuses, device_status_summary=device_status_summary, user_statuses=user_statuses, user_status_summary=user_status_summary)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_mobile_app_configuration.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedDeviceMobileAppConfiguration')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedDeviceMobileAppConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_mobile_app_configuration.metadata = {'url': '/deviceAppManagement/mobileAppConfigurations'}  # type: ignore

    async def get_mobile_app_configuration(
        self,
        managed_device_mobile_app_configuration_id: str,
        select: Optional[List[Union[str, "models.Enum96"]]] = None,
        expand: Optional[List[Union[str, "models.Enum97"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphManagedDeviceMobileAppConfiguration":
        """Get mobileAppConfigurations from deviceAppManagement.

        Get mobileAppConfigurations from deviceAppManagement.

        :param managed_device_mobile_app_configuration_id: key: id of
         managedDeviceMobileAppConfiguration.
        :type managed_device_mobile_app_configuration_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum96]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum97]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphManagedDeviceMobileAppConfiguration, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphManagedDeviceMobileAppConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mobile_app_configuration.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedDeviceMobileAppConfiguration-id': self._serialize.url("managed_device_mobile_app_configuration_id", managed_device_mobile_app_configuration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphManagedDeviceMobileAppConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mobile_app_configuration.metadata = {'url': '/deviceAppManagement/mobileAppConfigurations/{managedDeviceMobileAppConfiguration-id}'}  # type: ignore

    async def update_mobile_app_configuration(
        self,
        managed_device_mobile_app_configuration_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        targeted_mobile_apps: Optional[List[str]] = None,
        version: Optional[int] = None,
        assignments: Optional[List["models.MicrosoftGraphManagedDeviceMobileAppConfigurationAssignment"]] = None,
        device_statuses: Optional[List["models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceStatus"]] = None,
        device_status_summary: Optional["models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceSummary"] = None,
        user_statuses: Optional[List["models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserStatus"]] = None,
        user_status_summary: Optional["models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserSummary"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property mobileAppConfigurations in deviceAppManagement.

        Update the navigation property mobileAppConfigurations in deviceAppManagement.

        :param managed_device_mobile_app_configuration_id: key: id of
         managedDeviceMobileAppConfiguration.
        :type managed_device_mobile_app_configuration_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: DateTime the object was created.
        :type created_date_time: ~datetime.datetime
        :param description: Admin provided description of the Device Configuration.
        :type description: str
        :param display_name: Admin provided name of the device configuration.
        :type display_name: str
        :param last_modified_date_time: DateTime the object was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :param targeted_mobile_apps: the associated app.
        :type targeted_mobile_apps: list[str]
        :param version: Version of the device configuration.
        :type version: int
        :param assignments: The list of group assignemenets for app configration.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationAssignment]
        :param device_statuses: List of ManagedDeviceMobileAppConfigurationDeviceStatus.
        :type device_statuses: list[~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceStatus]
        :param device_status_summary: Contains properties, inherited properties and actions for an MDM
         mobile app configuration device status summary.
        :type device_status_summary: ~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationDeviceSummary
        :param user_statuses: List of ManagedDeviceMobileAppConfigurationUserStatus.
        :type user_statuses: list[~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserStatus]
        :param user_status_summary: Contains properties, inherited properties and actions for an MDM
         mobile app configuration user status summary.
        :type user_status_summary: ~devices_corporate_management.models.MicrosoftGraphManagedDeviceMobileAppConfigurationUserSummary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphManagedDeviceMobileAppConfiguration(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, targeted_mobile_apps=targeted_mobile_apps, version=version, assignments=assignments, device_statuses=device_statuses, device_status_summary=device_status_summary, user_statuses=user_statuses, user_status_summary=user_status_summary)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_mobile_app_configuration.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedDeviceMobileAppConfiguration-id': self._serialize.url("managed_device_mobile_app_configuration_id", managed_device_mobile_app_configuration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphManagedDeviceMobileAppConfiguration')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_mobile_app_configuration.metadata = {'url': '/deviceAppManagement/mobileAppConfigurations/{managedDeviceMobileAppConfiguration-id}'}  # type: ignore

    async def delete_mobile_app_configuration(
        self,
        managed_device_mobile_app_configuration_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property mobileAppConfigurations for deviceAppManagement.

        Delete navigation property mobileAppConfigurations for deviceAppManagement.

        :param managed_device_mobile_app_configuration_id: key: id of
         managedDeviceMobileAppConfiguration.
        :type managed_device_mobile_app_configuration_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_mobile_app_configuration.metadata['url']  # type: ignore
        path_format_arguments = {
            'managedDeviceMobileAppConfiguration-id': self._serialize.url("managed_device_mobile_app_configuration_id", managed_device_mobile_app_configuration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mobile_app_configuration.metadata = {'url': '/deviceAppManagement/mobileAppConfigurations/{managedDeviceMobileAppConfiguration-id}'}  # type: ignore

    def list_mobile_app(
        self,
        orderby: Optional[List[Union[str, "models.Enum109"]]] = None,
        select: Optional[List[Union[str, "models.Enum110"]]] = None,
        expand: Optional[List[Union[str, "models.Enum111"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfMobileApp"]:
        """Get mobileApps from deviceAppManagement.

        Get mobileApps from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum109]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum110]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum111]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfMobileApp or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfMobileApp]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfMobileApp"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_mobile_app.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfMobileApp', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_mobile_app.metadata = {'url': '/deviceAppManagement/mobileApps'}  # type: ignore

    async def create_mobile_app(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        developer: Optional[str] = None,
        display_name: Optional[str] = None,
        information_url: Optional[str] = None,
        is_featured: Optional[bool] = None,
        large_icon: Optional["models.MicrosoftGraphMimeContent"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        notes: Optional[str] = None,
        owner: Optional[str] = None,
        privacy_information_url: Optional[str] = None,
        publisher: Optional[str] = None,
        publishing_state: Optional[Union[str, "models.MicrosoftGraphMobileAppPublishingState"]] = None,
        assignments: Optional[List["models.MicrosoftGraphMobileAppAssignment"]] = None,
        categories: Optional[List["models.MicrosoftGraphMobileAppCategory"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphMobileApp":
        """Create new navigation property to mobileApps for deviceAppManagement.

        Create new navigation property to mobileApps for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the app was created.
        :type created_date_time: ~datetime.datetime
        :param description: The description of the app.
        :type description: str
        :param developer: The developer of the app.
        :type developer: str
        :param display_name: The admin provided or imported title of the app.
        :type display_name: str
        :param information_url: The more information Url.
        :type information_url: str
        :param is_featured: The value indicating whether the app is marked as featured by the admin.
        :type is_featured: bool
        :param large_icon: Contains properties for a generic mime content.
        :type large_icon: ~devices_corporate_management.models.MicrosoftGraphMimeContent
        :param last_modified_date_time: The date and time the app was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :param notes: Notes for the app.
        :type notes: str
        :param owner: The owner of the app.
        :type owner: str
        :param privacy_information_url: The privacy statement Url.
        :type privacy_information_url: str
        :param publisher: The publisher of the app.
        :type publisher: str
        :param publishing_state:
        :type publishing_state: str or ~devices_corporate_management.models.MicrosoftGraphMobileAppPublishingState
        :param assignments: The list of group assignments for this mobile app.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphMobileAppAssignment]
        :param categories: The list of categories for this app.
        :type categories: list[~devices_corporate_management.models.MicrosoftGraphMobileAppCategory]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMobileApp, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphMobileApp
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMobileApp"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphMobileApp(id=id, created_date_time=created_date_time, description=description, developer=developer, display_name=display_name, information_url=information_url, is_featured=is_featured, large_icon=large_icon, last_modified_date_time=last_modified_date_time, notes=notes, owner=owner, privacy_information_url=privacy_information_url, publisher=publisher, publishing_state=publishing_state, assignments=assignments, categories=categories)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_mobile_app.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphMobileApp')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMobileApp', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_mobile_app.metadata = {'url': '/deviceAppManagement/mobileApps'}  # type: ignore

    async def get_mobile_app(
        self,
        mobile_app_id: str,
        select: Optional[List[Union[str, "models.Enum112"]]] = None,
        expand: Optional[List[Union[str, "models.Enum113"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphMobileApp":
        """Get mobileApps from deviceAppManagement.

        Get mobileApps from deviceAppManagement.

        :param mobile_app_id: key: id of mobileApp.
        :type mobile_app_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum112]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum113]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMobileApp, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphMobileApp
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMobileApp"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mobile_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'mobileApp-id': self._serialize.url("mobile_app_id", mobile_app_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMobileApp', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mobile_app.metadata = {'url': '/deviceAppManagement/mobileApps/{mobileApp-id}'}  # type: ignore

    async def update_mobile_app(
        self,
        mobile_app_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        developer: Optional[str] = None,
        display_name: Optional[str] = None,
        information_url: Optional[str] = None,
        is_featured: Optional[bool] = None,
        large_icon: Optional["models.MicrosoftGraphMimeContent"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        notes: Optional[str] = None,
        owner: Optional[str] = None,
        privacy_information_url: Optional[str] = None,
        publisher: Optional[str] = None,
        publishing_state: Optional[Union[str, "models.MicrosoftGraphMobileAppPublishingState"]] = None,
        assignments: Optional[List["models.MicrosoftGraphMobileAppAssignment"]] = None,
        categories: Optional[List["models.MicrosoftGraphMobileAppCategory"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property mobileApps in deviceAppManagement.

        Update the navigation property mobileApps in deviceAppManagement.

        :param mobile_app_id: key: id of mobileApp.
        :type mobile_app_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the app was created.
        :type created_date_time: ~datetime.datetime
        :param description: The description of the app.
        :type description: str
        :param developer: The developer of the app.
        :type developer: str
        :param display_name: The admin provided or imported title of the app.
        :type display_name: str
        :param information_url: The more information Url.
        :type information_url: str
        :param is_featured: The value indicating whether the app is marked as featured by the admin.
        :type is_featured: bool
        :param large_icon: Contains properties for a generic mime content.
        :type large_icon: ~devices_corporate_management.models.MicrosoftGraphMimeContent
        :param last_modified_date_time: The date and time the app was last modified.
        :type last_modified_date_time: ~datetime.datetime
        :param notes: Notes for the app.
        :type notes: str
        :param owner: The owner of the app.
        :type owner: str
        :param privacy_information_url: The privacy statement Url.
        :type privacy_information_url: str
        :param publisher: The publisher of the app.
        :type publisher: str
        :param publishing_state:
        :type publishing_state: str or ~devices_corporate_management.models.MicrosoftGraphMobileAppPublishingState
        :param assignments: The list of group assignments for this mobile app.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphMobileAppAssignment]
        :param categories: The list of categories for this app.
        :type categories: list[~devices_corporate_management.models.MicrosoftGraphMobileAppCategory]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphMobileApp(id=id, created_date_time=created_date_time, description=description, developer=developer, display_name=display_name, information_url=information_url, is_featured=is_featured, large_icon=large_icon, last_modified_date_time=last_modified_date_time, notes=notes, owner=owner, privacy_information_url=privacy_information_url, publisher=publisher, publishing_state=publishing_state, assignments=assignments, categories=categories)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_mobile_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'mobileApp-id': self._serialize.url("mobile_app_id", mobile_app_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphMobileApp')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_mobile_app.metadata = {'url': '/deviceAppManagement/mobileApps/{mobileApp-id}'}  # type: ignore

    async def delete_mobile_app(
        self,
        mobile_app_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property mobileApps for deviceAppManagement.

        Delete navigation property mobileApps for deviceAppManagement.

        :param mobile_app_id: key: id of mobileApp.
        :type mobile_app_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_mobile_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'mobileApp-id': self._serialize.url("mobile_app_id", mobile_app_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_mobile_app.metadata = {'url': '/deviceAppManagement/mobileApps/{mobileApp-id}'}  # type: ignore

    def list_targeted_managed_app_configuration(
        self,
        orderby: Optional[List[Union[str, "models.Enum120"]]] = None,
        select: Optional[List[Union[str, "models.Enum121"]]] = None,
        expand: Optional[List[Union[str, "models.Enum122"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTargetedManagedAppConfiguration"]:
        """Get targetedManagedAppConfigurations from deviceAppManagement.

        Get targetedManagedAppConfigurations from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum120]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum121]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum122]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTargetedManagedAppConfiguration or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfTargetedManagedAppConfiguration]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTargetedManagedAppConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_targeted_managed_app_configuration.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTargetedManagedAppConfiguration', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_targeted_managed_app_configuration.metadata = {'url': '/deviceAppManagement/targetedManagedAppConfigurations'}  # type: ignore

    async def create_targeted_managed_app_configuration(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        custom_settings: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        deployed_app_count: Optional[int] = None,
        is_assigned: Optional[bool] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTargetedManagedAppConfiguration":
        """Create new navigation property to targetedManagedAppConfigurations for deviceAppManagement.

        Create new navigation property to targetedManagedAppConfigurations for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param custom_settings: A set of string key and string value pairs to be sent to apps for users
         to whom the configuration is scoped, unalterned by this service.
        :type custom_settings: list[~devices_corporate_management.models.MicrosoftGraphKeyValuePair]
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param assignments: Navigation property to list of inclusion and exclusion groups to which the
         policy is deployed.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTargetedManagedAppConfiguration, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTargetedManagedAppConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTargetedManagedAppConfiguration(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, custom_settings=custom_settings, deployed_app_count=deployed_app_count, is_assigned=is_assigned, apps=apps, assignments=assignments, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_targeted_managed_app_configuration.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTargetedManagedAppConfiguration')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTargetedManagedAppConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_targeted_managed_app_configuration.metadata = {'url': '/deviceAppManagement/targetedManagedAppConfigurations'}  # type: ignore

    async def get_targeted_managed_app_configuration(
        self,
        targeted_managed_app_configuration_id: str,
        select: Optional[List[Union[str, "models.Enum123"]]] = None,
        expand: Optional[List[Union[str, "models.Enum124"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTargetedManagedAppConfiguration":
        """Get targetedManagedAppConfigurations from deviceAppManagement.

        Get targetedManagedAppConfigurations from deviceAppManagement.

        :param targeted_managed_app_configuration_id: key: id of targetedManagedAppConfiguration.
        :type targeted_managed_app_configuration_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum123]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum124]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTargetedManagedAppConfiguration, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTargetedManagedAppConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_targeted_managed_app_configuration.metadata['url']  # type: ignore
        path_format_arguments = {
            'targetedManagedAppConfiguration-id': self._serialize.url("targeted_managed_app_configuration_id", targeted_managed_app_configuration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTargetedManagedAppConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_targeted_managed_app_configuration.metadata = {'url': '/deviceAppManagement/targetedManagedAppConfigurations/{targetedManagedAppConfiguration-id}'}  # type: ignore

    async def update_targeted_managed_app_configuration(
        self,
        targeted_managed_app_configuration_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        custom_settings: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        deployed_app_count: Optional[int] = None,
        is_assigned: Optional[bool] = None,
        apps: Optional[List["models.MicrosoftGraphManagedMobileApp"]] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        configuration_deployed_user_count: Optional[int] = None,
        configuration_deployment_summary_per_app: Optional[List["models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp"]] = None,
        microsoft_graph_managed_app_policy_deployment_summary_display_name: Optional[str] = None,
        last_refresh_time: Optional[datetime.datetime] = None,
        microsoft_graph_managed_app_policy_deployment_summary_version: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property targetedManagedAppConfigurations in deviceAppManagement.

        Update the navigation property targetedManagedAppConfigurations in deviceAppManagement.

        :param targeted_managed_app_configuration_id: key: id of targetedManagedAppConfiguration.
        :type targeted_managed_app_configuration_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param custom_settings: A set of string key and string value pairs to be sent to apps for users
         to whom the configuration is scoped, unalterned by this service.
        :type custom_settings: list[~devices_corporate_management.models.MicrosoftGraphKeyValuePair]
        :param deployed_app_count: Count of apps to which the current policy is deployed.
        :type deployed_app_count: int
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param apps: List of apps to which the policy is deployed.
        :type apps: list[~devices_corporate_management.models.MicrosoftGraphManagedMobileApp]
        :param assignments: Navigation property to list of inclusion and exclusion groups to which the
         policy is deployed.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param configuration_deployed_user_count: Not yet documented.
        :type configuration_deployed_user_count: int
        :param configuration_deployment_summary_per_app: Not yet documented.
        :type configuration_deployment_summary_per_app: list[~devices_corporate_management.models.MicrosoftGraphManagedAppPolicyDeploymentSummaryPerApp]
        :param microsoft_graph_managed_app_policy_deployment_summary_display_name: Not yet documented.
        :type microsoft_graph_managed_app_policy_deployment_summary_display_name: str
        :param last_refresh_time: Not yet documented.
        :type last_refresh_time: ~datetime.datetime
        :param microsoft_graph_managed_app_policy_deployment_summary_version: Version of the entity.
        :type microsoft_graph_managed_app_policy_deployment_summary_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTargetedManagedAppConfiguration(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, custom_settings=custom_settings, deployed_app_count=deployed_app_count, is_assigned=is_assigned, apps=apps, assignments=assignments, id_deployment_summary_id=microsoft_graph_entity_id, configuration_deployed_user_count=configuration_deployed_user_count, configuration_deployment_summary_per_app=configuration_deployment_summary_per_app, display_name_deployment_summary_display_name=microsoft_graph_managed_app_policy_deployment_summary_display_name, last_refresh_time=last_refresh_time, version_deployment_summary_version=microsoft_graph_managed_app_policy_deployment_summary_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_targeted_managed_app_configuration.metadata['url']  # type: ignore
        path_format_arguments = {
            'targetedManagedAppConfiguration-id': self._serialize.url("targeted_managed_app_configuration_id", targeted_managed_app_configuration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTargetedManagedAppConfiguration')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_targeted_managed_app_configuration.metadata = {'url': '/deviceAppManagement/targetedManagedAppConfigurations/{targetedManagedAppConfiguration-id}'}  # type: ignore

    async def delete_targeted_managed_app_configuration(
        self,
        targeted_managed_app_configuration_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property targetedManagedAppConfigurations for deviceAppManagement.

        Delete navigation property targetedManagedAppConfigurations for deviceAppManagement.

        :param targeted_managed_app_configuration_id: key: id of targetedManagedAppConfiguration.
        :type targeted_managed_app_configuration_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_targeted_managed_app_configuration.metadata['url']  # type: ignore
        path_format_arguments = {
            'targetedManagedAppConfiguration-id': self._serialize.url("targeted_managed_app_configuration_id", targeted_managed_app_configuration_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_targeted_managed_app_configuration.metadata = {'url': '/deviceAppManagement/targetedManagedAppConfigurations/{targetedManagedAppConfiguration-id}'}  # type: ignore

    def list_vpp_token(
        self,
        orderby: Optional[List[Union[str, "models.Enum132"]]] = None,
        select: Optional[List[Union[str, "models.Enum133"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfVppToken"]:
        """Get vppTokens from deviceAppManagement.

        Get vppTokens from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum132]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum133]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfVppToken or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfVppToken]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfVppToken"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_vpp_token.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfVppToken', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_vpp_token.metadata = {'url': '/deviceAppManagement/vppTokens'}  # type: ignore

    async def create_vpp_token(
        self,
        id: Optional[str] = None,
        apple_id: Optional[str] = None,
        automatically_update_apps: Optional[bool] = None,
        country_or_region: Optional[str] = None,
        expiration_date_time: Optional[datetime.datetime] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        last_sync_date_time: Optional[datetime.datetime] = None,
        last_sync_status: Optional[Union[str, "models.MicrosoftGraphVppTokenSyncStatus"]] = None,
        organization_name: Optional[str] = None,
        state: Optional[Union[str, "models.MicrosoftGraphVppTokenState"]] = None,
        token: Optional[str] = None,
        vpp_token_account_type: Optional[Union[str, "models.MicrosoftGraphVppTokenAccountType"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphVppToken":
        """Create new navigation property to vppTokens for deviceAppManagement.

        Create new navigation property to vppTokens for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param apple_id: The apple Id associated with the given Apple Volume Purchase Program Token.
        :type apple_id: str
        :param automatically_update_apps: Whether or not apps for the VPP token will be automatically
         updated.
        :type automatically_update_apps: bool
        :param country_or_region: Whether or not apps for the VPP token will be automatically updated.
        :type country_or_region: str
        :param expiration_date_time: The expiration date time of the Apple Volume Purchase Program
         Token.
        :type expiration_date_time: ~datetime.datetime
        :param last_modified_date_time: Last modification date time associated with the Apple Volume
         Purchase Program Token.
        :type last_modified_date_time: ~datetime.datetime
        :param last_sync_date_time: The last time when an application sync was done with the Apple
         volume purchase program service using the Apple Volume Purchase Program Token.
        :type last_sync_date_time: ~datetime.datetime
        :param last_sync_status:
        :type last_sync_status: str or ~devices_corporate_management.models.MicrosoftGraphVppTokenSyncStatus
        :param organization_name: The organization associated with the Apple Volume Purchase Program
         Token.
        :type organization_name: str
        :param state:
        :type state: str or ~devices_corporate_management.models.MicrosoftGraphVppTokenState
        :param token: The Apple Volume Purchase Program Token string downloaded from the Apple Volume
         Purchase Program.
        :type token: str
        :param vpp_token_account_type:
        :type vpp_token_account_type: str or ~devices_corporate_management.models.MicrosoftGraphVppTokenAccountType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphVppToken, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphVppToken
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphVppToken"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphVppToken(id=id, apple_id=apple_id, automatically_update_apps=automatically_update_apps, country_or_region=country_or_region, expiration_date_time=expiration_date_time, last_modified_date_time=last_modified_date_time, last_sync_date_time=last_sync_date_time, last_sync_status=last_sync_status, organization_name=organization_name, state=state, token=token, vpp_token_account_type=vpp_token_account_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_vpp_token.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphVppToken')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphVppToken', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_vpp_token.metadata = {'url': '/deviceAppManagement/vppTokens'}  # type: ignore

    async def get_vpp_token(
        self,
        vpp_token_id: str,
        select: Optional[List[Union[str, "models.Enum134"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphVppToken":
        """Get vppTokens from deviceAppManagement.

        Get vppTokens from deviceAppManagement.

        :param vpp_token_id: key: id of vppToken.
        :type vpp_token_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum134]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphVppToken, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphVppToken
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphVppToken"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_vpp_token.metadata['url']  # type: ignore
        path_format_arguments = {
            'vppToken-id': self._serialize.url("vpp_token_id", vpp_token_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphVppToken', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_vpp_token.metadata = {'url': '/deviceAppManagement/vppTokens/{vppToken-id}'}  # type: ignore

    async def update_vpp_token(
        self,
        vpp_token_id: str,
        id: Optional[str] = None,
        apple_id: Optional[str] = None,
        automatically_update_apps: Optional[bool] = None,
        country_or_region: Optional[str] = None,
        expiration_date_time: Optional[datetime.datetime] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        last_sync_date_time: Optional[datetime.datetime] = None,
        last_sync_status: Optional[Union[str, "models.MicrosoftGraphVppTokenSyncStatus"]] = None,
        organization_name: Optional[str] = None,
        state: Optional[Union[str, "models.MicrosoftGraphVppTokenState"]] = None,
        token: Optional[str] = None,
        vpp_token_account_type: Optional[Union[str, "models.MicrosoftGraphVppTokenAccountType"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property vppTokens in deviceAppManagement.

        Update the navigation property vppTokens in deviceAppManagement.

        :param vpp_token_id: key: id of vppToken.
        :type vpp_token_id: str
        :param id: Read-only.
        :type id: str
        :param apple_id: The apple Id associated with the given Apple Volume Purchase Program Token.
        :type apple_id: str
        :param automatically_update_apps: Whether or not apps for the VPP token will be automatically
         updated.
        :type automatically_update_apps: bool
        :param country_or_region: Whether or not apps for the VPP token will be automatically updated.
        :type country_or_region: str
        :param expiration_date_time: The expiration date time of the Apple Volume Purchase Program
         Token.
        :type expiration_date_time: ~datetime.datetime
        :param last_modified_date_time: Last modification date time associated with the Apple Volume
         Purchase Program Token.
        :type last_modified_date_time: ~datetime.datetime
        :param last_sync_date_time: The last time when an application sync was done with the Apple
         volume purchase program service using the Apple Volume Purchase Program Token.
        :type last_sync_date_time: ~datetime.datetime
        :param last_sync_status:
        :type last_sync_status: str or ~devices_corporate_management.models.MicrosoftGraphVppTokenSyncStatus
        :param organization_name: The organization associated with the Apple Volume Purchase Program
         Token.
        :type organization_name: str
        :param state:
        :type state: str or ~devices_corporate_management.models.MicrosoftGraphVppTokenState
        :param token: The Apple Volume Purchase Program Token string downloaded from the Apple Volume
         Purchase Program.
        :type token: str
        :param vpp_token_account_type:
        :type vpp_token_account_type: str or ~devices_corporate_management.models.MicrosoftGraphVppTokenAccountType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphVppToken(id=id, apple_id=apple_id, automatically_update_apps=automatically_update_apps, country_or_region=country_or_region, expiration_date_time=expiration_date_time, last_modified_date_time=last_modified_date_time, last_sync_date_time=last_sync_date_time, last_sync_status=last_sync_status, organization_name=organization_name, state=state, token=token, vpp_token_account_type=vpp_token_account_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_vpp_token.metadata['url']  # type: ignore
        path_format_arguments = {
            'vppToken-id': self._serialize.url("vpp_token_id", vpp_token_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphVppToken')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_vpp_token.metadata = {'url': '/deviceAppManagement/vppTokens/{vppToken-id}'}  # type: ignore

    async def delete_vpp_token(
        self,
        vpp_token_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property vppTokens for deviceAppManagement.

        Delete navigation property vppTokens for deviceAppManagement.

        :param vpp_token_id: key: id of vppToken.
        :type vpp_token_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_vpp_token.metadata['url']  # type: ignore
        path_format_arguments = {
            'vppToken-id': self._serialize.url("vpp_token_id", vpp_token_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_vpp_token.metadata = {'url': '/deviceAppManagement/vppTokens/{vppToken-id}'}  # type: ignore

    def list_window_information_protection_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum135"]]] = None,
        select: Optional[List[Union[str, "models.Enum136"]]] = None,
        expand: Optional[List[Union[str, "models.Enum137"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfWindowsInformationProtectionPolicy"]:
        """Get windowsInformationProtectionPolicies from deviceAppManagement.

        Get windowsInformationProtectionPolicies from deviceAppManagement.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~devices_corporate_management.models.Enum135]
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum136]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum137]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfWindowsInformationProtectionPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~devices_corporate_management.models.CollectionOfWindowsInformationProtectionPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfWindowsInformationProtectionPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_window_information_protection_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfWindowsInformationProtectionPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/windowsInformationProtectionPolicies'}  # type: ignore

    async def create_window_information_protection_policy(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        azure_rights_management_services_allowed: Optional[bool] = None,
        data_recovery_certificate: Optional["models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate"] = None,
        enforcement_level: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel"]] = None,
        enterprise_domain: Optional[str] = None,
        enterprise_internal_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_ip_ranges: Optional[List["models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection"]] = None,
        enterprise_ip_ranges_are_authoritative: Optional[bool] = None,
        enterprise_network_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_protected_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxied_domains: Optional[List["models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection"]] = None,
        enterprise_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxy_servers_are_authoritative: Optional[bool] = None,
        exempt_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        icons_visible: Optional[bool] = None,
        indexing_encrypted_stores_or_items_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        neutral_domain_resources: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        protected_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        protection_under_lock_config_required: Optional[bool] = None,
        revoke_on_unenroll_disabled: Optional[bool] = None,
        rights_management_services_template_id: Optional[str] = None,
        smb_auto_encrypted_file_extensions: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        exempt_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        protected_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        days_without_contact_before_unenroll: Optional[int] = None,
        mdm_enrollment_url: Optional[str] = None,
        minutes_of_inactivity_before_device_lock: Optional[int] = None,
        number_of_past_pins_remembered: Optional[int] = None,
        password_maximum_attempt_count: Optional[int] = None,
        pin_expiration_days: Optional[int] = None,
        pin_lowercase_letters: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements"]] = None,
        pin_minimum_length: Optional[int] = None,
        pin_special_characters: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements"]] = None,
        pin_uppercase_letters: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements"]] = None,
        revoke_on_mdm_handoff_disabled: Optional[bool] = None,
        windows_hello_for_business_blocked: Optional[bool] = None,
        **kwargs
    ) -> "models.MicrosoftGraphWindowsInformationProtectionPolicy":
        """Create new navigation property to windowsInformationProtectionPolicies for deviceAppManagement.

        Create new navigation property to windowsInformationProtectionPolicies for deviceAppManagement.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param azure_rights_management_services_allowed: Specifies whether to allow Azure RMS
         encryption for WIP.
        :type azure_rights_management_services_allowed: bool
        :param data_recovery_certificate: Windows Information Protection DataRecoveryCertificate.
        :type data_recovery_certificate: ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate
        :param enforcement_level:
        :type enforcement_level: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel
        :param enterprise_domain: Primary enterprise domain.
        :type enterprise_domain: str
        :param enterprise_internal_proxy_servers: This is the comma-separated list of internal proxy
         servers. For example, '157.54.14.28, 157.54.11.118, 10.202.14.167, 157.53.14.163,
         157.69.210.59'. These proxies have been configured by the admin to connect to specific
         resources on the Internet. They are considered to be enterprise network locations. The proxies
         are only leveraged in configuring the EnterpriseProxiedDomains policy to force traffic to the
         matched domains through these proxies.
        :type enterprise_internal_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_ip_ranges: Sets the enterprise IP ranges that define the computers in the
         enterprise network. Data that comes from those computers will be considered part of the
         enterprise and protected. These locations will be considered a safe destination for enterprise
         data to be shared to.
        :type enterprise_ip_ranges: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection]
        :param enterprise_ip_ranges_are_authoritative: Boolean value that tells the client to accept
         the configured list and not to use heuristics to attempt to find other subnets. Default is
         false.
        :type enterprise_ip_ranges_are_authoritative: bool
        :param enterprise_network_domain_names: This is the list of domains that comprise the
         boundaries of the enterprise. Data from one of these domains that is sent to a device will be
         considered enterprise data and protected These locations will be considered a safe destination
         for enterprise data to be shared to.
        :type enterprise_network_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_protected_domain_names: List of enterprise domains to be protected.
        :type enterprise_protected_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxied_domains: Contains a list of Enterprise resource domains hosted in the
         cloud that need to be protected. Connections to these resources are considered enterprise data.
         If a proxy is paired with a cloud resource, traffic to the cloud resource will be routed
         through the enterprise network via the denoted proxy server (on Port 80). A proxy server used
         for this purpose must also be configured using the EnterpriseInternalProxyServers policy.
        :type enterprise_proxied_domains: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection]
        :param enterprise_proxy_servers: This is a list of proxy servers. Any server not on this list
         is considered non-enterprise.
        :type enterprise_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxy_servers_are_authoritative: Boolean value that tells the client to
         accept the configured list of proxies and not try to detect other work proxies. Default is
         false.
        :type enterprise_proxy_servers_are_authoritative: bool
        :param exempt_apps: Exempt applications can also access enterprise data, but the data handled
         by those applications are not protected. This is because some critical enterprise applications
         may have compatibility problems with encrypted data.
        :type exempt_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param icons_visible: Determines whether overlays are added to icons for WIP protected files in
         Explorer and enterprise only app tiles in the Start menu. Starting in Windows 10, version 1703
         this setting also configures the visibility of the WIP icon in the title bar of a WIP-protected
         app.
        :type icons_visible: bool
        :param indexing_encrypted_stores_or_items_blocked: This switch is for the Windows Search
         Indexer, to allow or disallow indexing of items.
        :type indexing_encrypted_stores_or_items_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param neutral_domain_resources: List of domain names that can used for work or personal
         resource.
        :type neutral_domain_resources: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param protected_apps: Protected applications can access enterprise data and the data handled
         by those applications are protected with encryption.
        :type protected_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param protection_under_lock_config_required: Specifies whether the protection under lock
         feature (also known as encrypt under pin) should be configured.
        :type protection_under_lock_config_required: bool
        :param revoke_on_unenroll_disabled: This policy controls whether to revoke the WIP keys when a
         device unenrolls from the management service. If set to 1 (Don't revoke keys), the keys will
         not be revoked and the user will continue to have access to protected files after unenrollment.
         If the keys are not revoked, there will be no revoked file cleanup subsequently.
        :type revoke_on_unenroll_disabled: bool
        :param rights_management_services_template_id: TemplateID GUID to use for RMS encryption. The
         RMS template allows the IT admin to configure the details about who has access to RMS-protected
         file and how long they have access.
        :type rights_management_services_template_id: str
        :param smb_auto_encrypted_file_extensions: Specifies a list of file extensions, so that files
         with these extensions are encrypted when copying from an SMB share within the corporate
         boundary.
        :type smb_auto_encrypted_file_extensions: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param assignments: Navigation property to list of security groups targeted for policy.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param exempt_app_locker_files: Another way to input exempt apps through xml files.
        :type exempt_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :param protected_app_locker_files: Another way to input protected apps through xml files.
        :type protected_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :param days_without_contact_before_unenroll: Offline interval before app data is wiped (days).
        :type days_without_contact_before_unenroll: int
        :param mdm_enrollment_url: Enrollment url for the MDM.
        :type mdm_enrollment_url: str
        :param minutes_of_inactivity_before_device_lock: Specifies the maximum amount of time (in
         minutes) allowed after the device is idle that will cause the device to become PIN or password
         locked.   Range is an integer X where 0 <= X <= 999.
        :type minutes_of_inactivity_before_device_lock: int
        :param number_of_past_pins_remembered: Integer value that specifies the number of past PINs
         that can be associated to a user account that can't be reused. The largest number you can
         configure for this policy setting is 50. The lowest number you can configure for this policy
         setting is 0. If this policy is set to 0, then storage of previous PINs is not required. This
         node was added in Windows 10, version 1511. Default is 0.
        :type number_of_past_pins_remembered: int
        :param password_maximum_attempt_count: The number of authentication failures allowed before the
         device will be wiped. A value of 0 disables device wipe functionality. Range is an integer X
         where 4 <= X <= 16 for desktop and 0 <= X <= 999 for mobile devices.
        :type password_maximum_attempt_count: int
        :param pin_expiration_days: Integer value specifies the period of time (in days) that a PIN can
         be used before the system requires the user to change it. The largest number you can configure
         for this policy setting is 730. The lowest number you can configure for this policy setting is
         0. If this policy is set to 0, then the user's PIN will never expire. This node was added in
         Windows 10, version 1511. Default is 0.
        :type pin_expiration_days: int
        :param pin_lowercase_letters:
        :type pin_lowercase_letters: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements
        :param pin_minimum_length: Integer value that sets the minimum number of characters required
         for the PIN. Default value is 4. The lowest number you can configure for this policy setting is
         4. The largest number you can configure must be less than the number configured in the Maximum
         PIN length policy setting or the number 127, whichever is the lowest.
        :type pin_minimum_length: int
        :param pin_special_characters:
        :type pin_special_characters: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements
        :param pin_uppercase_letters:
        :type pin_uppercase_letters: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements
        :param revoke_on_mdm_handoff_disabled: New property in RS2, pending documentation.
        :type revoke_on_mdm_handoff_disabled: bool
        :param windows_hello_for_business_blocked: Boolean value that sets Windows Hello for Business
         as a method for signing into Windows.
        :type windows_hello_for_business_blocked: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphWindowsInformationProtectionPolicy, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphWindowsInformationProtectionPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphWindowsInformationProtectionPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, azure_rights_management_services_allowed=azure_rights_management_services_allowed, data_recovery_certificate=data_recovery_certificate, enforcement_level=enforcement_level, enterprise_domain=enterprise_domain, enterprise_internal_proxy_servers=enterprise_internal_proxy_servers, enterprise_ip_ranges=enterprise_ip_ranges, enterprise_ip_ranges_are_authoritative=enterprise_ip_ranges_are_authoritative, enterprise_network_domain_names=enterprise_network_domain_names, enterprise_protected_domain_names=enterprise_protected_domain_names, enterprise_proxied_domains=enterprise_proxied_domains, enterprise_proxy_servers=enterprise_proxy_servers, enterprise_proxy_servers_are_authoritative=enterprise_proxy_servers_are_authoritative, exempt_apps=exempt_apps, icons_visible=icons_visible, indexing_encrypted_stores_or_items_blocked=indexing_encrypted_stores_or_items_blocked, is_assigned=is_assigned, neutral_domain_resources=neutral_domain_resources, protected_apps=protected_apps, protection_under_lock_config_required=protection_under_lock_config_required, revoke_on_unenroll_disabled=revoke_on_unenroll_disabled, rights_management_services_template_id=rights_management_services_template_id, smb_auto_encrypted_file_extensions=smb_auto_encrypted_file_extensions, assignments=assignments, exempt_app_locker_files=exempt_app_locker_files, protected_app_locker_files=protected_app_locker_files, days_without_contact_before_unenroll=days_without_contact_before_unenroll, mdm_enrollment_url=mdm_enrollment_url, minutes_of_inactivity_before_device_lock=minutes_of_inactivity_before_device_lock, number_of_past_pins_remembered=number_of_past_pins_remembered, password_maximum_attempt_count=password_maximum_attempt_count, pin_expiration_days=pin_expiration_days, pin_lowercase_letters=pin_lowercase_letters, pin_minimum_length=pin_minimum_length, pin_special_characters=pin_special_characters, pin_uppercase_letters=pin_uppercase_letters, revoke_on_mdm_handoff_disabled=revoke_on_mdm_handoff_disabled, windows_hello_for_business_blocked=windows_hello_for_business_blocked)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_window_information_protection_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphWindowsInformationProtectionPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphWindowsInformationProtectionPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/windowsInformationProtectionPolicies'}  # type: ignore

    async def get_window_information_protection_policy(
        self,
        windows_information_protection_policy_id: str,
        select: Optional[List[Union[str, "models.Enum138"]]] = None,
        expand: Optional[List[Union[str, "models.Enum139"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphWindowsInformationProtectionPolicy":
        """Get windowsInformationProtectionPolicies from deviceAppManagement.

        Get windowsInformationProtectionPolicies from deviceAppManagement.

        :param windows_information_protection_policy_id: key: id of windowsInformationProtectionPolicy.
        :type windows_information_protection_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~devices_corporate_management.models.Enum138]
        :param expand: Expand related entities.
        :type expand: list[str or ~devices_corporate_management.models.Enum139]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphWindowsInformationProtectionPolicy, or the result of cls(response)
        :rtype: ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphWindowsInformationProtectionPolicy"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_window_information_protection_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'windowsInformationProtectionPolicy-id': self._serialize.url("windows_information_protection_policy_id", windows_information_protection_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphWindowsInformationProtectionPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/windowsInformationProtectionPolicies/{windowsInformationProtectionPolicy-id}'}  # type: ignore

    async def update_window_information_protection_policy(
        self,
        windows_information_protection_policy_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        version: Optional[str] = None,
        azure_rights_management_services_allowed: Optional[bool] = None,
        data_recovery_certificate: Optional["models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate"] = None,
        enforcement_level: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel"]] = None,
        enterprise_domain: Optional[str] = None,
        enterprise_internal_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_ip_ranges: Optional[List["models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection"]] = None,
        enterprise_ip_ranges_are_authoritative: Optional[bool] = None,
        enterprise_network_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_protected_domain_names: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxied_domains: Optional[List["models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection"]] = None,
        enterprise_proxy_servers: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        enterprise_proxy_servers_are_authoritative: Optional[bool] = None,
        exempt_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        icons_visible: Optional[bool] = None,
        indexing_encrypted_stores_or_items_blocked: Optional[bool] = None,
        is_assigned: Optional[bool] = None,
        neutral_domain_resources: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        protected_apps: Optional[List["models.MicrosoftGraphWindowsInformationProtectionApp"]] = None,
        protection_under_lock_config_required: Optional[bool] = None,
        revoke_on_unenroll_disabled: Optional[bool] = None,
        rights_management_services_template_id: Optional[str] = None,
        smb_auto_encrypted_file_extensions: Optional[List["models.MicrosoftGraphWindowsInformationProtectionResourceCollection"]] = None,
        assignments: Optional[List["models.MicrosoftGraphTargetedManagedAppPolicyAssignment"]] = None,
        exempt_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        protected_app_locker_files: Optional[List["models.MicrosoftGraphWindowsInformationProtectionAppLockerFile"]] = None,
        days_without_contact_before_unenroll: Optional[int] = None,
        mdm_enrollment_url: Optional[str] = None,
        minutes_of_inactivity_before_device_lock: Optional[int] = None,
        number_of_past_pins_remembered: Optional[int] = None,
        password_maximum_attempt_count: Optional[int] = None,
        pin_expiration_days: Optional[int] = None,
        pin_lowercase_letters: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements"]] = None,
        pin_minimum_length: Optional[int] = None,
        pin_special_characters: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements"]] = None,
        pin_uppercase_letters: Optional[Union[str, "models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements"]] = None,
        revoke_on_mdm_handoff_disabled: Optional[bool] = None,
        windows_hello_for_business_blocked: Optional[bool] = None,
        **kwargs
    ) -> None:
        """Update the navigation property windowsInformationProtectionPolicies in deviceAppManagement.

        Update the navigation property windowsInformationProtectionPolicies in deviceAppManagement.

        :param windows_information_protection_policy_id: key: id of windowsInformationProtectionPolicy.
        :type windows_information_protection_policy_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The date and time the policy was created.
        :type created_date_time: ~datetime.datetime
        :param description: The policy's description.
        :type description: str
        :param display_name: Policy display name.
        :type display_name: str
        :param last_modified_date_time: Last time the policy was modified.
        :type last_modified_date_time: ~datetime.datetime
        :param version: Version of the entity.
        :type version: str
        :param azure_rights_management_services_allowed: Specifies whether to allow Azure RMS
         encryption for WIP.
        :type azure_rights_management_services_allowed: bool
        :param data_recovery_certificate: Windows Information Protection DataRecoveryCertificate.
        :type data_recovery_certificate: ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionDataRecoveryCertificate
        :param enforcement_level:
        :type enforcement_level: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionEnforcementLevel
        :param enterprise_domain: Primary enterprise domain.
        :type enterprise_domain: str
        :param enterprise_internal_proxy_servers: This is the comma-separated list of internal proxy
         servers. For example, '157.54.14.28, 157.54.11.118, 10.202.14.167, 157.53.14.163,
         157.69.210.59'. These proxies have been configured by the admin to connect to specific
         resources on the Internet. They are considered to be enterprise network locations. The proxies
         are only leveraged in configuring the EnterpriseProxiedDomains policy to force traffic to the
         matched domains through these proxies.
        :type enterprise_internal_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_ip_ranges: Sets the enterprise IP ranges that define the computers in the
         enterprise network. Data that comes from those computers will be considered part of the
         enterprise and protected. These locations will be considered a safe destination for enterprise
         data to be shared to.
        :type enterprise_ip_ranges: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionIpRangeCollection]
        :param enterprise_ip_ranges_are_authoritative: Boolean value that tells the client to accept
         the configured list and not to use heuristics to attempt to find other subnets. Default is
         false.
        :type enterprise_ip_ranges_are_authoritative: bool
        :param enterprise_network_domain_names: This is the list of domains that comprise the
         boundaries of the enterprise. Data from one of these domains that is sent to a device will be
         considered enterprise data and protected These locations will be considered a safe destination
         for enterprise data to be shared to.
        :type enterprise_network_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_protected_domain_names: List of enterprise domains to be protected.
        :type enterprise_protected_domain_names: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxied_domains: Contains a list of Enterprise resource domains hosted in the
         cloud that need to be protected. Connections to these resources are considered enterprise data.
         If a proxy is paired with a cloud resource, traffic to the cloud resource will be routed
         through the enterprise network via the denoted proxy server (on Port 80). A proxy server used
         for this purpose must also be configured using the EnterpriseInternalProxyServers policy.
        :type enterprise_proxied_domains: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionProxiedDomainCollection]
        :param enterprise_proxy_servers: This is a list of proxy servers. Any server not on this list
         is considered non-enterprise.
        :type enterprise_proxy_servers: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param enterprise_proxy_servers_are_authoritative: Boolean value that tells the client to
         accept the configured list of proxies and not try to detect other work proxies. Default is
         false.
        :type enterprise_proxy_servers_are_authoritative: bool
        :param exempt_apps: Exempt applications can also access enterprise data, but the data handled
         by those applications are not protected. This is because some critical enterprise applications
         may have compatibility problems with encrypted data.
        :type exempt_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param icons_visible: Determines whether overlays are added to icons for WIP protected files in
         Explorer and enterprise only app tiles in the Start menu. Starting in Windows 10, version 1703
         this setting also configures the visibility of the WIP icon in the title bar of a WIP-protected
         app.
        :type icons_visible: bool
        :param indexing_encrypted_stores_or_items_blocked: This switch is for the Windows Search
         Indexer, to allow or disallow indexing of items.
        :type indexing_encrypted_stores_or_items_blocked: bool
        :param is_assigned: Indicates if the policy is deployed to any inclusion groups or not.
        :type is_assigned: bool
        :param neutral_domain_resources: List of domain names that can used for work or personal
         resource.
        :type neutral_domain_resources: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param protected_apps: Protected applications can access enterprise data and the data handled
         by those applications are protected with encryption.
        :type protected_apps: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionApp]
        :param protection_under_lock_config_required: Specifies whether the protection under lock
         feature (also known as encrypt under pin) should be configured.
        :type protection_under_lock_config_required: bool
        :param revoke_on_unenroll_disabled: This policy controls whether to revoke the WIP keys when a
         device unenrolls from the management service. If set to 1 (Don't revoke keys), the keys will
         not be revoked and the user will continue to have access to protected files after unenrollment.
         If the keys are not revoked, there will be no revoked file cleanup subsequently.
        :type revoke_on_unenroll_disabled: bool
        :param rights_management_services_template_id: TemplateID GUID to use for RMS encryption. The
         RMS template allows the IT admin to configure the details about who has access to RMS-protected
         file and how long they have access.
        :type rights_management_services_template_id: str
        :param smb_auto_encrypted_file_extensions: Specifies a list of file extensions, so that files
         with these extensions are encrypted when copying from an SMB share within the corporate
         boundary.
        :type smb_auto_encrypted_file_extensions: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionResourceCollection]
        :param assignments: Navigation property to list of security groups targeted for policy.
        :type assignments: list[~devices_corporate_management.models.MicrosoftGraphTargetedManagedAppPolicyAssignment]
        :param exempt_app_locker_files: Another way to input exempt apps through xml files.
        :type exempt_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :param protected_app_locker_files: Another way to input protected apps through xml files.
        :type protected_app_locker_files: list[~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionAppLockerFile]
        :param days_without_contact_before_unenroll: Offline interval before app data is wiped (days).
        :type days_without_contact_before_unenroll: int
        :param mdm_enrollment_url: Enrollment url for the MDM.
        :type mdm_enrollment_url: str
        :param minutes_of_inactivity_before_device_lock: Specifies the maximum amount of time (in
         minutes) allowed after the device is idle that will cause the device to become PIN or password
         locked.   Range is an integer X where 0 <= X <= 999.
        :type minutes_of_inactivity_before_device_lock: int
        :param number_of_past_pins_remembered: Integer value that specifies the number of past PINs
         that can be associated to a user account that can't be reused. The largest number you can
         configure for this policy setting is 50. The lowest number you can configure for this policy
         setting is 0. If this policy is set to 0, then storage of previous PINs is not required. This
         node was added in Windows 10, version 1511. Default is 0.
        :type number_of_past_pins_remembered: int
        :param password_maximum_attempt_count: The number of authentication failures allowed before the
         device will be wiped. A value of 0 disables device wipe functionality. Range is an integer X
         where 4 <= X <= 16 for desktop and 0 <= X <= 999 for mobile devices.
        :type password_maximum_attempt_count: int
        :param pin_expiration_days: Integer value specifies the period of time (in days) that a PIN can
         be used before the system requires the user to change it. The largest number you can configure
         for this policy setting is 730. The lowest number you can configure for this policy setting is
         0. If this policy is set to 0, then the user's PIN will never expire. This node was added in
         Windows 10, version 1511. Default is 0.
        :type pin_expiration_days: int
        :param pin_lowercase_letters:
        :type pin_lowercase_letters: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements
        :param pin_minimum_length: Integer value that sets the minimum number of characters required
         for the PIN. Default value is 4. The lowest number you can configure for this policy setting is
         4. The largest number you can configure must be less than the number configured in the Maximum
         PIN length policy setting or the number 127, whichever is the lowest.
        :type pin_minimum_length: int
        :param pin_special_characters:
        :type pin_special_characters: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements
        :param pin_uppercase_letters:
        :type pin_uppercase_letters: str or ~devices_corporate_management.models.MicrosoftGraphWindowsInformationProtectionPinCharacterRequirements
        :param revoke_on_mdm_handoff_disabled: New property in RS2, pending documentation.
        :type revoke_on_mdm_handoff_disabled: bool
        :param windows_hello_for_business_blocked: Boolean value that sets Windows Hello for Business
         as a method for signing into Windows.
        :type windows_hello_for_business_blocked: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphWindowsInformationProtectionPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, last_modified_date_time=last_modified_date_time, version=version, azure_rights_management_services_allowed=azure_rights_management_services_allowed, data_recovery_certificate=data_recovery_certificate, enforcement_level=enforcement_level, enterprise_domain=enterprise_domain, enterprise_internal_proxy_servers=enterprise_internal_proxy_servers, enterprise_ip_ranges=enterprise_ip_ranges, enterprise_ip_ranges_are_authoritative=enterprise_ip_ranges_are_authoritative, enterprise_network_domain_names=enterprise_network_domain_names, enterprise_protected_domain_names=enterprise_protected_domain_names, enterprise_proxied_domains=enterprise_proxied_domains, enterprise_proxy_servers=enterprise_proxy_servers, enterprise_proxy_servers_are_authoritative=enterprise_proxy_servers_are_authoritative, exempt_apps=exempt_apps, icons_visible=icons_visible, indexing_encrypted_stores_or_items_blocked=indexing_encrypted_stores_or_items_blocked, is_assigned=is_assigned, neutral_domain_resources=neutral_domain_resources, protected_apps=protected_apps, protection_under_lock_config_required=protection_under_lock_config_required, revoke_on_unenroll_disabled=revoke_on_unenroll_disabled, rights_management_services_template_id=rights_management_services_template_id, smb_auto_encrypted_file_extensions=smb_auto_encrypted_file_extensions, assignments=assignments, exempt_app_locker_files=exempt_app_locker_files, protected_app_locker_files=protected_app_locker_files, days_without_contact_before_unenroll=days_without_contact_before_unenroll, mdm_enrollment_url=mdm_enrollment_url, minutes_of_inactivity_before_device_lock=minutes_of_inactivity_before_device_lock, number_of_past_pins_remembered=number_of_past_pins_remembered, password_maximum_attempt_count=password_maximum_attempt_count, pin_expiration_days=pin_expiration_days, pin_lowercase_letters=pin_lowercase_letters, pin_minimum_length=pin_minimum_length, pin_special_characters=pin_special_characters, pin_uppercase_letters=pin_uppercase_letters, revoke_on_mdm_handoff_disabled=revoke_on_mdm_handoff_disabled, windows_hello_for_business_blocked=windows_hello_for_business_blocked)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_window_information_protection_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'windowsInformationProtectionPolicy-id': self._serialize.url("windows_information_protection_policy_id", windows_information_protection_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphWindowsInformationProtectionPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/windowsInformationProtectionPolicies/{windowsInformationProtectionPolicy-id}'}  # type: ignore

    async def delete_window_information_protection_policy(
        self,
        windows_information_protection_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property windowsInformationProtectionPolicies for deviceAppManagement.

        Delete navigation property windowsInformationProtectionPolicies for deviceAppManagement.

        :param windows_information_protection_policy_id: key: id of windowsInformationProtectionPolicy.
        :type windows_information_protection_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_window_information_protection_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'windowsInformationProtectionPolicy-id': self._serialize.url("windows_information_protection_policy_id", windows_information_protection_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_window_information_protection_policy.metadata = {'url': '/deviceAppManagement/windowsInformationProtectionPolicies/{windowsInformationProtectionPolicy-id}'}  # type: ignore
