# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class GroupCalendarViewCalendarOperations(object):
    """GroupCalendarViewCalendarOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~calendar.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_calendar_permission(
        self,
        group_id,  # type: str
        event_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum82"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum83"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfCalendarPermission0"]
        """Get calendarPermissions from groups.

        Get calendarPermissions from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~calendar.models.Enum82]
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum83]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCalendarPermission0 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~calendar.models.CollectionOfCalendarPermission0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCalendarPermission0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_calendar_permission.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'event-id': self._serialize.url("event_id", event_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCalendarPermission0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_calendar_permission.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions'}  # type: ignore

    def create_calendar_permission(
        self,
        group_id,  # type: str
        event_id,  # type: str
        id=None,  # type: Optional[str]
        allowed_roles=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphCalendarRoleType"]]]
        email_address=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        is_inside_organization=None,  # type: Optional[bool]
        is_removable=None,  # type: Optional[bool]
        role=None,  # type: Optional[Union[str, "models.MicrosoftGraphCalendarRoleType"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphCalendarPermission"
        """Create new navigation property to calendarPermissions for groups.

        Create new navigation property to calendarPermissions for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_roles: List of allowed sharing or delegating permission levels for the calendar.
         Possible values are: none, freeBusyRead, limitedRead, read, write,
         delegateWithoutPrivateEventAccess, delegateWithPrivateEventAccess, custom.
        :type allowed_roles: list[str or ~calendar.models.MicrosoftGraphCalendarRoleType]
        :param email_address: emailAddress.
        :type email_address: ~calendar.models.MicrosoftGraphEmailAddress
        :param is_inside_organization: True if the user in context (sharee or delegate) is inside the
         same organization as the calendar owner.
        :type is_inside_organization: bool
        :param is_removable: True if the user can be removed from the list of sharees or delegates for
         the specified calendar, false otherwise. The 'My organization' user determines the permissions
         other people within your organization have to the given calendar. You cannot remove 'My
         organization' as a sharee to a calendar.
        :type is_removable: bool
        :param role:
        :type role: str or ~calendar.models.MicrosoftGraphCalendarRoleType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCalendarPermission, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphCalendarPermission
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCalendarPermission"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphCalendarPermission(id=id, allowed_roles=allowed_roles, email_address=email_address, is_inside_organization=is_inside_organization, is_removable=is_removable, role=role)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_calendar_permission.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphCalendarPermission')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCalendarPermission', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_calendar_permission.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions'}  # type: ignore

    def get_calendar_permission(
        self,
        group_id,  # type: str
        event_id,  # type: str
        calendar_permission_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum84"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphCalendarPermission"
        """Get calendarPermissions from groups.

        Get calendarPermissions from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param calendar_permission_id: key: id of calendarPermission.
        :type calendar_permission_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum84]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCalendarPermission, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphCalendarPermission
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCalendarPermission"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_calendar_permission.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'calendarPermission-id': self._serialize.url("calendar_permission_id", calendar_permission_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCalendarPermission', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_calendar_permission.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions/{calendarPermission-id}'}  # type: ignore

    def update_calendar_permission(
        self,
        group_id,  # type: str
        event_id,  # type: str
        calendar_permission_id,  # type: str
        id=None,  # type: Optional[str]
        allowed_roles=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphCalendarRoleType"]]]
        email_address=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        is_inside_organization=None,  # type: Optional[bool]
        is_removable=None,  # type: Optional[bool]
        role=None,  # type: Optional[Union[str, "models.MicrosoftGraphCalendarRoleType"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property calendarPermissions in groups.

        Update the navigation property calendarPermissions in groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param calendar_permission_id: key: id of calendarPermission.
        :type calendar_permission_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_roles: List of allowed sharing or delegating permission levels for the calendar.
         Possible values are: none, freeBusyRead, limitedRead, read, write,
         delegateWithoutPrivateEventAccess, delegateWithPrivateEventAccess, custom.
        :type allowed_roles: list[str or ~calendar.models.MicrosoftGraphCalendarRoleType]
        :param email_address: emailAddress.
        :type email_address: ~calendar.models.MicrosoftGraphEmailAddress
        :param is_inside_organization: True if the user in context (sharee or delegate) is inside the
         same organization as the calendar owner.
        :type is_inside_organization: bool
        :param is_removable: True if the user can be removed from the list of sharees or delegates for
         the specified calendar, false otherwise. The 'My organization' user determines the permissions
         other people within your organization have to the given calendar. You cannot remove 'My
         organization' as a sharee to a calendar.
        :type is_removable: bool
        :param role:
        :type role: str or ~calendar.models.MicrosoftGraphCalendarRoleType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphCalendarPermission(id=id, allowed_roles=allowed_roles, email_address=email_address, is_inside_organization=is_inside_organization, is_removable=is_removable, role=role)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_calendar_permission.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'calendarPermission-id': self._serialize.url("calendar_permission_id", calendar_permission_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphCalendarPermission')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_calendar_permission.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions/{calendarPermission-id}'}  # type: ignore

    def delete_calendar_permission(
        self,
        group_id,  # type: str
        event_id,  # type: str
        calendar_permission_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property calendarPermissions for groups.

        Delete navigation property calendarPermissions for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param calendar_permission_id: key: id of calendarPermission.
        :type calendar_permission_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_calendar_permission.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'calendarPermission-id': self._serialize.url("calendar_permission_id", calendar_permission_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_calendar_permission.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarPermissions/{calendarPermission-id}'}  # type: ignore

    def list_calendar_view(
        self,
        group_id,  # type: str
        event_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum85"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum86"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum87"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfEvent4"]
        """Get calendarView from groups.

        Get calendarView from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~calendar.models.Enum85]
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum86]
        :param expand: Expand related entities.
        :type expand: list[str or ~calendar.models.Enum87]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEvent4 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~calendar.models.CollectionOfEvent4]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEvent4"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_calendar_view.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'event-id': self._serialize.url("event_id", event_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEvent4', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_calendar_view.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarView'}  # type: ignore

    def create_calendar_view(
        self,
        group_id,  # type: str
        event_id,  # type: str
        id=None,  # type: Optional[str]
        categories=None,  # type: Optional[List[str]]
        change_key=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        allow_new_time_proposals=None,  # type: Optional[bool]
        attendees=None,  # type: Optional[List["models.MicrosoftGraphAttendee"]]
        body=None,  # type: Optional["models.MicrosoftGraphItemBody"]
        body_preview=None,  # type: Optional[str]
        end=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        has_attachments=None,  # type: Optional[bool]
        i_cal_u_id=None,  # type: Optional[str]
        importance=None,  # type: Optional[Union[str, "models.MicrosoftGraphImportance"]]
        is_all_day=None,  # type: Optional[bool]
        is_cancelled=None,  # type: Optional[bool]
        is_online_meeting=None,  # type: Optional[bool]
        is_organizer=None,  # type: Optional[bool]
        is_reminder_on=None,  # type: Optional[bool]
        locations=None,  # type: Optional[List["models.MicrosoftGraphLocation"]]
        online_meeting_provider=None,  # type: Optional[Union[str, "models.MicrosoftGraphOnlineMeetingProviderType"]]
        online_meeting_url=None,  # type: Optional[str]
        original_end_time_zone=None,  # type: Optional[str]
        original_start=None,  # type: Optional[datetime.datetime]
        original_start_time_zone=None,  # type: Optional[str]
        reminder_minutes_before_start=None,  # type: Optional[int]
        response_requested=None,  # type: Optional[bool]
        response_status=None,  # type: Optional["models.MicrosoftGraphResponseStatus"]
        sensitivity=None,  # type: Optional[Union[str, "models.MicrosoftGraphSensitivity"]]
        series_master_id=None,  # type: Optional[str]
        show_as=None,  # type: Optional[Union[str, "models.MicrosoftGraphFreeBusyStatus"]]
        start=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        subject=None,  # type: Optional[str]
        transaction_id=None,  # type: Optional[str]
        type=None,  # type: Optional[Union[str, "models.MicrosoftGraphEventType"]]
        web_link=None,  # type: Optional[str]
        attachments=None,  # type: Optional[List["models.MicrosoftGraphAttachment"]]
        calendar=None,  # type: Optional["models.MicrosoftGraphCalendar"]
        extensions=None,  # type: Optional[List["models.MicrosoftGraphExtension"]]
        instances=None,  # type: Optional[List["models.MicrosoftGraphEvent"]]
        multi_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]]
        single_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]]
        pattern=None,  # type: Optional["models.MicrosoftGraphRecurrencePattern"]
        range=None,  # type: Optional["models.MicrosoftGraphRecurrenceRange"]
        email_address=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        conference_id=None,  # type: Optional[str]
        join_url=None,  # type: Optional[str]
        phones=None,  # type: Optional[List["models.MicrosoftGraphPhone"]]
        quick_dial=None,  # type: Optional[str]
        toll_free_numbers=None,  # type: Optional[List[str]]
        toll_number=None,  # type: Optional[str]
        address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        coordinates=None,  # type: Optional["models.MicrosoftGraphOutlookGeoCoordinates"]
        display_name=None,  # type: Optional[str]
        location_email_address=None,  # type: Optional[str]
        location_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationType"]]
        location_uri=None,  # type: Optional[str]
        unique_id=None,  # type: Optional[str]
        unique_id_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationUniqueIdType"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEvent"
        """Create new navigation property to calendarView for groups.

        Create new navigation property to calendarView for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param id: Read-only.
        :type id: str
        :param categories: The categories associated with the item.
        :type categories: list[str]
        :param change_key: Identifies the version of the item. Every time the item is changed,
         changeKey changes as well. This allows Exchange to apply changes to the correct version of the
         object. Read-only.
        :type change_key: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param allow_new_time_proposals: True if the meeting organizer allows invitees to propose a new
         time when responding, false otherwise. Optional. Default is true.
        :type allow_new_time_proposals: bool
        :param attendees: The collection of attendees for the event.
        :type attendees: list[~calendar.models.MicrosoftGraphAttendee]
        :param body: itemBody.
        :type body: ~calendar.models.MicrosoftGraphItemBody
        :param body_preview: The preview of the message associated with the event. It is in text
         format.
        :type body_preview: str
        :param end: dateTimeTimeZone.
        :type end: ~calendar.models.MicrosoftGraphDateTimeZone
        :param has_attachments: Set to true if the event has attachments.
        :type has_attachments: bool
        :param i_cal_u_id: A unique identifier that is shared by all instances of an event across
         different calendars. Read-only.
        :type i_cal_u_id: str
        :param importance:
        :type importance: str or ~calendar.models.MicrosoftGraphImportance
        :param is_all_day: Set to true if the event lasts all day.
        :type is_all_day: bool
        :param is_cancelled: Set to true if the event has been canceled.
        :type is_cancelled: bool
        :param is_online_meeting: True if this event has online meeting information, false otherwise.
         Default is false. Optional.
        :type is_online_meeting: bool
        :param is_organizer: Set to true if the calendar owner (specified by the owner property of the
         calendar) is the organizer of the event (specified by the organizer property of the event).
         This also applies if a delegate organized the event on behalf of the owner.
        :type is_organizer: bool
        :param is_reminder_on: Set to true if an alert is set to remind the user of the event.
        :type is_reminder_on: bool
        :param locations: The locations where the event is held or attended from. The location and
         locations properties always correspond with each other. If you update the location property,
         any prior locations in the locations collection would be removed and replaced by the new
         location value.
        :type locations: list[~calendar.models.MicrosoftGraphLocation]
        :param online_meeting_provider:
        :type online_meeting_provider: str or ~calendar.models.MicrosoftGraphOnlineMeetingProviderType
        :param online_meeting_url: A URL for an online meeting. The property is set only when an
         organizer specifies an event as an online meeting such as a Skype meeting. Read-only.
        :type online_meeting_url: str
        :param original_end_time_zone: The end time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_end_time_zone: str
        :param original_start: The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type original_start: ~datetime.datetime
        :param original_start_time_zone: The start time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_start_time_zone: str
        :param reminder_minutes_before_start: The number of minutes before the event start time that
         the reminder alert occurs.
        :type reminder_minutes_before_start: int
        :param response_requested: Default is true, which represents the organizer would like an
         invitee to send a response to the event.
        :type response_requested: bool
        :param response_status: responseStatus.
        :type response_status: ~calendar.models.MicrosoftGraphResponseStatus
        :param sensitivity:
        :type sensitivity: str or ~calendar.models.MicrosoftGraphSensitivity
        :param series_master_id: The ID for the recurring series master item, if this event is part of
         a recurring series.
        :type series_master_id: str
        :param show_as:
        :type show_as: str or ~calendar.models.MicrosoftGraphFreeBusyStatus
        :param start: dateTimeTimeZone.
        :type start: ~calendar.models.MicrosoftGraphDateTimeZone
        :param subject: The text of the event's subject line.
        :type subject: str
        :param transaction_id: A custom identifier specified by a client app for the server to avoid
         redundant POST operations in case of client retries to create the same event. This is useful
         when low network connectivity causes the client to time out before receiving a response from
         the server for the client's prior create-event request. After you set transactionId when
         creating an event, you cannot change transactionId in a subsequent update. This property is
         only returned in a response payload if an app has set it. Optional.
        :type transaction_id: str
        :param type:
        :type type: str or ~calendar.models.MicrosoftGraphEventType
        :param web_link: The URL to open the event in Outlook on the web.Outlook on the web opens the
         event in the browser if you are signed in to your mailbox. Otherwise, Outlook on the web
         prompts you to sign in.This URL can be accessed from within an iFrame.
        :type web_link: str
        :param attachments: The collection of fileAttachment and itemAttachment attachments for the
         event. Navigation property. Read-only. Nullable.
        :type attachments: list[~calendar.models.MicrosoftGraphAttachment]
        :param calendar: calendar.
        :type calendar: ~calendar.models.MicrosoftGraphCalendar
        :param extensions: The collection of open extensions defined for the event. Read-only.
         Nullable.
        :type extensions: list[~calendar.models.MicrosoftGraphExtension]
        :param instances: The instances of the event. Navigation property. Read-only. Nullable.
        :type instances: list[~calendar.models.MicrosoftGraphEvent]
        :param multi_value_extended_properties: The collection of multi-value extended properties
         defined for the event. Read-only. Nullable.
        :type multi_value_extended_properties: list[~calendar.models.MicrosoftGraphMultiValueLegacyExtendedProperty]
        :param single_value_extended_properties: The collection of single-value extended properties
         defined for the event. Read-only. Nullable.
        :type single_value_extended_properties: list[~calendar.models.MicrosoftGraphSingleValueLegacyExtendedProperty]
        :param pattern: recurrencePattern.
        :type pattern: ~calendar.models.MicrosoftGraphRecurrencePattern
        :param range: recurrenceRange.
        :type range: ~calendar.models.MicrosoftGraphRecurrenceRange
        :param email_address: emailAddress.
        :type email_address: ~calendar.models.MicrosoftGraphEmailAddress
        :param conference_id: The ID of the conference.
        :type conference_id: str
        :param join_url: The external link that launches the online meeting. This is a URL that clients
         will launch into a browser and will redirect the user to join the meeting.
        :type join_url: str
        :param phones: All of the phone numbers associated with this conference.
        :type phones: list[~calendar.models.MicrosoftGraphPhone]
        :param quick_dial: The pre-formatted quickdial for this call.
        :type quick_dial: str
        :param toll_free_numbers: The toll free numbers that can be used to join the conference.
        :type toll_free_numbers: list[str]
        :param toll_number: The toll number that can be used to join the conference.
        :type toll_number: str
        :param address: physicalAddress.
        :type address: ~calendar.models.MicrosoftGraphPhysicalAddress
        :param coordinates: outlookGeoCoordinates.
        :type coordinates: ~calendar.models.MicrosoftGraphOutlookGeoCoordinates
        :param display_name: The name associated with the location.
        :type display_name: str
        :param location_email_address: Optional email address of the location.
        :type location_email_address: str
        :param location_type:
        :type location_type: str or ~calendar.models.MicrosoftGraphLocationType
        :param location_uri: Optional URI representing the location.
        :type location_uri: str
        :param unique_id: For internal use only.
        :type unique_id: str
        :param unique_id_type:
        :type unique_id_type: str or ~calendar.models.MicrosoftGraphLocationUniqueIdType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEvent, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphEvent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEvent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEvent(id=id, categories=categories, change_key=change_key, created_date_time=created_date_time, last_modified_date_time=last_modified_date_time, allow_new_time_proposals=allow_new_time_proposals, attendees=attendees, body=body, body_preview=body_preview, end=end, has_attachments=has_attachments, i_cal_u_id=i_cal_u_id, importance=importance, is_all_day=is_all_day, is_cancelled=is_cancelled, is_online_meeting=is_online_meeting, is_organizer=is_organizer, is_reminder_on=is_reminder_on, locations=locations, online_meeting_provider=online_meeting_provider, online_meeting_url=online_meeting_url, original_end_time_zone=original_end_time_zone, original_start=original_start, original_start_time_zone=original_start_time_zone, reminder_minutes_before_start=reminder_minutes_before_start, response_requested=response_requested, response_status=response_status, sensitivity=sensitivity, series_master_id=series_master_id, show_as=show_as, start=start, subject=subject, transaction_id=transaction_id, type=type, web_link=web_link, attachments=attachments, calendar=calendar, extensions=extensions, instances=instances, multi_value_extended_properties=multi_value_extended_properties, single_value_extended_properties=single_value_extended_properties, pattern=pattern, range=range, email_address=email_address, conference_id=conference_id, join_url=join_url, phones=phones, quick_dial=quick_dial, toll_free_numbers=toll_free_numbers, toll_number=toll_number, address=address, coordinates=coordinates, display_name=display_name, location_email_address=location_email_address, location_type=location_type, location_uri=location_uri, unique_id=unique_id, unique_id_type=unique_id_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_calendar_view.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEvent')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEvent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_calendar_view.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarView'}  # type: ignore

    def get_calendar_view(
        self,
        group_id,  # type: str
        event_id,  # type: str
        event_id1,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum88"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum89"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEvent"
        """Get calendarView from groups.

        Get calendarView from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param event_id1: key: id of event.
        :type event_id1: str
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum88]
        :param expand: Expand related entities.
        :type expand: list[str or ~calendar.models.Enum89]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEvent, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphEvent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEvent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_calendar_view.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'event-id1': self._serialize.url("event_id1", event_id1, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEvent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_calendar_view.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}'}  # type: ignore

    def update_calendar_view(
        self,
        group_id,  # type: str
        event_id,  # type: str
        event_id1,  # type: str
        id=None,  # type: Optional[str]
        categories=None,  # type: Optional[List[str]]
        change_key=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        allow_new_time_proposals=None,  # type: Optional[bool]
        attendees=None,  # type: Optional[List["models.MicrosoftGraphAttendee"]]
        body=None,  # type: Optional["models.MicrosoftGraphItemBody"]
        body_preview=None,  # type: Optional[str]
        end=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        has_attachments=None,  # type: Optional[bool]
        i_cal_u_id=None,  # type: Optional[str]
        importance=None,  # type: Optional[Union[str, "models.MicrosoftGraphImportance"]]
        is_all_day=None,  # type: Optional[bool]
        is_cancelled=None,  # type: Optional[bool]
        is_online_meeting=None,  # type: Optional[bool]
        is_organizer=None,  # type: Optional[bool]
        is_reminder_on=None,  # type: Optional[bool]
        locations=None,  # type: Optional[List["models.MicrosoftGraphLocation"]]
        online_meeting_provider=None,  # type: Optional[Union[str, "models.MicrosoftGraphOnlineMeetingProviderType"]]
        online_meeting_url=None,  # type: Optional[str]
        original_end_time_zone=None,  # type: Optional[str]
        original_start=None,  # type: Optional[datetime.datetime]
        original_start_time_zone=None,  # type: Optional[str]
        reminder_minutes_before_start=None,  # type: Optional[int]
        response_requested=None,  # type: Optional[bool]
        response_status=None,  # type: Optional["models.MicrosoftGraphResponseStatus"]
        sensitivity=None,  # type: Optional[Union[str, "models.MicrosoftGraphSensitivity"]]
        series_master_id=None,  # type: Optional[str]
        show_as=None,  # type: Optional[Union[str, "models.MicrosoftGraphFreeBusyStatus"]]
        start=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        subject=None,  # type: Optional[str]
        transaction_id=None,  # type: Optional[str]
        type=None,  # type: Optional[Union[str, "models.MicrosoftGraphEventType"]]
        web_link=None,  # type: Optional[str]
        attachments=None,  # type: Optional[List["models.MicrosoftGraphAttachment"]]
        calendar=None,  # type: Optional["models.MicrosoftGraphCalendar"]
        extensions=None,  # type: Optional[List["models.MicrosoftGraphExtension"]]
        instances=None,  # type: Optional[List["models.MicrosoftGraphEvent"]]
        multi_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]]
        single_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]]
        pattern=None,  # type: Optional["models.MicrosoftGraphRecurrencePattern"]
        range=None,  # type: Optional["models.MicrosoftGraphRecurrenceRange"]
        email_address=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        conference_id=None,  # type: Optional[str]
        join_url=None,  # type: Optional[str]
        phones=None,  # type: Optional[List["models.MicrosoftGraphPhone"]]
        quick_dial=None,  # type: Optional[str]
        toll_free_numbers=None,  # type: Optional[List[str]]
        toll_number=None,  # type: Optional[str]
        address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        coordinates=None,  # type: Optional["models.MicrosoftGraphOutlookGeoCoordinates"]
        display_name=None,  # type: Optional[str]
        location_email_address=None,  # type: Optional[str]
        location_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationType"]]
        location_uri=None,  # type: Optional[str]
        unique_id=None,  # type: Optional[str]
        unique_id_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationUniqueIdType"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property calendarView in groups.

        Update the navigation property calendarView in groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param event_id1: key: id of event.
        :type event_id1: str
        :param id: Read-only.
        :type id: str
        :param categories: The categories associated with the item.
        :type categories: list[str]
        :param change_key: Identifies the version of the item. Every time the item is changed,
         changeKey changes as well. This allows Exchange to apply changes to the correct version of the
         object. Read-only.
        :type change_key: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param allow_new_time_proposals: True if the meeting organizer allows invitees to propose a new
         time when responding, false otherwise. Optional. Default is true.
        :type allow_new_time_proposals: bool
        :param attendees: The collection of attendees for the event.
        :type attendees: list[~calendar.models.MicrosoftGraphAttendee]
        :param body: itemBody.
        :type body: ~calendar.models.MicrosoftGraphItemBody
        :param body_preview: The preview of the message associated with the event. It is in text
         format.
        :type body_preview: str
        :param end: dateTimeTimeZone.
        :type end: ~calendar.models.MicrosoftGraphDateTimeZone
        :param has_attachments: Set to true if the event has attachments.
        :type has_attachments: bool
        :param i_cal_u_id: A unique identifier that is shared by all instances of an event across
         different calendars. Read-only.
        :type i_cal_u_id: str
        :param importance:
        :type importance: str or ~calendar.models.MicrosoftGraphImportance
        :param is_all_day: Set to true if the event lasts all day.
        :type is_all_day: bool
        :param is_cancelled: Set to true if the event has been canceled.
        :type is_cancelled: bool
        :param is_online_meeting: True if this event has online meeting information, false otherwise.
         Default is false. Optional.
        :type is_online_meeting: bool
        :param is_organizer: Set to true if the calendar owner (specified by the owner property of the
         calendar) is the organizer of the event (specified by the organizer property of the event).
         This also applies if a delegate organized the event on behalf of the owner.
        :type is_organizer: bool
        :param is_reminder_on: Set to true if an alert is set to remind the user of the event.
        :type is_reminder_on: bool
        :param locations: The locations where the event is held or attended from. The location and
         locations properties always correspond with each other. If you update the location property,
         any prior locations in the locations collection would be removed and replaced by the new
         location value.
        :type locations: list[~calendar.models.MicrosoftGraphLocation]
        :param online_meeting_provider:
        :type online_meeting_provider: str or ~calendar.models.MicrosoftGraphOnlineMeetingProviderType
        :param online_meeting_url: A URL for an online meeting. The property is set only when an
         organizer specifies an event as an online meeting such as a Skype meeting. Read-only.
        :type online_meeting_url: str
        :param original_end_time_zone: The end time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_end_time_zone: str
        :param original_start: The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type original_start: ~datetime.datetime
        :param original_start_time_zone: The start time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_start_time_zone: str
        :param reminder_minutes_before_start: The number of minutes before the event start time that
         the reminder alert occurs.
        :type reminder_minutes_before_start: int
        :param response_requested: Default is true, which represents the organizer would like an
         invitee to send a response to the event.
        :type response_requested: bool
        :param response_status: responseStatus.
        :type response_status: ~calendar.models.MicrosoftGraphResponseStatus
        :param sensitivity:
        :type sensitivity: str or ~calendar.models.MicrosoftGraphSensitivity
        :param series_master_id: The ID for the recurring series master item, if this event is part of
         a recurring series.
        :type series_master_id: str
        :param show_as:
        :type show_as: str or ~calendar.models.MicrosoftGraphFreeBusyStatus
        :param start: dateTimeTimeZone.
        :type start: ~calendar.models.MicrosoftGraphDateTimeZone
        :param subject: The text of the event's subject line.
        :type subject: str
        :param transaction_id: A custom identifier specified by a client app for the server to avoid
         redundant POST operations in case of client retries to create the same event. This is useful
         when low network connectivity causes the client to time out before receiving a response from
         the server for the client's prior create-event request. After you set transactionId when
         creating an event, you cannot change transactionId in a subsequent update. This property is
         only returned in a response payload if an app has set it. Optional.
        :type transaction_id: str
        :param type:
        :type type: str or ~calendar.models.MicrosoftGraphEventType
        :param web_link: The URL to open the event in Outlook on the web.Outlook on the web opens the
         event in the browser if you are signed in to your mailbox. Otherwise, Outlook on the web
         prompts you to sign in.This URL can be accessed from within an iFrame.
        :type web_link: str
        :param attachments: The collection of fileAttachment and itemAttachment attachments for the
         event. Navigation property. Read-only. Nullable.
        :type attachments: list[~calendar.models.MicrosoftGraphAttachment]
        :param calendar: calendar.
        :type calendar: ~calendar.models.MicrosoftGraphCalendar
        :param extensions: The collection of open extensions defined for the event. Read-only.
         Nullable.
        :type extensions: list[~calendar.models.MicrosoftGraphExtension]
        :param instances: The instances of the event. Navigation property. Read-only. Nullable.
        :type instances: list[~calendar.models.MicrosoftGraphEvent]
        :param multi_value_extended_properties: The collection of multi-value extended properties
         defined for the event. Read-only. Nullable.
        :type multi_value_extended_properties: list[~calendar.models.MicrosoftGraphMultiValueLegacyExtendedProperty]
        :param single_value_extended_properties: The collection of single-value extended properties
         defined for the event. Read-only. Nullable.
        :type single_value_extended_properties: list[~calendar.models.MicrosoftGraphSingleValueLegacyExtendedProperty]
        :param pattern: recurrencePattern.
        :type pattern: ~calendar.models.MicrosoftGraphRecurrencePattern
        :param range: recurrenceRange.
        :type range: ~calendar.models.MicrosoftGraphRecurrenceRange
        :param email_address: emailAddress.
        :type email_address: ~calendar.models.MicrosoftGraphEmailAddress
        :param conference_id: The ID of the conference.
        :type conference_id: str
        :param join_url: The external link that launches the online meeting. This is a URL that clients
         will launch into a browser and will redirect the user to join the meeting.
        :type join_url: str
        :param phones: All of the phone numbers associated with this conference.
        :type phones: list[~calendar.models.MicrosoftGraphPhone]
        :param quick_dial: The pre-formatted quickdial for this call.
        :type quick_dial: str
        :param toll_free_numbers: The toll free numbers that can be used to join the conference.
        :type toll_free_numbers: list[str]
        :param toll_number: The toll number that can be used to join the conference.
        :type toll_number: str
        :param address: physicalAddress.
        :type address: ~calendar.models.MicrosoftGraphPhysicalAddress
        :param coordinates: outlookGeoCoordinates.
        :type coordinates: ~calendar.models.MicrosoftGraphOutlookGeoCoordinates
        :param display_name: The name associated with the location.
        :type display_name: str
        :param location_email_address: Optional email address of the location.
        :type location_email_address: str
        :param location_type:
        :type location_type: str or ~calendar.models.MicrosoftGraphLocationType
        :param location_uri: Optional URI representing the location.
        :type location_uri: str
        :param unique_id: For internal use only.
        :type unique_id: str
        :param unique_id_type:
        :type unique_id_type: str or ~calendar.models.MicrosoftGraphLocationUniqueIdType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEvent(id=id, categories=categories, change_key=change_key, created_date_time=created_date_time, last_modified_date_time=last_modified_date_time, allow_new_time_proposals=allow_new_time_proposals, attendees=attendees, body=body, body_preview=body_preview, end=end, has_attachments=has_attachments, i_cal_u_id=i_cal_u_id, importance=importance, is_all_day=is_all_day, is_cancelled=is_cancelled, is_online_meeting=is_online_meeting, is_organizer=is_organizer, is_reminder_on=is_reminder_on, locations=locations, online_meeting_provider=online_meeting_provider, online_meeting_url=online_meeting_url, original_end_time_zone=original_end_time_zone, original_start=original_start, original_start_time_zone=original_start_time_zone, reminder_minutes_before_start=reminder_minutes_before_start, response_requested=response_requested, response_status=response_status, sensitivity=sensitivity, series_master_id=series_master_id, show_as=show_as, start=start, subject=subject, transaction_id=transaction_id, type=type, web_link=web_link, attachments=attachments, calendar=calendar, extensions=extensions, instances=instances, multi_value_extended_properties=multi_value_extended_properties, single_value_extended_properties=single_value_extended_properties, pattern=pattern, range=range, email_address=email_address, conference_id=conference_id, join_url=join_url, phones=phones, quick_dial=quick_dial, toll_free_numbers=toll_free_numbers, toll_number=toll_number, address=address, coordinates=coordinates, display_name=display_name, location_email_address=location_email_address, location_type=location_type, location_uri=location_uri, unique_id=unique_id, unique_id_type=unique_id_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_calendar_view.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'event-id1': self._serialize.url("event_id1", event_id1, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEvent')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_calendar_view.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}'}  # type: ignore

    def delete_calendar_view(
        self,
        group_id,  # type: str
        event_id,  # type: str
        event_id1,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property calendarView for groups.

        Delete navigation property calendarView for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param event_id1: key: id of event.
        :type event_id1: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_calendar_view.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'event-id1': self._serialize.url("event_id1", event_id1, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_calendar_view.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/calendarView/{event-id1}'}  # type: ignore

    def list_event(
        self,
        group_id,  # type: str
        event_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum90"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum91"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum92"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfEvent5"]
        """Get events from groups.

        Get events from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~calendar.models.Enum90]
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum91]
        :param expand: Expand related entities.
        :type expand: list[str or ~calendar.models.Enum92]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEvent5 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~calendar.models.CollectionOfEvent5]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEvent5"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_event.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'event-id': self._serialize.url("event_id", event_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEvent5', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_event.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/events'}  # type: ignore

    def create_event(
        self,
        group_id,  # type: str
        event_id,  # type: str
        id=None,  # type: Optional[str]
        categories=None,  # type: Optional[List[str]]
        change_key=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        allow_new_time_proposals=None,  # type: Optional[bool]
        attendees=None,  # type: Optional[List["models.MicrosoftGraphAttendee"]]
        body=None,  # type: Optional["models.MicrosoftGraphItemBody"]
        body_preview=None,  # type: Optional[str]
        end=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        has_attachments=None,  # type: Optional[bool]
        i_cal_u_id=None,  # type: Optional[str]
        importance=None,  # type: Optional[Union[str, "models.MicrosoftGraphImportance"]]
        is_all_day=None,  # type: Optional[bool]
        is_cancelled=None,  # type: Optional[bool]
        is_online_meeting=None,  # type: Optional[bool]
        is_organizer=None,  # type: Optional[bool]
        is_reminder_on=None,  # type: Optional[bool]
        locations=None,  # type: Optional[List["models.MicrosoftGraphLocation"]]
        online_meeting_provider=None,  # type: Optional[Union[str, "models.MicrosoftGraphOnlineMeetingProviderType"]]
        online_meeting_url=None,  # type: Optional[str]
        original_end_time_zone=None,  # type: Optional[str]
        original_start=None,  # type: Optional[datetime.datetime]
        original_start_time_zone=None,  # type: Optional[str]
        reminder_minutes_before_start=None,  # type: Optional[int]
        response_requested=None,  # type: Optional[bool]
        response_status=None,  # type: Optional["models.MicrosoftGraphResponseStatus"]
        sensitivity=None,  # type: Optional[Union[str, "models.MicrosoftGraphSensitivity"]]
        series_master_id=None,  # type: Optional[str]
        show_as=None,  # type: Optional[Union[str, "models.MicrosoftGraphFreeBusyStatus"]]
        start=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        subject=None,  # type: Optional[str]
        transaction_id=None,  # type: Optional[str]
        type=None,  # type: Optional[Union[str, "models.MicrosoftGraphEventType"]]
        web_link=None,  # type: Optional[str]
        attachments=None,  # type: Optional[List["models.MicrosoftGraphAttachment"]]
        calendar=None,  # type: Optional["models.MicrosoftGraphCalendar"]
        extensions=None,  # type: Optional[List["models.MicrosoftGraphExtension"]]
        instances=None,  # type: Optional[List["models.MicrosoftGraphEvent"]]
        multi_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]]
        single_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]]
        pattern=None,  # type: Optional["models.MicrosoftGraphRecurrencePattern"]
        range=None,  # type: Optional["models.MicrosoftGraphRecurrenceRange"]
        email_address=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        conference_id=None,  # type: Optional[str]
        join_url=None,  # type: Optional[str]
        phones=None,  # type: Optional[List["models.MicrosoftGraphPhone"]]
        quick_dial=None,  # type: Optional[str]
        toll_free_numbers=None,  # type: Optional[List[str]]
        toll_number=None,  # type: Optional[str]
        address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        coordinates=None,  # type: Optional["models.MicrosoftGraphOutlookGeoCoordinates"]
        display_name=None,  # type: Optional[str]
        location_email_address=None,  # type: Optional[str]
        location_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationType"]]
        location_uri=None,  # type: Optional[str]
        unique_id=None,  # type: Optional[str]
        unique_id_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationUniqueIdType"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEvent"
        """Create new navigation property to events for groups.

        Create new navigation property to events for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param id: Read-only.
        :type id: str
        :param categories: The categories associated with the item.
        :type categories: list[str]
        :param change_key: Identifies the version of the item. Every time the item is changed,
         changeKey changes as well. This allows Exchange to apply changes to the correct version of the
         object. Read-only.
        :type change_key: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param allow_new_time_proposals: True if the meeting organizer allows invitees to propose a new
         time when responding, false otherwise. Optional. Default is true.
        :type allow_new_time_proposals: bool
        :param attendees: The collection of attendees for the event.
        :type attendees: list[~calendar.models.MicrosoftGraphAttendee]
        :param body: itemBody.
        :type body: ~calendar.models.MicrosoftGraphItemBody
        :param body_preview: The preview of the message associated with the event. It is in text
         format.
        :type body_preview: str
        :param end: dateTimeTimeZone.
        :type end: ~calendar.models.MicrosoftGraphDateTimeZone
        :param has_attachments: Set to true if the event has attachments.
        :type has_attachments: bool
        :param i_cal_u_id: A unique identifier that is shared by all instances of an event across
         different calendars. Read-only.
        :type i_cal_u_id: str
        :param importance:
        :type importance: str or ~calendar.models.MicrosoftGraphImportance
        :param is_all_day: Set to true if the event lasts all day.
        :type is_all_day: bool
        :param is_cancelled: Set to true if the event has been canceled.
        :type is_cancelled: bool
        :param is_online_meeting: True if this event has online meeting information, false otherwise.
         Default is false. Optional.
        :type is_online_meeting: bool
        :param is_organizer: Set to true if the calendar owner (specified by the owner property of the
         calendar) is the organizer of the event (specified by the organizer property of the event).
         This also applies if a delegate organized the event on behalf of the owner.
        :type is_organizer: bool
        :param is_reminder_on: Set to true if an alert is set to remind the user of the event.
        :type is_reminder_on: bool
        :param locations: The locations where the event is held or attended from. The location and
         locations properties always correspond with each other. If you update the location property,
         any prior locations in the locations collection would be removed and replaced by the new
         location value.
        :type locations: list[~calendar.models.MicrosoftGraphLocation]
        :param online_meeting_provider:
        :type online_meeting_provider: str or ~calendar.models.MicrosoftGraphOnlineMeetingProviderType
        :param online_meeting_url: A URL for an online meeting. The property is set only when an
         organizer specifies an event as an online meeting such as a Skype meeting. Read-only.
        :type online_meeting_url: str
        :param original_end_time_zone: The end time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_end_time_zone: str
        :param original_start: The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type original_start: ~datetime.datetime
        :param original_start_time_zone: The start time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_start_time_zone: str
        :param reminder_minutes_before_start: The number of minutes before the event start time that
         the reminder alert occurs.
        :type reminder_minutes_before_start: int
        :param response_requested: Default is true, which represents the organizer would like an
         invitee to send a response to the event.
        :type response_requested: bool
        :param response_status: responseStatus.
        :type response_status: ~calendar.models.MicrosoftGraphResponseStatus
        :param sensitivity:
        :type sensitivity: str or ~calendar.models.MicrosoftGraphSensitivity
        :param series_master_id: The ID for the recurring series master item, if this event is part of
         a recurring series.
        :type series_master_id: str
        :param show_as:
        :type show_as: str or ~calendar.models.MicrosoftGraphFreeBusyStatus
        :param start: dateTimeTimeZone.
        :type start: ~calendar.models.MicrosoftGraphDateTimeZone
        :param subject: The text of the event's subject line.
        :type subject: str
        :param transaction_id: A custom identifier specified by a client app for the server to avoid
         redundant POST operations in case of client retries to create the same event. This is useful
         when low network connectivity causes the client to time out before receiving a response from
         the server for the client's prior create-event request. After you set transactionId when
         creating an event, you cannot change transactionId in a subsequent update. This property is
         only returned in a response payload if an app has set it. Optional.
        :type transaction_id: str
        :param type:
        :type type: str or ~calendar.models.MicrosoftGraphEventType
        :param web_link: The URL to open the event in Outlook on the web.Outlook on the web opens the
         event in the browser if you are signed in to your mailbox. Otherwise, Outlook on the web
         prompts you to sign in.This URL can be accessed from within an iFrame.
        :type web_link: str
        :param attachments: The collection of fileAttachment and itemAttachment attachments for the
         event. Navigation property. Read-only. Nullable.
        :type attachments: list[~calendar.models.MicrosoftGraphAttachment]
        :param calendar: calendar.
        :type calendar: ~calendar.models.MicrosoftGraphCalendar
        :param extensions: The collection of open extensions defined for the event. Read-only.
         Nullable.
        :type extensions: list[~calendar.models.MicrosoftGraphExtension]
        :param instances: The instances of the event. Navigation property. Read-only. Nullable.
        :type instances: list[~calendar.models.MicrosoftGraphEvent]
        :param multi_value_extended_properties: The collection of multi-value extended properties
         defined for the event. Read-only. Nullable.
        :type multi_value_extended_properties: list[~calendar.models.MicrosoftGraphMultiValueLegacyExtendedProperty]
        :param single_value_extended_properties: The collection of single-value extended properties
         defined for the event. Read-only. Nullable.
        :type single_value_extended_properties: list[~calendar.models.MicrosoftGraphSingleValueLegacyExtendedProperty]
        :param pattern: recurrencePattern.
        :type pattern: ~calendar.models.MicrosoftGraphRecurrencePattern
        :param range: recurrenceRange.
        :type range: ~calendar.models.MicrosoftGraphRecurrenceRange
        :param email_address: emailAddress.
        :type email_address: ~calendar.models.MicrosoftGraphEmailAddress
        :param conference_id: The ID of the conference.
        :type conference_id: str
        :param join_url: The external link that launches the online meeting. This is a URL that clients
         will launch into a browser and will redirect the user to join the meeting.
        :type join_url: str
        :param phones: All of the phone numbers associated with this conference.
        :type phones: list[~calendar.models.MicrosoftGraphPhone]
        :param quick_dial: The pre-formatted quickdial for this call.
        :type quick_dial: str
        :param toll_free_numbers: The toll free numbers that can be used to join the conference.
        :type toll_free_numbers: list[str]
        :param toll_number: The toll number that can be used to join the conference.
        :type toll_number: str
        :param address: physicalAddress.
        :type address: ~calendar.models.MicrosoftGraphPhysicalAddress
        :param coordinates: outlookGeoCoordinates.
        :type coordinates: ~calendar.models.MicrosoftGraphOutlookGeoCoordinates
        :param display_name: The name associated with the location.
        :type display_name: str
        :param location_email_address: Optional email address of the location.
        :type location_email_address: str
        :param location_type:
        :type location_type: str or ~calendar.models.MicrosoftGraphLocationType
        :param location_uri: Optional URI representing the location.
        :type location_uri: str
        :param unique_id: For internal use only.
        :type unique_id: str
        :param unique_id_type:
        :type unique_id_type: str or ~calendar.models.MicrosoftGraphLocationUniqueIdType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEvent, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphEvent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEvent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEvent(id=id, categories=categories, change_key=change_key, created_date_time=created_date_time, last_modified_date_time=last_modified_date_time, allow_new_time_proposals=allow_new_time_proposals, attendees=attendees, body=body, body_preview=body_preview, end=end, has_attachments=has_attachments, i_cal_u_id=i_cal_u_id, importance=importance, is_all_day=is_all_day, is_cancelled=is_cancelled, is_online_meeting=is_online_meeting, is_organizer=is_organizer, is_reminder_on=is_reminder_on, locations=locations, online_meeting_provider=online_meeting_provider, online_meeting_url=online_meeting_url, original_end_time_zone=original_end_time_zone, original_start=original_start, original_start_time_zone=original_start_time_zone, reminder_minutes_before_start=reminder_minutes_before_start, response_requested=response_requested, response_status=response_status, sensitivity=sensitivity, series_master_id=series_master_id, show_as=show_as, start=start, subject=subject, transaction_id=transaction_id, type=type, web_link=web_link, attachments=attachments, calendar=calendar, extensions=extensions, instances=instances, multi_value_extended_properties=multi_value_extended_properties, single_value_extended_properties=single_value_extended_properties, pattern=pattern, range=range, email_address=email_address, conference_id=conference_id, join_url=join_url, phones=phones, quick_dial=quick_dial, toll_free_numbers=toll_free_numbers, toll_number=toll_number, address=address, coordinates=coordinates, display_name=display_name, location_email_address=location_email_address, location_type=location_type, location_uri=location_uri, unique_id=unique_id, unique_id_type=unique_id_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEvent')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEvent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_event.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/events'}  # type: ignore

    def get_event(
        self,
        group_id,  # type: str
        event_id,  # type: str
        event_id1,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum93"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum94"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEvent"
        """Get events from groups.

        Get events from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param event_id1: key: id of event.
        :type event_id1: str
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum93]
        :param expand: Expand related entities.
        :type expand: list[str or ~calendar.models.Enum94]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEvent, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphEvent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEvent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'event-id1': self._serialize.url("event_id1", event_id1, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEvent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_event.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}'}  # type: ignore

    def update_event(
        self,
        group_id,  # type: str
        event_id,  # type: str
        event_id1,  # type: str
        id=None,  # type: Optional[str]
        categories=None,  # type: Optional[List[str]]
        change_key=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        allow_new_time_proposals=None,  # type: Optional[bool]
        attendees=None,  # type: Optional[List["models.MicrosoftGraphAttendee"]]
        body=None,  # type: Optional["models.MicrosoftGraphItemBody"]
        body_preview=None,  # type: Optional[str]
        end=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        has_attachments=None,  # type: Optional[bool]
        i_cal_u_id=None,  # type: Optional[str]
        importance=None,  # type: Optional[Union[str, "models.MicrosoftGraphImportance"]]
        is_all_day=None,  # type: Optional[bool]
        is_cancelled=None,  # type: Optional[bool]
        is_online_meeting=None,  # type: Optional[bool]
        is_organizer=None,  # type: Optional[bool]
        is_reminder_on=None,  # type: Optional[bool]
        locations=None,  # type: Optional[List["models.MicrosoftGraphLocation"]]
        online_meeting_provider=None,  # type: Optional[Union[str, "models.MicrosoftGraphOnlineMeetingProviderType"]]
        online_meeting_url=None,  # type: Optional[str]
        original_end_time_zone=None,  # type: Optional[str]
        original_start=None,  # type: Optional[datetime.datetime]
        original_start_time_zone=None,  # type: Optional[str]
        reminder_minutes_before_start=None,  # type: Optional[int]
        response_requested=None,  # type: Optional[bool]
        response_status=None,  # type: Optional["models.MicrosoftGraphResponseStatus"]
        sensitivity=None,  # type: Optional[Union[str, "models.MicrosoftGraphSensitivity"]]
        series_master_id=None,  # type: Optional[str]
        show_as=None,  # type: Optional[Union[str, "models.MicrosoftGraphFreeBusyStatus"]]
        start=None,  # type: Optional["models.MicrosoftGraphDateTimeZone"]
        subject=None,  # type: Optional[str]
        transaction_id=None,  # type: Optional[str]
        type=None,  # type: Optional[Union[str, "models.MicrosoftGraphEventType"]]
        web_link=None,  # type: Optional[str]
        attachments=None,  # type: Optional[List["models.MicrosoftGraphAttachment"]]
        calendar=None,  # type: Optional["models.MicrosoftGraphCalendar"]
        extensions=None,  # type: Optional[List["models.MicrosoftGraphExtension"]]
        instances=None,  # type: Optional[List["models.MicrosoftGraphEvent"]]
        multi_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]]
        single_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]]
        pattern=None,  # type: Optional["models.MicrosoftGraphRecurrencePattern"]
        range=None,  # type: Optional["models.MicrosoftGraphRecurrenceRange"]
        email_address=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        conference_id=None,  # type: Optional[str]
        join_url=None,  # type: Optional[str]
        phones=None,  # type: Optional[List["models.MicrosoftGraphPhone"]]
        quick_dial=None,  # type: Optional[str]
        toll_free_numbers=None,  # type: Optional[List[str]]
        toll_number=None,  # type: Optional[str]
        address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        coordinates=None,  # type: Optional["models.MicrosoftGraphOutlookGeoCoordinates"]
        display_name=None,  # type: Optional[str]
        location_email_address=None,  # type: Optional[str]
        location_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationType"]]
        location_uri=None,  # type: Optional[str]
        unique_id=None,  # type: Optional[str]
        unique_id_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphLocationUniqueIdType"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property events in groups.

        Update the navigation property events in groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param event_id1: key: id of event.
        :type event_id1: str
        :param id: Read-only.
        :type id: str
        :param categories: The categories associated with the item.
        :type categories: list[str]
        :param change_key: Identifies the version of the item. Every time the item is changed,
         changeKey changes as well. This allows Exchange to apply changes to the correct version of the
         object. Read-only.
        :type change_key: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param allow_new_time_proposals: True if the meeting organizer allows invitees to propose a new
         time when responding, false otherwise. Optional. Default is true.
        :type allow_new_time_proposals: bool
        :param attendees: The collection of attendees for the event.
        :type attendees: list[~calendar.models.MicrosoftGraphAttendee]
        :param body: itemBody.
        :type body: ~calendar.models.MicrosoftGraphItemBody
        :param body_preview: The preview of the message associated with the event. It is in text
         format.
        :type body_preview: str
        :param end: dateTimeTimeZone.
        :type end: ~calendar.models.MicrosoftGraphDateTimeZone
        :param has_attachments: Set to true if the event has attachments.
        :type has_attachments: bool
        :param i_cal_u_id: A unique identifier that is shared by all instances of an event across
         different calendars. Read-only.
        :type i_cal_u_id: str
        :param importance:
        :type importance: str or ~calendar.models.MicrosoftGraphImportance
        :param is_all_day: Set to true if the event lasts all day.
        :type is_all_day: bool
        :param is_cancelled: Set to true if the event has been canceled.
        :type is_cancelled: bool
        :param is_online_meeting: True if this event has online meeting information, false otherwise.
         Default is false. Optional.
        :type is_online_meeting: bool
        :param is_organizer: Set to true if the calendar owner (specified by the owner property of the
         calendar) is the organizer of the event (specified by the organizer property of the event).
         This also applies if a delegate organized the event on behalf of the owner.
        :type is_organizer: bool
        :param is_reminder_on: Set to true if an alert is set to remind the user of the event.
        :type is_reminder_on: bool
        :param locations: The locations where the event is held or attended from. The location and
         locations properties always correspond with each other. If you update the location property,
         any prior locations in the locations collection would be removed and replaced by the new
         location value.
        :type locations: list[~calendar.models.MicrosoftGraphLocation]
        :param online_meeting_provider:
        :type online_meeting_provider: str or ~calendar.models.MicrosoftGraphOnlineMeetingProviderType
        :param online_meeting_url: A URL for an online meeting. The property is set only when an
         organizer specifies an event as an online meeting such as a Skype meeting. Read-only.
        :type online_meeting_url: str
        :param original_end_time_zone: The end time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_end_time_zone: str
        :param original_start: The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type original_start: ~datetime.datetime
        :param original_start_time_zone: The start time zone that was set when the event was created. A
         value of tzone://Microsoft/Custom indicates that a legacy custom time zone was set in desktop
         Outlook.
        :type original_start_time_zone: str
        :param reminder_minutes_before_start: The number of minutes before the event start time that
         the reminder alert occurs.
        :type reminder_minutes_before_start: int
        :param response_requested: Default is true, which represents the organizer would like an
         invitee to send a response to the event.
        :type response_requested: bool
        :param response_status: responseStatus.
        :type response_status: ~calendar.models.MicrosoftGraphResponseStatus
        :param sensitivity:
        :type sensitivity: str or ~calendar.models.MicrosoftGraphSensitivity
        :param series_master_id: The ID for the recurring series master item, if this event is part of
         a recurring series.
        :type series_master_id: str
        :param show_as:
        :type show_as: str or ~calendar.models.MicrosoftGraphFreeBusyStatus
        :param start: dateTimeTimeZone.
        :type start: ~calendar.models.MicrosoftGraphDateTimeZone
        :param subject: The text of the event's subject line.
        :type subject: str
        :param transaction_id: A custom identifier specified by a client app for the server to avoid
         redundant POST operations in case of client retries to create the same event. This is useful
         when low network connectivity causes the client to time out before receiving a response from
         the server for the client's prior create-event request. After you set transactionId when
         creating an event, you cannot change transactionId in a subsequent update. This property is
         only returned in a response payload if an app has set it. Optional.
        :type transaction_id: str
        :param type:
        :type type: str or ~calendar.models.MicrosoftGraphEventType
        :param web_link: The URL to open the event in Outlook on the web.Outlook on the web opens the
         event in the browser if you are signed in to your mailbox. Otherwise, Outlook on the web
         prompts you to sign in.This URL can be accessed from within an iFrame.
        :type web_link: str
        :param attachments: The collection of fileAttachment and itemAttachment attachments for the
         event. Navigation property. Read-only. Nullable.
        :type attachments: list[~calendar.models.MicrosoftGraphAttachment]
        :param calendar: calendar.
        :type calendar: ~calendar.models.MicrosoftGraphCalendar
        :param extensions: The collection of open extensions defined for the event. Read-only.
         Nullable.
        :type extensions: list[~calendar.models.MicrosoftGraphExtension]
        :param instances: The instances of the event. Navigation property. Read-only. Nullable.
        :type instances: list[~calendar.models.MicrosoftGraphEvent]
        :param multi_value_extended_properties: The collection of multi-value extended properties
         defined for the event. Read-only. Nullable.
        :type multi_value_extended_properties: list[~calendar.models.MicrosoftGraphMultiValueLegacyExtendedProperty]
        :param single_value_extended_properties: The collection of single-value extended properties
         defined for the event. Read-only. Nullable.
        :type single_value_extended_properties: list[~calendar.models.MicrosoftGraphSingleValueLegacyExtendedProperty]
        :param pattern: recurrencePattern.
        :type pattern: ~calendar.models.MicrosoftGraphRecurrencePattern
        :param range: recurrenceRange.
        :type range: ~calendar.models.MicrosoftGraphRecurrenceRange
        :param email_address: emailAddress.
        :type email_address: ~calendar.models.MicrosoftGraphEmailAddress
        :param conference_id: The ID of the conference.
        :type conference_id: str
        :param join_url: The external link that launches the online meeting. This is a URL that clients
         will launch into a browser and will redirect the user to join the meeting.
        :type join_url: str
        :param phones: All of the phone numbers associated with this conference.
        :type phones: list[~calendar.models.MicrosoftGraphPhone]
        :param quick_dial: The pre-formatted quickdial for this call.
        :type quick_dial: str
        :param toll_free_numbers: The toll free numbers that can be used to join the conference.
        :type toll_free_numbers: list[str]
        :param toll_number: The toll number that can be used to join the conference.
        :type toll_number: str
        :param address: physicalAddress.
        :type address: ~calendar.models.MicrosoftGraphPhysicalAddress
        :param coordinates: outlookGeoCoordinates.
        :type coordinates: ~calendar.models.MicrosoftGraphOutlookGeoCoordinates
        :param display_name: The name associated with the location.
        :type display_name: str
        :param location_email_address: Optional email address of the location.
        :type location_email_address: str
        :param location_type:
        :type location_type: str or ~calendar.models.MicrosoftGraphLocationType
        :param location_uri: Optional URI representing the location.
        :type location_uri: str
        :param unique_id: For internal use only.
        :type unique_id: str
        :param unique_id_type:
        :type unique_id_type: str or ~calendar.models.MicrosoftGraphLocationUniqueIdType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEvent(id=id, categories=categories, change_key=change_key, created_date_time=created_date_time, last_modified_date_time=last_modified_date_time, allow_new_time_proposals=allow_new_time_proposals, attendees=attendees, body=body, body_preview=body_preview, end=end, has_attachments=has_attachments, i_cal_u_id=i_cal_u_id, importance=importance, is_all_day=is_all_day, is_cancelled=is_cancelled, is_online_meeting=is_online_meeting, is_organizer=is_organizer, is_reminder_on=is_reminder_on, locations=locations, online_meeting_provider=online_meeting_provider, online_meeting_url=online_meeting_url, original_end_time_zone=original_end_time_zone, original_start=original_start, original_start_time_zone=original_start_time_zone, reminder_minutes_before_start=reminder_minutes_before_start, response_requested=response_requested, response_status=response_status, sensitivity=sensitivity, series_master_id=series_master_id, show_as=show_as, start=start, subject=subject, transaction_id=transaction_id, type=type, web_link=web_link, attachments=attachments, calendar=calendar, extensions=extensions, instances=instances, multi_value_extended_properties=multi_value_extended_properties, single_value_extended_properties=single_value_extended_properties, pattern=pattern, range=range, email_address=email_address, conference_id=conference_id, join_url=join_url, phones=phones, quick_dial=quick_dial, toll_free_numbers=toll_free_numbers, toll_number=toll_number, address=address, coordinates=coordinates, display_name=display_name, location_email_address=location_email_address, location_type=location_type, location_uri=location_uri, unique_id=unique_id, unique_id_type=unique_id_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'event-id1': self._serialize.url("event_id1", event_id1, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEvent')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_event.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}'}  # type: ignore

    def delete_event(
        self,
        group_id,  # type: str
        event_id,  # type: str
        event_id1,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property events for groups.

        Delete navigation property events for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param event_id1: key: id of event.
        :type event_id1: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_event.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'event-id1': self._serialize.url("event_id1", event_id1, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_event.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/events/{event-id1}'}  # type: ignore

    def list_multi_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum95"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum96"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfMultiValueLegacyExtendedProperty2"]
        """Get multiValueExtendedProperties from groups.

        Get multiValueExtendedProperties from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~calendar.models.Enum95]
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum96]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfMultiValueLegacyExtendedProperty2 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~calendar.models.CollectionOfMultiValueLegacyExtendedProperty2]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfMultiValueLegacyExtendedProperty2"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_multi_value_extended_property.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'event-id': self._serialize.url("event_id", event_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfMultiValueLegacyExtendedProperty2', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties'}  # type: ignore

    def create_multi_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphMultiValueLegacyExtendedProperty"
        """Create new navigation property to multiValueExtendedProperties for groups.

        Create new navigation property to multiValueExtendedProperties for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param id: Read-only.
        :type id: str
        :param value: A collection of property values.
        :type value: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMultiValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphMultiValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphMultiValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphMultiValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMultiValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties'}  # type: ignore

    def get_multi_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        multi_value_legacy_extended_property_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum97"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphMultiValueLegacyExtendedProperty"
        """Get multiValueExtendedProperties from groups.

        Get multiValueExtendedProperties from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param multi_value_legacy_extended_property_id: key: id of multiValueLegacyExtendedProperty.
        :type multi_value_legacy_extended_property_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum97]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMultiValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphMultiValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'multiValueLegacyExtendedProperty-id': self._serialize.url("multi_value_legacy_extended_property_id", multi_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMultiValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}'}  # type: ignore

    def update_multi_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        multi_value_legacy_extended_property_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property multiValueExtendedProperties in groups.

        Update the navigation property multiValueExtendedProperties in groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param multi_value_legacy_extended_property_id: key: id of multiValueLegacyExtendedProperty.
        :type multi_value_legacy_extended_property_id: str
        :param id: Read-only.
        :type id: str
        :param value: A collection of property values.
        :type value: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphMultiValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'multiValueLegacyExtendedProperty-id': self._serialize.url("multi_value_legacy_extended_property_id", multi_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphMultiValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}'}  # type: ignore

    def delete_multi_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        multi_value_legacy_extended_property_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property multiValueExtendedProperties for groups.

        Delete navigation property multiValueExtendedProperties for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param multi_value_legacy_extended_property_id: key: id of multiValueLegacyExtendedProperty.
        :type multi_value_legacy_extended_property_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'multiValueLegacyExtendedProperty-id': self._serialize.url("multi_value_legacy_extended_property_id", multi_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}'}  # type: ignore

    def list_single_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum98"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum99"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfSingleValueLegacyExtendedProperty2"]
        """Get singleValueExtendedProperties from groups.

        Get singleValueExtendedProperties from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~calendar.models.Enum98]
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum99]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSingleValueLegacyExtendedProperty2 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~calendar.models.CollectionOfSingleValueLegacyExtendedProperty2]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSingleValueLegacyExtendedProperty2"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_single_value_extended_property.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'event-id': self._serialize.url("event_id", event_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSingleValueLegacyExtendedProperty2', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_single_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties'}  # type: ignore

    def create_single_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphSingleValueLegacyExtendedProperty"
        """Create new navigation property to singleValueExtendedProperties for groups.

        Create new navigation property to singleValueExtendedProperties for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param id: Read-only.
        :type id: str
        :param value: A property value.
        :type value: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSingleValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphSingleValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSingleValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSingleValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSingleValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_single_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties'}  # type: ignore

    def get_single_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        single_value_legacy_extended_property_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum100"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphSingleValueLegacyExtendedProperty"
        """Get singleValueExtendedProperties from groups.

        Get singleValueExtendedProperties from groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param single_value_legacy_extended_property_id: key: id of singleValueLegacyExtendedProperty.
        :type single_value_legacy_extended_property_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~calendar.models.Enum100]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSingleValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~calendar.models.MicrosoftGraphSingleValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'singleValueLegacyExtendedProperty-id': self._serialize.url("single_value_legacy_extended_property_id", single_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSingleValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_single_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}'}  # type: ignore

    def update_single_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        single_value_legacy_extended_property_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property singleValueExtendedProperties in groups.

        Update the navigation property singleValueExtendedProperties in groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param single_value_legacy_extended_property_id: key: id of singleValueLegacyExtendedProperty.
        :type single_value_legacy_extended_property_id: str
        :param id: Read-only.
        :type id: str
        :param value: A property value.
        :type value: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSingleValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'singleValueLegacyExtendedProperty-id': self._serialize.url("single_value_legacy_extended_property_id", single_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSingleValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_single_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}'}  # type: ignore

    def delete_single_value_extended_property(
        self,
        group_id,  # type: str
        event_id,  # type: str
        single_value_legacy_extended_property_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property singleValueExtendedProperties for groups.

        Delete navigation property singleValueExtendedProperties for groups.

        :param group_id: key: id of group.
        :type group_id: str
        :param event_id: key: id of event.
        :type event_id: str
        :param single_value_legacy_extended_property_id: key: id of singleValueLegacyExtendedProperty.
        :type single_value_legacy_extended_property_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'event-id': self._serialize.url("event_id", event_id, 'str'),
            'singleValueLegacyExtendedProperty-id': self._serialize.url("single_value_legacy_extended_property_id", single_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_single_value_extended_property.metadata = {'url': '/groups/{group-id}/calendarView/{event-id}/calendar/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}'}  # type: ignore
