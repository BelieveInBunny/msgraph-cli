# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class SecurityOperations:
    """SecurityOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~security.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_alert(
        self,
        orderby: Optional[List[Union[str, "models.Get5ItemsItem"]]] = None,
        select: Optional[List[Union[str, "models.Get6ItemsItem"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAlert"]:
        """Get alerts from Security.

        Get alerts from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAlert or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfAlert]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAlert"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_alert.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAlert', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_alert.metadata = {'url': '/Security/alerts'}  # type: ignore

    async def create_alert(
        self,
        id: Optional[str] = None,
        activity_group_name: Optional[str] = None,
        assigned_to: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        category: Optional[str] = None,
        closed_date_time: Optional[datetime.datetime] = None,
        cloud_app_states: Optional[List["models.MicrosoftGraphCloudAppSecurityState"]] = None,
        comments: Optional[List[str]] = None,
        confidence: Optional[int] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        detection_ids: Optional[List[str]] = None,
        event_date_time: Optional[datetime.datetime] = None,
        feedback: Optional[Union[str, "models.MicrosoftGraphAlertFeedback"]] = None,
        file_states: Optional[List["models.MicrosoftGraphFileSecurityState"]] = None,
        history_states: Optional[List["models.MicrosoftGraphAlertHistoryState"]] = None,
        host_states: Optional[List["models.MicrosoftGraphHostSecurityState"]] = None,
        incident_ids: Optional[List[str]] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        malware_states: Optional[List["models.MicrosoftGraphMalwareState"]] = None,
        network_connections: Optional[List["models.MicrosoftGraphNetworkConnection"]] = None,
        processes: Optional[List["models.MicrosoftGraphProcess"]] = None,
        recommended_actions: Optional[List[str]] = None,
        registry_key_states: Optional[List["models.MicrosoftGraphRegistryKeyState"]] = None,
        security_resources: Optional[List["models.MicrosoftGraphSecurityResource"]] = None,
        severity: Optional[Union[str, "models.MicrosoftGraphAlertSeverity"]] = None,
        source_materials: Optional[List[str]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphAlertStatus"]] = None,
        tags: Optional[List[str]] = None,
        title: Optional[str] = None,
        triggers: Optional[List["models.MicrosoftGraphAlertTrigger"]] = None,
        user_states: Optional[List["models.MicrosoftGraphUserSecurityState"]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        vulnerability_states: Optional[List["models.MicrosoftGraphVulnerabilityState"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAlert":
        """Create new navigation property to alerts for Security.

        Create new navigation property to alerts for Security.

        :param id: Read-only.
        :type id: str
        :param activity_group_name: Name or alias of the activity group (attacker) this alert is
         attributed to.
        :type activity_group_name: str
        :param assigned_to: Name of the analyst the alert is assigned to for triage, investigation, or
         remediation (supports update).
        :type assigned_to: str
        :param azure_subscription_id: Azure subscription ID, present if this alert is related to an
         Azure resource.
        :type azure_subscription_id: str
        :param azure_tenant_id: Azure Active Directory tenant ID. Required.
        :type azure_tenant_id: str
        :param category: Category of the alert (for example, credentialTheft, ransomware, etc.).
        :type category: str
        :param closed_date_time: Time at which the alert was closed. The Timestamp type represents date
         and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC
         on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z' (supports update).
        :type closed_date_time: ~datetime.datetime
        :param cloud_app_states: Security-related stateful information generated by the provider about
         the cloud application/s related to this alert.
        :type cloud_app_states: list[~security.models.MicrosoftGraphCloudAppSecurityState]
        :param comments: Customer-provided comments on alert (for customer alert management) (supports
         update).
        :type comments: list[str]
        :param confidence: Confidence of the detection logic (percentage between 1-100).
        :type confidence: int
        :param created_date_time: Time at which the alert was created by the alert provider. The
         Timestamp type represents date and time information using ISO 8601 format and is always in UTC
         time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
         Required.
        :type created_date_time: ~datetime.datetime
        :param description: Alert description.
        :type description: str
        :param detection_ids: Set of alerts related to this alert entity (each alert is pushed to the
         SIEM as a separate record).
        :type detection_ids: list[str]
        :param event_date_time: Time at which the event(s) that served as the trigger(s) to generate
         the alert occurred. The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Required.
        :type event_date_time: ~datetime.datetime
        :param feedback:
        :type feedback: str or ~security.models.MicrosoftGraphAlertFeedback
        :param file_states: Security-related stateful information generated by the provider about the
         file(s) related to this alert.
        :type file_states: list[~security.models.MicrosoftGraphFileSecurityState]
        :param history_states:
        :type history_states: list[~security.models.MicrosoftGraphAlertHistoryState]
        :param host_states: Security-related stateful information generated by the provider about the
         host(s) related to this alert.
        :type host_states: list[~security.models.MicrosoftGraphHostSecurityState]
        :param incident_ids: IDs of incidents related to current alert.
        :type incident_ids: list[str]
        :param last_modified_date_time: Time at which the alert entity was last modified. The Timestamp
         type represents date and time information using ISO 8601 format and is always in UTC time. For
         example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param malware_states: Threat Intelligence pertaining to malware related to this alert.
        :type malware_states: list[~security.models.MicrosoftGraphMalwareState]
        :param network_connections: Security-related stateful information generated by the provider
         about the network connection(s) related to this alert.
        :type network_connections: list[~security.models.MicrosoftGraphNetworkConnection]
        :param processes: Security-related stateful information generated by the provider about the
         process or processes related to this alert.
        :type processes: list[~security.models.MicrosoftGraphProcess]
        :param recommended_actions: Vendor/provider recommended action(s) to take as a result of the
         alert (for example, isolate machine, enforce2FA, reimage host).
        :type recommended_actions: list[str]
        :param registry_key_states: Security-related stateful information generated by the provider
         about the registry keys related to this alert.
        :type registry_key_states: list[~security.models.MicrosoftGraphRegistryKeyState]
        :param security_resources: Resources related to current alert. For example, for some alerts
         this can have the Azure Resource value.
        :type security_resources: list[~security.models.MicrosoftGraphSecurityResource]
        :param severity:
        :type severity: str or ~security.models.MicrosoftGraphAlertSeverity
        :param source_materials: Hyperlinks (URIs) to the source material related to the alert, for
         example, provider's user interface for alerts or log search, etc.
        :type source_materials: list[str]
        :param status:
        :type status: str or ~security.models.MicrosoftGraphAlertStatus
        :param tags: User-definable labels that can be applied to an alert and can serve as filter
         conditions (for example 'HVA', 'SAW', etc.) (supports update).
        :type tags: list[str]
        :param title: Alert title. Required.
        :type title: str
        :param triggers: Security-related information about the specific properties that triggered the
         alert (properties appearing in the alert). Alerts might contain information about multiple
         users, hosts, files, ip addresses. This field indicates which properties triggered the alert
         generation.
        :type triggers: list[~security.models.MicrosoftGraphAlertTrigger]
        :param user_states: Security-related stateful information generated by the provider about the
         user accounts related to this alert.
        :type user_states: list[~security.models.MicrosoftGraphUserSecurityState]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :param vulnerability_states: Threat intelligence pertaining to one or more vulnerabilities
         related to this alert.
        :type vulnerability_states: list[~security.models.MicrosoftGraphVulnerabilityState]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAlert, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphAlert
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAlert"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAlert(id=id, activity_group_name=activity_group_name, assigned_to=assigned_to, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, category=category, closed_date_time=closed_date_time, cloud_app_states=cloud_app_states, comments=comments, confidence=confidence, created_date_time=created_date_time, description=description, detection_ids=detection_ids, event_date_time=event_date_time, feedback=feedback, file_states=file_states, history_states=history_states, host_states=host_states, incident_ids=incident_ids, last_modified_date_time=last_modified_date_time, malware_states=malware_states, network_connections=network_connections, processes=processes, recommended_actions=recommended_actions, registry_key_states=registry_key_states, security_resources=security_resources, severity=severity, source_materials=source_materials, status=status, tags=tags, title=title, triggers=triggers, user_states=user_states, vendor_information=vendor_information, vulnerability_states=vulnerability_states)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_alert.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAlert')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAlert', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_alert.metadata = {'url': '/Security/alerts'}  # type: ignore

    async def get_alert(
        self,
        alert_id: str,
        select: Optional[List[Union[str, "models.Enum19"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAlert":
        """Get alerts from Security.

        Get alerts from Security.

        :param alert_id: key: id of alert.
        :type alert_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum19]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAlert, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphAlert
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAlert"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_alert.metadata['url']  # type: ignore
        path_format_arguments = {
            'alert-id': self._serialize.url("alert_id", alert_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAlert', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_alert.metadata = {'url': '/Security/alerts/{alert-id}'}  # type: ignore

    async def update_alert(
        self,
        alert_id: str,
        id: Optional[str] = None,
        activity_group_name: Optional[str] = None,
        assigned_to: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        category: Optional[str] = None,
        closed_date_time: Optional[datetime.datetime] = None,
        cloud_app_states: Optional[List["models.MicrosoftGraphCloudAppSecurityState"]] = None,
        comments: Optional[List[str]] = None,
        confidence: Optional[int] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        detection_ids: Optional[List[str]] = None,
        event_date_time: Optional[datetime.datetime] = None,
        feedback: Optional[Union[str, "models.MicrosoftGraphAlertFeedback"]] = None,
        file_states: Optional[List["models.MicrosoftGraphFileSecurityState"]] = None,
        history_states: Optional[List["models.MicrosoftGraphAlertHistoryState"]] = None,
        host_states: Optional[List["models.MicrosoftGraphHostSecurityState"]] = None,
        incident_ids: Optional[List[str]] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        malware_states: Optional[List["models.MicrosoftGraphMalwareState"]] = None,
        network_connections: Optional[List["models.MicrosoftGraphNetworkConnection"]] = None,
        processes: Optional[List["models.MicrosoftGraphProcess"]] = None,
        recommended_actions: Optional[List[str]] = None,
        registry_key_states: Optional[List["models.MicrosoftGraphRegistryKeyState"]] = None,
        security_resources: Optional[List["models.MicrosoftGraphSecurityResource"]] = None,
        severity: Optional[Union[str, "models.MicrosoftGraphAlertSeverity"]] = None,
        source_materials: Optional[List[str]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphAlertStatus"]] = None,
        tags: Optional[List[str]] = None,
        title: Optional[str] = None,
        triggers: Optional[List["models.MicrosoftGraphAlertTrigger"]] = None,
        user_states: Optional[List["models.MicrosoftGraphUserSecurityState"]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        vulnerability_states: Optional[List["models.MicrosoftGraphVulnerabilityState"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property alerts in Security.

        Update the navigation property alerts in Security.

        :param alert_id: key: id of alert.
        :type alert_id: str
        :param id: Read-only.
        :type id: str
        :param activity_group_name: Name or alias of the activity group (attacker) this alert is
         attributed to.
        :type activity_group_name: str
        :param assigned_to: Name of the analyst the alert is assigned to for triage, investigation, or
         remediation (supports update).
        :type assigned_to: str
        :param azure_subscription_id: Azure subscription ID, present if this alert is related to an
         Azure resource.
        :type azure_subscription_id: str
        :param azure_tenant_id: Azure Active Directory tenant ID. Required.
        :type azure_tenant_id: str
        :param category: Category of the alert (for example, credentialTheft, ransomware, etc.).
        :type category: str
        :param closed_date_time: Time at which the alert was closed. The Timestamp type represents date
         and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC
         on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z' (supports update).
        :type closed_date_time: ~datetime.datetime
        :param cloud_app_states: Security-related stateful information generated by the provider about
         the cloud application/s related to this alert.
        :type cloud_app_states: list[~security.models.MicrosoftGraphCloudAppSecurityState]
        :param comments: Customer-provided comments on alert (for customer alert management) (supports
         update).
        :type comments: list[str]
        :param confidence: Confidence of the detection logic (percentage between 1-100).
        :type confidence: int
        :param created_date_time: Time at which the alert was created by the alert provider. The
         Timestamp type represents date and time information using ISO 8601 format and is always in UTC
         time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
         Required.
        :type created_date_time: ~datetime.datetime
        :param description: Alert description.
        :type description: str
        :param detection_ids: Set of alerts related to this alert entity (each alert is pushed to the
         SIEM as a separate record).
        :type detection_ids: list[str]
        :param event_date_time: Time at which the event(s) that served as the trigger(s) to generate
         the alert occurred. The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Required.
        :type event_date_time: ~datetime.datetime
        :param feedback:
        :type feedback: str or ~security.models.MicrosoftGraphAlertFeedback
        :param file_states: Security-related stateful information generated by the provider about the
         file(s) related to this alert.
        :type file_states: list[~security.models.MicrosoftGraphFileSecurityState]
        :param history_states:
        :type history_states: list[~security.models.MicrosoftGraphAlertHistoryState]
        :param host_states: Security-related stateful information generated by the provider about the
         host(s) related to this alert.
        :type host_states: list[~security.models.MicrosoftGraphHostSecurityState]
        :param incident_ids: IDs of incidents related to current alert.
        :type incident_ids: list[str]
        :param last_modified_date_time: Time at which the alert entity was last modified. The Timestamp
         type represents date and time information using ISO 8601 format and is always in UTC time. For
         example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param malware_states: Threat Intelligence pertaining to malware related to this alert.
        :type malware_states: list[~security.models.MicrosoftGraphMalwareState]
        :param network_connections: Security-related stateful information generated by the provider
         about the network connection(s) related to this alert.
        :type network_connections: list[~security.models.MicrosoftGraphNetworkConnection]
        :param processes: Security-related stateful information generated by the provider about the
         process or processes related to this alert.
        :type processes: list[~security.models.MicrosoftGraphProcess]
        :param recommended_actions: Vendor/provider recommended action(s) to take as a result of the
         alert (for example, isolate machine, enforce2FA, reimage host).
        :type recommended_actions: list[str]
        :param registry_key_states: Security-related stateful information generated by the provider
         about the registry keys related to this alert.
        :type registry_key_states: list[~security.models.MicrosoftGraphRegistryKeyState]
        :param security_resources: Resources related to current alert. For example, for some alerts
         this can have the Azure Resource value.
        :type security_resources: list[~security.models.MicrosoftGraphSecurityResource]
        :param severity:
        :type severity: str or ~security.models.MicrosoftGraphAlertSeverity
        :param source_materials: Hyperlinks (URIs) to the source material related to the alert, for
         example, provider's user interface for alerts or log search, etc.
        :type source_materials: list[str]
        :param status:
        :type status: str or ~security.models.MicrosoftGraphAlertStatus
        :param tags: User-definable labels that can be applied to an alert and can serve as filter
         conditions (for example 'HVA', 'SAW', etc.) (supports update).
        :type tags: list[str]
        :param title: Alert title. Required.
        :type title: str
        :param triggers: Security-related information about the specific properties that triggered the
         alert (properties appearing in the alert). Alerts might contain information about multiple
         users, hosts, files, ip addresses. This field indicates which properties triggered the alert
         generation.
        :type triggers: list[~security.models.MicrosoftGraphAlertTrigger]
        :param user_states: Security-related stateful information generated by the provider about the
         user accounts related to this alert.
        :type user_states: list[~security.models.MicrosoftGraphUserSecurityState]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :param vulnerability_states: Threat intelligence pertaining to one or more vulnerabilities
         related to this alert.
        :type vulnerability_states: list[~security.models.MicrosoftGraphVulnerabilityState]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAlert(id=id, activity_group_name=activity_group_name, assigned_to=assigned_to, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, category=category, closed_date_time=closed_date_time, cloud_app_states=cloud_app_states, comments=comments, confidence=confidence, created_date_time=created_date_time, description=description, detection_ids=detection_ids, event_date_time=event_date_time, feedback=feedback, file_states=file_states, history_states=history_states, host_states=host_states, incident_ids=incident_ids, last_modified_date_time=last_modified_date_time, malware_states=malware_states, network_connections=network_connections, processes=processes, recommended_actions=recommended_actions, registry_key_states=registry_key_states, security_resources=security_resources, severity=severity, source_materials=source_materials, status=status, tags=tags, title=title, triggers=triggers, user_states=user_states, vendor_information=vendor_information, vulnerability_states=vulnerability_states)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_alert.metadata['url']  # type: ignore
        path_format_arguments = {
            'alert-id': self._serialize.url("alert_id", alert_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAlert')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_alert.metadata = {'url': '/Security/alerts/{alert-id}'}  # type: ignore

    async def delete_alert(
        self,
        alert_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property alerts for Security.

        Delete navigation property alerts for Security.

        :param alert_id: key: id of alert.
        :type alert_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_alert.metadata['url']  # type: ignore
        path_format_arguments = {
            'alert-id': self._serialize.url("alert_id", alert_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_alert.metadata = {'url': '/Security/alerts/{alert-id}'}  # type: ignore

    def list_secure_score_control_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum20"]]] = None,
        select: Optional[List[Union[str, "models.Enum21"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSecureScoreControlProfile"]:
        """Get secureScoreControlProfiles from Security.

        Get secureScoreControlProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum20]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum21]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSecureScoreControlProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfSecureScoreControlProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSecureScoreControlProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_secure_score_control_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSecureScoreControlProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles'}  # type: ignore

    async def create_secure_score_control_profile(
        self,
        id: Optional[str] = None,
        action_type: Optional[str] = None,
        action_url: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        compliance_information: Optional[List["models.MicrosoftGraphComplianceInformation"]] = None,
        control_category: Optional[str] = None,
        control_state_updates: Optional[List["models.MicrosoftGraphSecureScoreControlStateUpdate"]] = None,
        deprecated: Optional[bool] = None,
        implementation_cost: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        max_score: Optional[float] = None,
        rank: Optional[int] = None,
        remediation: Optional[str] = None,
        remediation_impact: Optional[str] = None,
        service: Optional[str] = None,
        threats: Optional[List[str]] = None,
        tier: Optional[str] = None,
        title: Optional[str] = None,
        user_impact: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScoreControlProfile":
        """Create new navigation property to secureScoreControlProfiles for Security.

        Create new navigation property to secureScoreControlProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param action_type: Control action type (Config, Review, Behavior).
        :type action_type: str
        :param action_url: URL to where the control can be actioned.
        :type action_url: str
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param compliance_information:
        :type compliance_information: list[~security.models.MicrosoftGraphComplianceInformation]
        :param control_category: Control action category (Identity, Data, Device, Apps,
         Infrastructure).
        :type control_category: str
        :param control_state_updates:
        :type control_state_updates: list[~security.models.MicrosoftGraphSecureScoreControlStateUpdate]
        :param deprecated: Flag to indicate if a control is depreciated.
        :type deprecated: bool
        :param implementation_cost: Resource cost of implemmentating control (low, moderate, high).
        :type implementation_cost: str
        :param last_modified_date_time: Time at which the control profile entity was last modified. The
         Timestamp type represents date and time.
        :type last_modified_date_time: ~datetime.datetime
        :param max_score: max attainable score for the control.
        :type max_score: float
        :param rank: Microsoft's stack ranking of control.
        :type rank: int
        :param remediation: Description of what the control will help remediate.
        :type remediation: str
        :param remediation_impact: Description of the impact on users of the remediation.
        :type remediation_impact: str
        :param service: Service that owns the control (Exchange, Sharepoint, Azure AD).
        :type service: str
        :param threats: List of threats the control mitigates
         (accountBreach,dataDeletion,dataExfiltration,dataSpillage,.
        :type threats: list[str]
        :param tier:
        :type tier: str
        :param title: Title of the control.
        :type title: str
        :param user_impact:
        :type user_impact: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScoreControlProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScoreControlProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScoreControlProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScoreControlProfile(id=id, action_type=action_type, action_url=action_url, azure_tenant_id=azure_tenant_id, compliance_information=compliance_information, control_category=control_category, control_state_updates=control_state_updates, deprecated=deprecated, implementation_cost=implementation_cost, last_modified_date_time=last_modified_date_time, max_score=max_score, rank=rank, remediation=remediation, remediation_impact=remediation_impact, service=service, threats=threats, tier=tier, title=title, user_impact=user_impact, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_secure_score_control_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScoreControlProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScoreControlProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles'}  # type: ignore

    async def get_secure_score_control_profile(
        self,
        secure_score_control_profile_id: str,
        select: Optional[List[Union[str, "models.Enum22"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScoreControlProfile":
        """Get secureScoreControlProfiles from Security.

        Get secureScoreControlProfiles from Security.

        :param secure_score_control_profile_id: key: id of secureScoreControlProfile.
        :type secure_score_control_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum22]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScoreControlProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScoreControlProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScoreControlProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_secure_score_control_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScoreControlProfile-id': self._serialize.url("secure_score_control_profile_id", secure_score_control_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScoreControlProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles/{secureScoreControlProfile-id}'}  # type: ignore

    async def update_secure_score_control_profile(
        self,
        secure_score_control_profile_id: str,
        id: Optional[str] = None,
        action_type: Optional[str] = None,
        action_url: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        compliance_information: Optional[List["models.MicrosoftGraphComplianceInformation"]] = None,
        control_category: Optional[str] = None,
        control_state_updates: Optional[List["models.MicrosoftGraphSecureScoreControlStateUpdate"]] = None,
        deprecated: Optional[bool] = None,
        implementation_cost: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        max_score: Optional[float] = None,
        rank: Optional[int] = None,
        remediation: Optional[str] = None,
        remediation_impact: Optional[str] = None,
        service: Optional[str] = None,
        threats: Optional[List[str]] = None,
        tier: Optional[str] = None,
        title: Optional[str] = None,
        user_impact: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property secureScoreControlProfiles in Security.

        Update the navigation property secureScoreControlProfiles in Security.

        :param secure_score_control_profile_id: key: id of secureScoreControlProfile.
        :type secure_score_control_profile_id: str
        :param id: Read-only.
        :type id: str
        :param action_type: Control action type (Config, Review, Behavior).
        :type action_type: str
        :param action_url: URL to where the control can be actioned.
        :type action_url: str
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param compliance_information:
        :type compliance_information: list[~security.models.MicrosoftGraphComplianceInformation]
        :param control_category: Control action category (Identity, Data, Device, Apps,
         Infrastructure).
        :type control_category: str
        :param control_state_updates:
        :type control_state_updates: list[~security.models.MicrosoftGraphSecureScoreControlStateUpdate]
        :param deprecated: Flag to indicate if a control is depreciated.
        :type deprecated: bool
        :param implementation_cost: Resource cost of implemmentating control (low, moderate, high).
        :type implementation_cost: str
        :param last_modified_date_time: Time at which the control profile entity was last modified. The
         Timestamp type represents date and time.
        :type last_modified_date_time: ~datetime.datetime
        :param max_score: max attainable score for the control.
        :type max_score: float
        :param rank: Microsoft's stack ranking of control.
        :type rank: int
        :param remediation: Description of what the control will help remediate.
        :type remediation: str
        :param remediation_impact: Description of the impact on users of the remediation.
        :type remediation_impact: str
        :param service: Service that owns the control (Exchange, Sharepoint, Azure AD).
        :type service: str
        :param threats: List of threats the control mitigates
         (accountBreach,dataDeletion,dataExfiltration,dataSpillage,.
        :type threats: list[str]
        :param tier:
        :type tier: str
        :param title: Title of the control.
        :type title: str
        :param user_impact:
        :type user_impact: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScoreControlProfile(id=id, action_type=action_type, action_url=action_url, azure_tenant_id=azure_tenant_id, compliance_information=compliance_information, control_category=control_category, control_state_updates=control_state_updates, deprecated=deprecated, implementation_cost=implementation_cost, last_modified_date_time=last_modified_date_time, max_score=max_score, rank=rank, remediation=remediation, remediation_impact=remediation_impact, service=service, threats=threats, tier=tier, title=title, user_impact=user_impact, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_secure_score_control_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScoreControlProfile-id': self._serialize.url("secure_score_control_profile_id", secure_score_control_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScoreControlProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles/{secureScoreControlProfile-id}'}  # type: ignore

    async def delete_secure_score_control_profile(
        self,
        secure_score_control_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property secureScoreControlProfiles for Security.

        Delete navigation property secureScoreControlProfiles for Security.

        :param secure_score_control_profile_id: key: id of secureScoreControlProfile.
        :type secure_score_control_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_secure_score_control_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScoreControlProfile-id': self._serialize.url("secure_score_control_profile_id", secure_score_control_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles/{secureScoreControlProfile-id}'}  # type: ignore

    def list_secure_score(
        self,
        orderby: Optional[List[Union[str, "models.Enum23"]]] = None,
        select: Optional[List[Union[str, "models.Enum24"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSecureScore"]:
        """Get secureScores from Security.

        Get secureScores from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum23]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum24]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSecureScore or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfSecureScore]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSecureScore"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_secure_score.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSecureScore', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_secure_score.metadata = {'url': '/Security/secureScores'}  # type: ignore

    async def create_secure_score(
        self,
        id: Optional[str] = None,
        active_user_count: Optional[int] = None,
        average_comparative_scores: Optional[List["models.MicrosoftGraphAverageComparativeScore"]] = None,
        azure_tenant_id: Optional[str] = None,
        control_scores: Optional[List["models.MicrosoftGraphControlScore"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        current_score: Optional[float] = None,
        enabled_services: Optional[List[str]] = None,
        licensed_user_count: Optional[int] = None,
        max_score: Optional[float] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScore":
        """Create new navigation property to secureScores for Security.

        Create new navigation property to secureScores for Security.

        :param id: Read-only.
        :type id: str
        :param active_user_count: Active user count of the given tenant.
        :type active_user_count: int
        :param average_comparative_scores: Average score by different scopes (for example, average by
         industry, average by seating) and control category (Identity, Data, Device, Apps,
         Infrastructure) within the scope.
        :type average_comparative_scores: list[~security.models.MicrosoftGraphAverageComparativeScore]
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param control_scores: Contains tenant scores for a set of controls.
        :type control_scores: list[~security.models.MicrosoftGraphControlScore]
        :param created_date_time: The date when the entity is created.
        :type created_date_time: ~datetime.datetime
        :param current_score: Tenant current attained score on specified date.
        :type current_score: float
        :param enabled_services: Microsoft-provided services for the tenant (for example, Exchange
         online, Skype, Sharepoint).
        :type enabled_services: list[str]
        :param licensed_user_count: Licensed user count of the given tenant.
        :type licensed_user_count: int
        :param max_score: Tenant maximum possible score on specified date.
        :type max_score: float
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScore, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScore
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScore"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScore(id=id, active_user_count=active_user_count, average_comparative_scores=average_comparative_scores, azure_tenant_id=azure_tenant_id, control_scores=control_scores, created_date_time=created_date_time, current_score=current_score, enabled_services=enabled_services, licensed_user_count=licensed_user_count, max_score=max_score, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_secure_score.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScore')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScore', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_secure_score.metadata = {'url': '/Security/secureScores'}  # type: ignore

    async def get_secure_score(
        self,
        secure_score_id: str,
        select: Optional[List[Union[str, "models.Enum25"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScore":
        """Get secureScores from Security.

        Get secureScores from Security.

        :param secure_score_id: key: id of secureScore.
        :type secure_score_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScore, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScore
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScore"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScore-id': self._serialize.url("secure_score_id", secure_score_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScore', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_secure_score.metadata = {'url': '/Security/secureScores/{secureScore-id}'}  # type: ignore

    async def update_secure_score(
        self,
        secure_score_id: str,
        id: Optional[str] = None,
        active_user_count: Optional[int] = None,
        average_comparative_scores: Optional[List["models.MicrosoftGraphAverageComparativeScore"]] = None,
        azure_tenant_id: Optional[str] = None,
        control_scores: Optional[List["models.MicrosoftGraphControlScore"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        current_score: Optional[float] = None,
        enabled_services: Optional[List[str]] = None,
        licensed_user_count: Optional[int] = None,
        max_score: Optional[float] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property secureScores in Security.

        Update the navigation property secureScores in Security.

        :param secure_score_id: key: id of secureScore.
        :type secure_score_id: str
        :param id: Read-only.
        :type id: str
        :param active_user_count: Active user count of the given tenant.
        :type active_user_count: int
        :param average_comparative_scores: Average score by different scopes (for example, average by
         industry, average by seating) and control category (Identity, Data, Device, Apps,
         Infrastructure) within the scope.
        :type average_comparative_scores: list[~security.models.MicrosoftGraphAverageComparativeScore]
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param control_scores: Contains tenant scores for a set of controls.
        :type control_scores: list[~security.models.MicrosoftGraphControlScore]
        :param created_date_time: The date when the entity is created.
        :type created_date_time: ~datetime.datetime
        :param current_score: Tenant current attained score on specified date.
        :type current_score: float
        :param enabled_services: Microsoft-provided services for the tenant (for example, Exchange
         online, Skype, Sharepoint).
        :type enabled_services: list[str]
        :param licensed_user_count: Licensed user count of the given tenant.
        :type licensed_user_count: int
        :param max_score: Tenant maximum possible score on specified date.
        :type max_score: float
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScore(id=id, active_user_count=active_user_count, average_comparative_scores=average_comparative_scores, azure_tenant_id=azure_tenant_id, control_scores=control_scores, created_date_time=created_date_time, current_score=current_score, enabled_services=enabled_services, licensed_user_count=licensed_user_count, max_score=max_score, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScore-id': self._serialize.url("secure_score_id", secure_score_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScore')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_secure_score.metadata = {'url': '/Security/secureScores/{secureScore-id}'}  # type: ignore

    async def delete_secure_score(
        self,
        secure_score_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property secureScores for Security.

        Delete navigation property secureScores for Security.

        :param secure_score_id: key: id of secureScore.
        :type secure_score_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScore-id': self._serialize.url("secure_score_id", secure_score_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_secure_score.metadata = {'url': '/Security/secureScores/{secureScore-id}'}  # type: ignore
