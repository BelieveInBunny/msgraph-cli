# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class PolicyOperations:
    """PolicyOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~identity_sign_ins.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_activity_based_timeout_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum114"]]] = None,
        select: Optional[List[Union[str, "models.Enum115"]]] = None,
        expand: Optional[List[Union[str, "models.Enum116"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfActivityBasedTimeoutPolicy"]:
        """Get activityBasedTimeoutPolicies from policies.

        Get activityBasedTimeoutPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum114]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum115]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum116]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfActivityBasedTimeoutPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfActivityBasedTimeoutPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_activity_based_timeout_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfActivityBasedTimeoutPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies'}  # type: ignore

    async def create_activity_based_timeout_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphActivityBasedTimeoutPolicy":
        """Create new navigation property to activityBasedTimeoutPolicies for policies.

        Create new navigation property to activityBasedTimeoutPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphActivityBasedTimeoutPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphActivityBasedTimeoutPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphActivityBasedTimeoutPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_activity_based_timeout_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphActivityBasedTimeoutPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphActivityBasedTimeoutPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies'}  # type: ignore

    async def get_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id: str,
        select: Optional[List[Union[str, "models.Enum117"]]] = None,
        expand: Optional[List[Union[str, "models.Enum118"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphActivityBasedTimeoutPolicy":
        """Get activityBasedTimeoutPolicies from policies.

        Get activityBasedTimeoutPolicies from policies.

        :param activity_based_timeout_policy_id: key: id of activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum117]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum118]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphActivityBasedTimeoutPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphActivityBasedTimeoutPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphActivityBasedTimeoutPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    async def update_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property activityBasedTimeoutPolicies in policies.

        Update the navigation property activityBasedTimeoutPolicies in policies.

        :param activity_based_timeout_policy_id: key: id of activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphActivityBasedTimeoutPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphActivityBasedTimeoutPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    async def delete_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property activityBasedTimeoutPolicies for policies.

        Delete navigation property activityBasedTimeoutPolicies for policies.

        :param activity_based_timeout_policy_id: key: id of activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    def list_claim_mapping_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum119"]]] = None,
        select: Optional[List[Union[str, "models.Enum120"]]] = None,
        expand: Optional[List[Union[str, "models.Enum121"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfClaimsMappingPolicy"]:
        """Get claimsMappingPolicies from policies.

        Get claimsMappingPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum119]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum120]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum121]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfClaimsMappingPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfClaimsMappingPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_claim_mapping_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfClaimsMappingPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies'}  # type: ignore

    async def create_claim_mapping_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphClaimsMappingPolicy":
        """Create new navigation property to claimsMappingPolicies for policies.

        Create new navigation property to claimsMappingPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphClaimsMappingPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphClaimsMappingPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphClaimsMappingPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_claim_mapping_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphClaimsMappingPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphClaimsMappingPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies'}  # type: ignore

    async def get_claim_mapping_policy(
        self,
        claims_mapping_policy_id: str,
        select: Optional[List[Union[str, "models.Enum122"]]] = None,
        expand: Optional[List[Union[str, "models.Enum123"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphClaimsMappingPolicy":
        """Get claimsMappingPolicies from policies.

        Get claimsMappingPolicies from policies.

        :param claims_mapping_policy_id: key: id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum122]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum123]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphClaimsMappingPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphClaimsMappingPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphClaimsMappingPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    async def update_claim_mapping_policy(
        self,
        claims_mapping_policy_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property claimsMappingPolicies in policies.

        Update the navigation property claimsMappingPolicies in policies.

        :param claims_mapping_policy_id: key: id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphClaimsMappingPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphClaimsMappingPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    async def delete_claim_mapping_policy(
        self,
        claims_mapping_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property claimsMappingPolicies for policies.

        Delete navigation property claimsMappingPolicies for policies.

        :param claims_mapping_policy_id: key: id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    def list_conditional_access_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum124"]]] = None,
        select: Optional[List[Union[str, "models.Enum125"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfConditionalAccessPolicy0"]:
        """Get conditionalAccessPolicies from policies.

        Get conditionalAccessPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum124]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum125]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfConditionalAccessPolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfConditionalAccessPolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfConditionalAccessPolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_conditional_access_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfConditionalAccessPolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies'}  # type: ignore

    async def create_conditional_access_policy(
        self,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        grant_controls: Optional["models.MicrosoftGraphConditionalAccessGrantControls"] = None,
        modified_date_time: Optional[datetime.datetime] = None,
        state: Optional[Union[str, "models.MicrosoftGraphConditionalAccessPolicyState"]] = None,
        application_enforced_restrictions: Optional["models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl"] = None,
        cloud_app_security: Optional["models.MicrosoftGraphCloudAppSecuritySessionControl"] = None,
        persistent_browser: Optional["models.MicrosoftGraphPersistentBrowserSessionControl"] = None,
        sign_in_frequency: Optional["models.MicrosoftGraphSignInFrequencySessionControl"] = None,
        applications: Optional["models.MicrosoftGraphConditionalAccessApplications"] = None,
        client_app_types: Optional[List[Union[str, "models.MicrosoftGraphConditionalAccessClientApp"]]] = None,
        locations: Optional["models.MicrosoftGraphConditionalAccessLocations"] = None,
        platforms: Optional["models.MicrosoftGraphConditionalAccessPlatforms"] = None,
        sign_in_risk_levels: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]] = None,
        users: Optional["models.MicrosoftGraphConditionalAccessUsers"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphConditionalAccessPolicy":
        """Create new navigation property to conditionalAccessPolicies for policies.

        Create new navigation property to conditionalAccessPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type created_date_time: ~datetime.datetime
        :param description:
        :type description: str
        :param display_name: Specifies a display name for the conditionalAccessPolicy object.
        :type display_name: str
        :param grant_controls: conditionalAccessGrantControls.
        :type grant_controls: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessGrantControls
        :param modified_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type modified_date_time: ~datetime.datetime
        :param state:
        :type state: str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicyState
        :param application_enforced_restrictions: applicationEnforcedRestrictionsSessionControl.
        :type application_enforced_restrictions: ~identity_sign_ins.models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl
        :param cloud_app_security: cloudAppSecuritySessionControl.
        :type cloud_app_security: ~identity_sign_ins.models.MicrosoftGraphCloudAppSecuritySessionControl
        :param persistent_browser: persistentBrowserSessionControl.
        :type persistent_browser: ~identity_sign_ins.models.MicrosoftGraphPersistentBrowserSessionControl
        :param sign_in_frequency: signInFrequencySessionControl.
        :type sign_in_frequency: ~identity_sign_ins.models.MicrosoftGraphSignInFrequencySessionControl
        :param applications: conditionalAccessApplications.
        :type applications: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessApplications
        :param client_app_types: Client application types included in the policy. Possible values are:
         all, browser, mobileAppsAndDesktopClients, exchangeActiveSync, easSupported, other.
        :type client_app_types: list[str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessClientApp]
        :param locations: conditionalAccessLocations.
        :type locations: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessLocations
        :param platforms: conditionalAccessPlatforms.
        :type platforms: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPlatforms
        :param sign_in_risk_levels: Risk levels included in the policy. Possible values are: low,
         medium, high, none.
        :type sign_in_risk_levels: list[str or ~identity_sign_ins.models.MicrosoftGraphRiskLevel]
        :param users: conditionalAccessUsers.
        :type users: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessUsers
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConditionalAccessPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConditionalAccessPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, grant_controls=grant_controls, modified_date_time=modified_date_time, state=state, application_enforced_restrictions=application_enforced_restrictions, cloud_app_security=cloud_app_security, persistent_browser=persistent_browser, sign_in_frequency=sign_in_frequency, applications=applications, client_app_types=client_app_types, locations=locations, platforms=platforms, sign_in_risk_levels=sign_in_risk_levels, users=users)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_conditional_access_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConditionalAccessPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConditionalAccessPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies'}  # type: ignore

    async def get_conditional_access_policy(
        self,
        conditional_access_policy_id: str,
        select: Optional[List[Union[str, "models.Enum126"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphConditionalAccessPolicy":
        """Get conditionalAccessPolicies from policies.

        Get conditionalAccessPolicies from policies.

        :param conditional_access_policy_id: key: id of conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum126]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConditionalAccessPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConditionalAccessPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    async def update_conditional_access_policy(
        self,
        conditional_access_policy_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        grant_controls: Optional["models.MicrosoftGraphConditionalAccessGrantControls"] = None,
        modified_date_time: Optional[datetime.datetime] = None,
        state: Optional[Union[str, "models.MicrosoftGraphConditionalAccessPolicyState"]] = None,
        application_enforced_restrictions: Optional["models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl"] = None,
        cloud_app_security: Optional["models.MicrosoftGraphCloudAppSecuritySessionControl"] = None,
        persistent_browser: Optional["models.MicrosoftGraphPersistentBrowserSessionControl"] = None,
        sign_in_frequency: Optional["models.MicrosoftGraphSignInFrequencySessionControl"] = None,
        applications: Optional["models.MicrosoftGraphConditionalAccessApplications"] = None,
        client_app_types: Optional[List[Union[str, "models.MicrosoftGraphConditionalAccessClientApp"]]] = None,
        locations: Optional["models.MicrosoftGraphConditionalAccessLocations"] = None,
        platforms: Optional["models.MicrosoftGraphConditionalAccessPlatforms"] = None,
        sign_in_risk_levels: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]] = None,
        users: Optional["models.MicrosoftGraphConditionalAccessUsers"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property conditionalAccessPolicies in policies.

        Update the navigation property conditionalAccessPolicies in policies.

        :param conditional_access_policy_id: key: id of conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type created_date_time: ~datetime.datetime
        :param description:
        :type description: str
        :param display_name: Specifies a display name for the conditionalAccessPolicy object.
        :type display_name: str
        :param grant_controls: conditionalAccessGrantControls.
        :type grant_controls: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessGrantControls
        :param modified_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type modified_date_time: ~datetime.datetime
        :param state:
        :type state: str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicyState
        :param application_enforced_restrictions: applicationEnforcedRestrictionsSessionControl.
        :type application_enforced_restrictions: ~identity_sign_ins.models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl
        :param cloud_app_security: cloudAppSecuritySessionControl.
        :type cloud_app_security: ~identity_sign_ins.models.MicrosoftGraphCloudAppSecuritySessionControl
        :param persistent_browser: persistentBrowserSessionControl.
        :type persistent_browser: ~identity_sign_ins.models.MicrosoftGraphPersistentBrowserSessionControl
        :param sign_in_frequency: signInFrequencySessionControl.
        :type sign_in_frequency: ~identity_sign_ins.models.MicrosoftGraphSignInFrequencySessionControl
        :param applications: conditionalAccessApplications.
        :type applications: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessApplications
        :param client_app_types: Client application types included in the policy. Possible values are:
         all, browser, mobileAppsAndDesktopClients, exchangeActiveSync, easSupported, other.
        :type client_app_types: list[str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessClientApp]
        :param locations: conditionalAccessLocations.
        :type locations: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessLocations
        :param platforms: conditionalAccessPlatforms.
        :type platforms: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPlatforms
        :param sign_in_risk_levels: Risk levels included in the policy. Possible values are: low,
         medium, high, none.
        :type sign_in_risk_levels: list[str or ~identity_sign_ins.models.MicrosoftGraphRiskLevel]
        :param users: conditionalAccessUsers.
        :type users: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessUsers
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConditionalAccessPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, grant_controls=grant_controls, modified_date_time=modified_date_time, state=state, application_enforced_restrictions=application_enforced_restrictions, cloud_app_security=cloud_app_security, persistent_browser=persistent_browser, sign_in_frequency=sign_in_frequency, applications=applications, client_app_types=client_app_types, locations=locations, platforms=platforms, sign_in_risk_levels=sign_in_risk_levels, users=users)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConditionalAccessPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    async def delete_conditional_access_policy(
        self,
        conditional_access_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property conditionalAccessPolicies for policies.

        Delete navigation property conditionalAccessPolicies for policies.

        :param conditional_access_policy_id: key: id of conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    def list_home_realm_discovery_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum127"]]] = None,
        select: Optional[List[Union[str, "models.Enum128"]]] = None,
        expand: Optional[List[Union[str, "models.Enum129"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfHomeRealmDiscoveryPolicy"]:
        """Get homeRealmDiscoveryPolicies from policies.

        Get homeRealmDiscoveryPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum127]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum128]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum129]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfHomeRealmDiscoveryPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfHomeRealmDiscoveryPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_home_realm_discovery_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfHomeRealmDiscoveryPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies'}  # type: ignore

    async def create_home_realm_discovery_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphHomeRealmDiscoveryPolicy":
        """Create new navigation property to homeRealmDiscoveryPolicies for policies.

        Create new navigation property to homeRealmDiscoveryPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphHomeRealmDiscoveryPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphHomeRealmDiscoveryPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphHomeRealmDiscoveryPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_home_realm_discovery_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphHomeRealmDiscoveryPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphHomeRealmDiscoveryPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies'}  # type: ignore

    async def get_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id: str,
        select: Optional[List[Union[str, "models.Enum130"]]] = None,
        expand: Optional[List[Union[str, "models.Enum131"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphHomeRealmDiscoveryPolicy":
        """Get homeRealmDiscoveryPolicies from policies.

        Get homeRealmDiscoveryPolicies from policies.

        :param home_realm_discovery_policy_id: key: id of homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum130]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum131]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphHomeRealmDiscoveryPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphHomeRealmDiscoveryPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphHomeRealmDiscoveryPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    async def update_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property homeRealmDiscoveryPolicies in policies.

        Update the navigation property homeRealmDiscoveryPolicies in policies.

        :param home_realm_discovery_policy_id: key: id of homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphHomeRealmDiscoveryPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphHomeRealmDiscoveryPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    async def delete_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property homeRealmDiscoveryPolicies for policies.

        Delete navigation property homeRealmDiscoveryPolicies for policies.

        :param home_realm_discovery_policy_id: key: id of homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    async def get_identity_security_default_enforcement_policy(
        self,
        select: Optional[List[Union[str, "models.Enum132"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy":
        """Get identitySecurityDefaultsEnforcementPolicy from policies.

        Get identitySecurityDefaultsEnforcementPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum132]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    async def update_identity_security_default_enforcement_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        is_enabled: Optional[bool] = None,
        **kwargs
    ) -> None:
        """Update the navigation property identitySecurityDefaultsEnforcementPolicy in policies.

        Update the navigation property identitySecurityDefaultsEnforcementPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param is_enabled: If set to true, Azure Active Directory security defaults is enabled for the
         tenant.
        :type is_enabled: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, is_enabled=is_enabled)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    async def delete_identity_security_default_enforcement_policy(
        self,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property identitySecurityDefaultsEnforcementPolicy for policies.

        Delete navigation property identitySecurityDefaultsEnforcementPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    def list_permission_grant_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum133"]]] = None,
        select: Optional[List[Union[str, "models.Enum134"]]] = None,
        expand: Optional[List[Union[str, "models.Enum135"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPermissionGrantPolicy"]:
        """Get permissionGrantPolicies from policies.

        Get permissionGrantPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum133]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum134]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum135]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPermissionGrantPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfPermissionGrantPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPermissionGrantPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_permission_grant_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPermissionGrantPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies'}  # type: ignore

    async def create_permission_grant_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        excludes: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]] = None,
        includes: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPermissionGrantPolicy":
        """Create new navigation property to permissionGrantPolicies for policies.

        Create new navigation property to permissionGrantPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param excludes:
        :type excludes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :param includes:
        :type includes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPermissionGrantPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphPermissionGrantPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPermissionGrantPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPermissionGrantPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, excludes=excludes, includes=includes)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_permission_grant_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPermissionGrantPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPermissionGrantPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies'}  # type: ignore

    async def get_permission_grant_policy(
        self,
        permission_grant_policy_id: str,
        select: Optional[List[Union[str, "models.Enum136"]]] = None,
        expand: Optional[List[Union[str, "models.Enum137"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPermissionGrantPolicy":
        """Get permissionGrantPolicies from policies.

        Get permissionGrantPolicies from policies.

        :param permission_grant_policy_id: key: id of permissionGrantPolicy.
        :type permission_grant_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum136]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum137]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPermissionGrantPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphPermissionGrantPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPermissionGrantPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_permission_grant_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'permissionGrantPolicy-id': self._serialize.url("permission_grant_policy_id", permission_grant_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPermissionGrantPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies/{permissionGrantPolicy-id}'}  # type: ignore

    async def update_permission_grant_policy(
        self,
        permission_grant_policy_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        excludes: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]] = None,
        includes: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property permissionGrantPolicies in policies.

        Update the navigation property permissionGrantPolicies in policies.

        :param permission_grant_policy_id: key: id of permissionGrantPolicy.
        :type permission_grant_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param excludes:
        :type excludes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :param includes:
        :type includes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPermissionGrantPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, excludes=excludes, includes=includes)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_permission_grant_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'permissionGrantPolicy-id': self._serialize.url("permission_grant_policy_id", permission_grant_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPermissionGrantPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies/{permissionGrantPolicy-id}'}  # type: ignore

    async def delete_permission_grant_policy(
        self,
        permission_grant_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property permissionGrantPolicies for policies.

        Delete navigation property permissionGrantPolicies for policies.

        :param permission_grant_policy_id: key: id of permissionGrantPolicy.
        :type permission_grant_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_permission_grant_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'permissionGrantPolicy-id': self._serialize.url("permission_grant_policy_id", permission_grant_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies/{permissionGrantPolicy-id}'}  # type: ignore

    def list_token_issuance_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum144"]]] = None,
        select: Optional[List[Union[str, "models.Enum145"]]] = None,
        expand: Optional[List[Union[str, "models.Enum146"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTokenIssuancePolicy"]:
        """Get tokenIssuancePolicies from policies.

        Get tokenIssuancePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum144]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum145]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum146]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenIssuancePolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfTokenIssuancePolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_issuance_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenIssuancePolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies'}  # type: ignore

    async def create_token_issuance_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTokenIssuancePolicy":
        """Create new navigation property to tokenIssuancePolicies for policies.

        Create new navigation property to tokenIssuancePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenIssuancePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenIssuancePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenIssuancePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_token_issuance_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenIssuancePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenIssuancePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies'}  # type: ignore

    async def get_token_issuance_policy(
        self,
        token_issuance_policy_id: str,
        select: Optional[List[Union[str, "models.Enum147"]]] = None,
        expand: Optional[List[Union[str, "models.Enum148"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTokenIssuancePolicy":
        """Get tokenIssuancePolicies from policies.

        Get tokenIssuancePolicies from policies.

        :param token_issuance_policy_id: key: id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum147]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum148]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenIssuancePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenIssuancePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenIssuancePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    async def update_token_issuance_policy(
        self,
        token_issuance_policy_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property tokenIssuancePolicies in policies.

        Update the navigation property tokenIssuancePolicies in policies.

        :param token_issuance_policy_id: key: id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenIssuancePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenIssuancePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    async def delete_token_issuance_policy(
        self,
        token_issuance_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property tokenIssuancePolicies for policies.

        Delete navigation property tokenIssuancePolicies for policies.

        :param token_issuance_policy_id: key: id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    def list_token_lifetime_policy(
        self,
        orderby: Optional[List[Union[str, "models.Enum149"]]] = None,
        select: Optional[List[Union[str, "models.Enum150"]]] = None,
        expand: Optional[List[Union[str, "models.Enum151"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTokenLifetimePolicy"]:
        """Get tokenLifetimePolicies from policies.

        Get tokenLifetimePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum149]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum150]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum151]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenLifetimePolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~identity_sign_ins.models.CollectionOfTokenLifetimePolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_lifetime_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenLifetimePolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies'}  # type: ignore

    async def create_token_lifetime_policy(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTokenLifetimePolicy":
        """Create new navigation property to tokenLifetimePolicies for policies.

        Create new navigation property to tokenLifetimePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenLifetimePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenLifetimePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenLifetimePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_token_lifetime_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenLifetimePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenLifetimePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies'}  # type: ignore

    async def get_token_lifetime_policy(
        self,
        token_lifetime_policy_id: str,
        select: Optional[List[Union[str, "models.Enum152"]]] = None,
        expand: Optional[List[Union[str, "models.Enum153"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTokenLifetimePolicy":
        """Get tokenLifetimePolicies from policies.

        Get tokenLifetimePolicies from policies.

        :param token_lifetime_policy_id: key: id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum152]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum153]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenLifetimePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenLifetimePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenLifetimePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore

    async def update_token_lifetime_policy(
        self,
        token_lifetime_policy_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        definition: Optional[List[str]] = None,
        is_organization_default: Optional[bool] = None,
        applies_to: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property tokenLifetimePolicies in policies.

        Update the navigation property tokenLifetimePolicies in policies.

        :param token_lifetime_policy_id: key: id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenLifetimePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenLifetimePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore

    async def delete_token_lifetime_policy(
        self,
        token_lifetime_policy_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property tokenLifetimePolicies for policies.

        Delete navigation property tokenLifetimePolicies for policies.

        :param token_lifetime_policy_id: key: id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore
