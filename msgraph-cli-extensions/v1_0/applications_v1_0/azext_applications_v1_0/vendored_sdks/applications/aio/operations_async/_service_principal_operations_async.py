# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class ServicePrincipalOperations:
    """ServicePrincipalOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~applications.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_app_role_assigned_to(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum32"]]] = None,
        select: Optional[List[Union[str, "models.Enum33"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAppRoleAssignment0"]:
        """Get appRoleAssignedTo from servicePrincipals.

        Get appRoleAssignedTo from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum32]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum33]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAppRoleAssignment0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfAppRoleAssignment0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAppRoleAssignment0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_app_role_assigned_to.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAppRoleAssignment0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_app_role_assigned_to.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignedTo'}  # type: ignore

    async def create_app_role_assigned_to(
        self,
        service_principal_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        app_role_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        principal_display_name: Optional[str] = None,
        principal_id: Optional[str] = None,
        principal_type: Optional[str] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAppRoleAssignment":
        """Create new navigation property to appRoleAssignedTo for servicePrincipals.

        Create new navigation property to appRoleAssignedTo for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param app_role_id: The identifier (id) for the app role which is assigned to the principal.
         This app role must be exposed in the appRoles property on the resource application's service
         principal (resourceId). If the resource application has not declared any app roles, a default
         app role ID of 00000000-0000-0000-0000-000000000000 can be specified to signal that the
         principal is assigned to the resource app without any specific app roles. Required on create.
         Does not support $filter.
        :type app_role_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param principal_display_name: The display name of the user, group, or service principal that
         was granted the app role assignment. Read-only. Supports $filter (eq and startswith).
        :type principal_display_name: str
        :param principal_id: The unique identifier (id) for the user, group or service principal being
         granted the app role. Required on create. Does not support $filter.
        :type principal_id: str
        :param principal_type: The type of the assigned principal. This can either be 'User', 'Group'
         or 'ServicePrincipal'. Read-only. Does not support $filter.
        :type principal_type: str
        :param resource_display_name: The display name of the resource app's service principal to which
         the assignment is made. Does not support $filter.
        :type resource_display_name: str
        :param resource_id: The unique identifier (id) for the resource service principal for which the
         assignment is made. Required on create. Supports $filter (eq only).
        :type resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAppRoleAssignment, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphAppRoleAssignment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAppRoleAssignment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAppRoleAssignment(id=id, deleted_date_time=deleted_date_time, app_role_id=app_role_id, created_date_time=created_date_time, principal_display_name=principal_display_name, principal_id=principal_id, principal_type=principal_type, resource_display_name=resource_display_name, resource_id=resource_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_app_role_assigned_to.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAppRoleAssignment')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAppRoleAssignment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_app_role_assigned_to.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignedTo'}  # type: ignore

    async def get_app_role_assigned_to(
        self,
        service_principal_id: str,
        app_role_assignment_id: str,
        select: Optional[List[Union[str, "models.Enum34"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAppRoleAssignment":
        """Get appRoleAssignedTo from servicePrincipals.

        Get appRoleAssignedTo from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param app_role_assignment_id: key: id of appRoleAssignment.
        :type app_role_assignment_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum34]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAppRoleAssignment, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphAppRoleAssignment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAppRoleAssignment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_app_role_assigned_to.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'appRoleAssignment-id': self._serialize.url("app_role_assignment_id", app_role_assignment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAppRoleAssignment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_app_role_assigned_to.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignedTo/{appRoleAssignment-id}'}  # type: ignore

    async def update_app_role_assigned_to(
        self,
        service_principal_id: str,
        app_role_assignment_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        app_role_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        principal_display_name: Optional[str] = None,
        principal_id: Optional[str] = None,
        principal_type: Optional[str] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property appRoleAssignedTo in servicePrincipals.

        Update the navigation property appRoleAssignedTo in servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param app_role_assignment_id: key: id of appRoleAssignment.
        :type app_role_assignment_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param app_role_id: The identifier (id) for the app role which is assigned to the principal.
         This app role must be exposed in the appRoles property on the resource application's service
         principal (resourceId). If the resource application has not declared any app roles, a default
         app role ID of 00000000-0000-0000-0000-000000000000 can be specified to signal that the
         principal is assigned to the resource app without any specific app roles. Required on create.
         Does not support $filter.
        :type app_role_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param principal_display_name: The display name of the user, group, or service principal that
         was granted the app role assignment. Read-only. Supports $filter (eq and startswith).
        :type principal_display_name: str
        :param principal_id: The unique identifier (id) for the user, group or service principal being
         granted the app role. Required on create. Does not support $filter.
        :type principal_id: str
        :param principal_type: The type of the assigned principal. This can either be 'User', 'Group'
         or 'ServicePrincipal'. Read-only. Does not support $filter.
        :type principal_type: str
        :param resource_display_name: The display name of the resource app's service principal to which
         the assignment is made. Does not support $filter.
        :type resource_display_name: str
        :param resource_id: The unique identifier (id) for the resource service principal for which the
         assignment is made. Required on create. Supports $filter (eq only).
        :type resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAppRoleAssignment(id=id, deleted_date_time=deleted_date_time, app_role_id=app_role_id, created_date_time=created_date_time, principal_display_name=principal_display_name, principal_id=principal_id, principal_type=principal_type, resource_display_name=resource_display_name, resource_id=resource_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_app_role_assigned_to.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'appRoleAssignment-id': self._serialize.url("app_role_assignment_id", app_role_assignment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAppRoleAssignment')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_app_role_assigned_to.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignedTo/{appRoleAssignment-id}'}  # type: ignore

    async def delete_app_role_assigned_to(
        self,
        service_principal_id: str,
        app_role_assignment_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property appRoleAssignedTo for servicePrincipals.

        Delete navigation property appRoleAssignedTo for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param app_role_assignment_id: key: id of appRoleAssignment.
        :type app_role_assignment_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_app_role_assigned_to.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'appRoleAssignment-id': self._serialize.url("app_role_assignment_id", app_role_assignment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_app_role_assigned_to.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignedTo/{appRoleAssignment-id}'}  # type: ignore

    def list_app_role_assignment(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum35"]]] = None,
        select: Optional[List[Union[str, "models.Enum36"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAppRoleAssignment1"]:
        """Get appRoleAssignments from servicePrincipals.

        Get appRoleAssignments from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum35]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum36]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAppRoleAssignment1 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfAppRoleAssignment1]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAppRoleAssignment1"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_app_role_assignment.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAppRoleAssignment1', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_app_role_assignment.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignments'}  # type: ignore

    async def create_app_role_assignment(
        self,
        service_principal_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        app_role_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        principal_display_name: Optional[str] = None,
        principal_id: Optional[str] = None,
        principal_type: Optional[str] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAppRoleAssignment":
        """Create new navigation property to appRoleAssignments for servicePrincipals.

        Create new navigation property to appRoleAssignments for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param app_role_id: The identifier (id) for the app role which is assigned to the principal.
         This app role must be exposed in the appRoles property on the resource application's service
         principal (resourceId). If the resource application has not declared any app roles, a default
         app role ID of 00000000-0000-0000-0000-000000000000 can be specified to signal that the
         principal is assigned to the resource app without any specific app roles. Required on create.
         Does not support $filter.
        :type app_role_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param principal_display_name: The display name of the user, group, or service principal that
         was granted the app role assignment. Read-only. Supports $filter (eq and startswith).
        :type principal_display_name: str
        :param principal_id: The unique identifier (id) for the user, group or service principal being
         granted the app role. Required on create. Does not support $filter.
        :type principal_id: str
        :param principal_type: The type of the assigned principal. This can either be 'User', 'Group'
         or 'ServicePrincipal'. Read-only. Does not support $filter.
        :type principal_type: str
        :param resource_display_name: The display name of the resource app's service principal to which
         the assignment is made. Does not support $filter.
        :type resource_display_name: str
        :param resource_id: The unique identifier (id) for the resource service principal for which the
         assignment is made. Required on create. Supports $filter (eq only).
        :type resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAppRoleAssignment, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphAppRoleAssignment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAppRoleAssignment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAppRoleAssignment(id=id, deleted_date_time=deleted_date_time, app_role_id=app_role_id, created_date_time=created_date_time, principal_display_name=principal_display_name, principal_id=principal_id, principal_type=principal_type, resource_display_name=resource_display_name, resource_id=resource_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_app_role_assignment.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAppRoleAssignment')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAppRoleAssignment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_app_role_assignment.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignments'}  # type: ignore

    async def get_app_role_assignment(
        self,
        service_principal_id: str,
        app_role_assignment_id: str,
        select: Optional[List[Union[str, "models.Enum37"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAppRoleAssignment":
        """Get appRoleAssignments from servicePrincipals.

        Get appRoleAssignments from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param app_role_assignment_id: key: id of appRoleAssignment.
        :type app_role_assignment_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum37]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAppRoleAssignment, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphAppRoleAssignment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAppRoleAssignment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_app_role_assignment.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'appRoleAssignment-id': self._serialize.url("app_role_assignment_id", app_role_assignment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAppRoleAssignment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_app_role_assignment.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignments/{appRoleAssignment-id}'}  # type: ignore

    async def update_app_role_assignment(
        self,
        service_principal_id: str,
        app_role_assignment_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        app_role_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        principal_display_name: Optional[str] = None,
        principal_id: Optional[str] = None,
        principal_type: Optional[str] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property appRoleAssignments in servicePrincipals.

        Update the navigation property appRoleAssignments in servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param app_role_assignment_id: key: id of appRoleAssignment.
        :type app_role_assignment_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param app_role_id: The identifier (id) for the app role which is assigned to the principal.
         This app role must be exposed in the appRoles property on the resource application's service
         principal (resourceId). If the resource application has not declared any app roles, a default
         app role ID of 00000000-0000-0000-0000-000000000000 can be specified to signal that the
         principal is assigned to the resource app without any specific app roles. Required on create.
         Does not support $filter.
        :type app_role_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param principal_display_name: The display name of the user, group, or service principal that
         was granted the app role assignment. Read-only. Supports $filter (eq and startswith).
        :type principal_display_name: str
        :param principal_id: The unique identifier (id) for the user, group or service principal being
         granted the app role. Required on create. Does not support $filter.
        :type principal_id: str
        :param principal_type: The type of the assigned principal. This can either be 'User', 'Group'
         or 'ServicePrincipal'. Read-only. Does not support $filter.
        :type principal_type: str
        :param resource_display_name: The display name of the resource app's service principal to which
         the assignment is made. Does not support $filter.
        :type resource_display_name: str
        :param resource_id: The unique identifier (id) for the resource service principal for which the
         assignment is made. Required on create. Supports $filter (eq only).
        :type resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAppRoleAssignment(id=id, deleted_date_time=deleted_date_time, app_role_id=app_role_id, created_date_time=created_date_time, principal_display_name=principal_display_name, principal_id=principal_id, principal_type=principal_type, resource_display_name=resource_display_name, resource_id=resource_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_app_role_assignment.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'appRoleAssignment-id': self._serialize.url("app_role_assignment_id", app_role_assignment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAppRoleAssignment')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_app_role_assignment.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignments/{appRoleAssignment-id}'}  # type: ignore

    async def delete_app_role_assignment(
        self,
        service_principal_id: str,
        app_role_assignment_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property appRoleAssignments for servicePrincipals.

        Delete navigation property appRoleAssignments for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param app_role_assignment_id: key: id of appRoleAssignment.
        :type app_role_assignment_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_app_role_assignment.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'appRoleAssignment-id': self._serialize.url("app_role_assignment_id", app_role_assignment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_app_role_assignment.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/appRoleAssignments/{appRoleAssignment-id}'}  # type: ignore

    def list_claim_mapping_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum38"]]] = None,
        select: Optional[List[Union[str, "models.Enum39"]]] = None,
        expand: Optional[List[Union[str, "models.Enum40"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfClaimsMappingPolicy"]:
        """Get claimsMappingPolicies from servicePrincipals.

        Get claimsMappingPolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum38]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum39]
        :param expand: Expand related entities.
        :type expand: list[str or ~applications.models.Enum40]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfClaimsMappingPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfClaimsMappingPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_claim_mapping_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfClaimsMappingPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_claim_mapping_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/claimsMappingPolicies'}  # type: ignore

    def list_ref_claim_mapping_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum41"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfClaimsMappingPolicy"]:
        """Get ref of claimsMappingPolicies from servicePrincipals.

        Get ref of claimsMappingPolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum41]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfClaimsMappingPolicy or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfClaimsMappingPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_claim_mapping_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfClaimsMappingPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_claim_mapping_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/claimsMappingPolicies/$ref'}  # type: ignore

    async def create_ref_claim_mapping_policy(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to claimsMappingPolicies for servicePrincipals.

        Create new navigation property ref to claimsMappingPolicies for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_claim_mapping_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/claimsMappingPolicies/$ref'}  # type: ignore

    def list_created_object(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum42"]]] = None,
        select: Optional[List[Union[str, "models.Enum43"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDirectoryObject0"]:
        """Get createdObjects from servicePrincipals.

        Get createdObjects from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum42]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum43]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDirectoryObject0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfDirectoryObject0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDirectoryObject0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_created_object.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDirectoryObject0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_created_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/createdObjects'}  # type: ignore

    def list_ref_created_object(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum44"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfDirectoryObject0"]:
        """Get ref of createdObjects from servicePrincipals.

        Get ref of createdObjects from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum44]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfDirectoryObject0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfDirectoryObject0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfDirectoryObject0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_created_object.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfDirectoryObject0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_created_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/createdObjects/$ref'}  # type: ignore

    async def create_ref_created_object(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to createdObjects for servicePrincipals.

        Create new navigation property ref to createdObjects for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_created_object.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_created_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/createdObjects/$ref'}  # type: ignore

    def list_endpoint(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum45"]]] = None,
        select: Optional[List[Union[str, "models.Enum46"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEndpoint"]:
        """Get endpoints from servicePrincipals.

        Get endpoints from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum45]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum46]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEndpoint or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfEndpoint]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEndpoint"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_endpoint.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEndpoint', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_endpoint.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/endpoints'}  # type: ignore

    async def create_endpoint(
        self,
        service_principal_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        capability: Optional[str] = None,
        provider_id: Optional[str] = None,
        provider_name: Optional[str] = None,
        provider_resource_id: Optional[str] = None,
        uri: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEndpoint":
        """Create new navigation property to endpoints for servicePrincipals.

        Create new navigation property to endpoints for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param capability: Describes the capability that is associated with this resource. (e.g.
         Messages, Conversations, etc.)  Not nullable. Read-only.
        :type capability: str
        :param provider_id: Application id of the publishing underlying service. Not nullable. Read-
         only.
        :type provider_id: str
        :param provider_name: Name of the publishing underlying service. Read-only.
        :type provider_name: str
        :param provider_resource_id: For Microsoft 365 groups, this is set to a well-known name for the
         resource (e.g. Yammer.FeedURL etc.). Not nullable. Read-only.
        :type provider_resource_id: str
        :param uri: URL of the published resource. Not nullable. Read-only.
        :type uri: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEndpoint, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphEndpoint
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEndpoint"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEndpoint(id=id, deleted_date_time=deleted_date_time, capability=capability, provider_id=provider_id, provider_name=provider_name, provider_resource_id=provider_resource_id, uri=uri)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_endpoint.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEndpoint')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEndpoint', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_endpoint.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/endpoints'}  # type: ignore

    async def get_endpoint(
        self,
        service_principal_id: str,
        endpoint_id: str,
        select: Optional[List[Union[str, "models.Enum47"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEndpoint":
        """Get endpoints from servicePrincipals.

        Get endpoints from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param endpoint_id: key: id of endpoint.
        :type endpoint_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum47]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEndpoint, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphEndpoint
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEndpoint"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_endpoint.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'endpoint-id': self._serialize.url("endpoint_id", endpoint_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEndpoint', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_endpoint.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/endpoints/{endpoint-id}'}  # type: ignore

    async def update_endpoint(
        self,
        service_principal_id: str,
        endpoint_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        capability: Optional[str] = None,
        provider_id: Optional[str] = None,
        provider_name: Optional[str] = None,
        provider_resource_id: Optional[str] = None,
        uri: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property endpoints in servicePrincipals.

        Update the navigation property endpoints in servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param endpoint_id: key: id of endpoint.
        :type endpoint_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param capability: Describes the capability that is associated with this resource. (e.g.
         Messages, Conversations, etc.)  Not nullable. Read-only.
        :type capability: str
        :param provider_id: Application id of the publishing underlying service. Not nullable. Read-
         only.
        :type provider_id: str
        :param provider_name: Name of the publishing underlying service. Read-only.
        :type provider_name: str
        :param provider_resource_id: For Microsoft 365 groups, this is set to a well-known name for the
         resource (e.g. Yammer.FeedURL etc.). Not nullable. Read-only.
        :type provider_resource_id: str
        :param uri: URL of the published resource. Not nullable. Read-only.
        :type uri: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEndpoint(id=id, deleted_date_time=deleted_date_time, capability=capability, provider_id=provider_id, provider_name=provider_name, provider_resource_id=provider_resource_id, uri=uri)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_endpoint.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'endpoint-id': self._serialize.url("endpoint_id", endpoint_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEndpoint')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_endpoint.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/endpoints/{endpoint-id}'}  # type: ignore

    async def delete_endpoint(
        self,
        service_principal_id: str,
        endpoint_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property endpoints for servicePrincipals.

        Delete navigation property endpoints for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param endpoint_id: key: id of endpoint.
        :type endpoint_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_endpoint.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
            'endpoint-id': self._serialize.url("endpoint_id", endpoint_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_endpoint.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/endpoints/{endpoint-id}'}  # type: ignore

    def list_home_realm_discovery_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum48"]]] = None,
        select: Optional[List[Union[str, "models.Enum49"]]] = None,
        expand: Optional[List[Union[str, "models.Enum50"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfHomeRealmDiscoveryPolicy0"]:
        """Get homeRealmDiscoveryPolicies from servicePrincipals.

        Get homeRealmDiscoveryPolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum48]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum49]
        :param expand: Expand related entities.
        :type expand: list[str or ~applications.models.Enum50]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfHomeRealmDiscoveryPolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfHomeRealmDiscoveryPolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfHomeRealmDiscoveryPolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_home_realm_discovery_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfHomeRealmDiscoveryPolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_home_realm_discovery_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/homeRealmDiscoveryPolicies'}  # type: ignore

    def list_ref_home_realm_discovery_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum51"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfHomeRealmDiscoveryPolicy0"]:
        """Get ref of homeRealmDiscoveryPolicies from servicePrincipals.

        Get ref of homeRealmDiscoveryPolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum51]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfHomeRealmDiscoveryPolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfHomeRealmDiscoveryPolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfHomeRealmDiscoveryPolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_home_realm_discovery_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfHomeRealmDiscoveryPolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_home_realm_discovery_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/homeRealmDiscoveryPolicies/$ref'}  # type: ignore

    async def create_ref_home_realm_discovery_policy(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to homeRealmDiscoveryPolicies for servicePrincipals.

        Create new navigation property ref to homeRealmDiscoveryPolicies for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_home_realm_discovery_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/homeRealmDiscoveryPolicies/$ref'}  # type: ignore

    def list_member_of(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum52"]]] = None,
        select: Optional[List[Union[str, "models.Enum53"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDirectoryObject1"]:
        """Get memberOf from servicePrincipals.

        Get memberOf from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum52]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum53]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDirectoryObject1 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfDirectoryObject1]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDirectoryObject1"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_member_of.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDirectoryObject1', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_member_of.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/memberOf'}  # type: ignore

    def list_ref_member_of(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum54"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfDirectoryObject1"]:
        """Get ref of memberOf from servicePrincipals.

        Get ref of memberOf from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum54]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfDirectoryObject1 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfDirectoryObject1]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfDirectoryObject1"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_member_of.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfDirectoryObject1', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_member_of.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/memberOf/$ref'}  # type: ignore

    async def create_ref_member_of(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to memberOf for servicePrincipals.

        Create new navigation property ref to memberOf for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_member_of.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_member_of.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/memberOf/$ref'}  # type: ignore

    async def add_key(
        self,
        service_principal_id: str,
        key_credential: Optional["models.MicrosoftGraphKeyCredential"] = None,
        password_credential: Optional["models.MicrosoftGraphPasswordCredential"] = None,
        proof: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphKeyCredential":
        """Invoke action addKey.

        Invoke action addKey.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param key_credential: keyCredential.
        :type key_credential: ~applications.models.MicrosoftGraphKeyCredential
        :param password_credential: passwordCredential.
        :type password_credential: ~applications.models.MicrosoftGraphPasswordCredential
        :param proof:
        :type proof: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphKeyCredential, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphKeyCredential
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphKeyCredential"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsN3Fx9GServiceprincipalsServiceprincipalIdMicrosoftGraphAddkeyPostRequestbodyContentApplicationJsonSchema(key_credential=key_credential, password_credential=password_credential, proof=proof)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.add_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsN3Fx9GServiceprincipalsServiceprincipalIdMicrosoftGraphAddkeyPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphKeyCredential', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    add_key.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.addKey'}  # type: ignore

    async def add_password(
        self,
        service_principal_id: str,
        password_credential: Optional["models.MicrosoftGraphPasswordCredential"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPasswordCredential":
        """Invoke action addPassword.

        Invoke action addPassword.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param password_credential: passwordCredential.
        :type password_credential: ~applications.models.MicrosoftGraphPasswordCredential
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPasswordCredential, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphPasswordCredential
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPasswordCredential"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsIeboplServiceprincipalsServiceprincipalIdMicrosoftGraphAddpasswordPostRequestbodyContentApplicationJsonSchema(password_credential=password_credential)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.add_password.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsIeboplServiceprincipalsServiceprincipalIdMicrosoftGraphAddpasswordPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPasswordCredential', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    add_password.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.addPassword'}  # type: ignore

    async def check_member_group(
        self,
        service_principal_id: str,
        group_ids: Optional[List[str]] = None,
        **kwargs
    ) -> List[str]:
        """Invoke action checkMemberGroups.

        Invoke action checkMemberGroups.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param group_ids:
        :type group_ids: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsO5Kx2YServiceprincipalsServiceprincipalIdMicrosoftGraphCheckmembergroupsPostRequestbodyContentApplicationJsonSchema(group_ids=group_ids)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.check_member_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsO5Kx2YServiceprincipalsServiceprincipalIdMicrosoftGraphCheckmembergroupsPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    check_member_group.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.checkMemberGroups'}  # type: ignore

    async def check_member_object(
        self,
        service_principal_id: str,
        ids: Optional[List[str]] = None,
        **kwargs
    ) -> List[str]:
        """Invoke action checkMemberObjects.

        Invoke action checkMemberObjects.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param ids:
        :type ids: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1Ffhl47ServiceprincipalsServiceprincipalIdMicrosoftGraphCheckmemberobjectsPostRequestbodyContentApplicationJsonSchema(ids=ids)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.check_member_object.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1Ffhl47ServiceprincipalsServiceprincipalIdMicrosoftGraphCheckmemberobjectsPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    check_member_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.checkMemberObjects'}  # type: ignore

    async def get_member_group(
        self,
        service_principal_id: str,
        security_enabled_only: Optional[bool] = False,
        **kwargs
    ) -> List[str]:
        """Invoke action getMemberGroups.

        Invoke action getMemberGroups.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param security_enabled_only:
        :type security_enabled_only: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1850388ServiceprincipalsServiceprincipalIdMicrosoftGraphGetmembergroupsPostRequestbodyContentApplicationJsonSchema(security_enabled_only=security_enabled_only)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.get_member_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1850388ServiceprincipalsServiceprincipalIdMicrosoftGraphGetmembergroupsPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_member_group.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.getMemberGroups'}  # type: ignore

    async def get_member_object(
        self,
        service_principal_id: str,
        security_enabled_only: Optional[bool] = False,
        **kwargs
    ) -> List[str]:
        """Invoke action getMemberObjects.

        Invoke action getMemberObjects.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param security_enabled_only:
        :type security_enabled_only: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of str, or the result of cls(response)
        :rtype: list[str]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List[str]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1Md6PmhServiceprincipalsServiceprincipalIdMicrosoftGraphGetmemberobjectsPostRequestbodyContentApplicationJsonSchema(security_enabled_only=security_enabled_only)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.get_member_object.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1Md6PmhServiceprincipalsServiceprincipalIdMicrosoftGraphGetmemberobjectsPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[str]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_member_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.getMemberObjects'}  # type: ignore

    async def remove_key(
        self,
        service_principal_id: str,
        key_id: Optional[str] = None,
        proof: Optional[str] = None,
        **kwargs
    ) -> None:
        """Invoke action removeKey.

        Invoke action removeKey.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param key_id:
        :type key_id: str
        :param proof:
        :type proof: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1UhuhlbServiceprincipalsServiceprincipalIdMicrosoftGraphRemovekeyPostRequestbodyContentApplicationJsonSchema(key_id=key_id, proof=proof)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.remove_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1UhuhlbServiceprincipalsServiceprincipalIdMicrosoftGraphRemovekeyPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    remove_key.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.removeKey'}  # type: ignore

    async def remove_password(
        self,
        service_principal_id: str,
        key_id: Optional[str] = None,
        **kwargs
    ) -> None:
        """Invoke action removePassword.

        Invoke action removePassword.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param key_id:
        :type key_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1Idoj4GServiceprincipalsServiceprincipalIdMicrosoftGraphRemovepasswordPostRequestbodyContentApplicationJsonSchema(key_id=key_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.remove_password.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1Idoj4GServiceprincipalsServiceprincipalIdMicrosoftGraphRemovepasswordPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    remove_password.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.removePassword'}  # type: ignore

    async def restore(
        self,
        service_principal_id: str,
        **kwargs
    ) -> "models.MicrosoftGraphDirectoryObject":
        """Invoke action restore.

        Invoke action restore.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDirectoryObject, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphDirectoryObject
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDirectoryObject"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.restore.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDirectoryObject', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    restore.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/microsoft.graph.restore'}  # type: ignore

    def list_oauth2_permission_grant(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum55"]]] = None,
        select: Optional[List[Union[str, "models.Enum56"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfOAuth2PermissionGrant"]:
        """Get oauth2PermissionGrants from servicePrincipals.

        Get oauth2PermissionGrants from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum55]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum56]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfOAuth2PermissionGrant or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfOAuth2PermissionGrant]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfOAuth2PermissionGrant"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_oauth2_permission_grant.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfOAuth2PermissionGrant', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_oauth2_permission_grant.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/oauth2PermissionGrants'}  # type: ignore

    def list_ref_oauth2_permission_grant(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum57"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfOAuth2PermissionGrant"]:
        """Get ref of oauth2PermissionGrants from servicePrincipals.

        Get ref of oauth2PermissionGrants from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum57]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfOAuth2PermissionGrant or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfOAuth2PermissionGrant]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfOAuth2PermissionGrant"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_oauth2_permission_grant.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfOAuth2PermissionGrant', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_oauth2_permission_grant.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/oauth2PermissionGrants/$ref'}  # type: ignore

    async def create_ref_oauth2_permission_grant(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to oauth2PermissionGrants for servicePrincipals.

        Create new navigation property ref to oauth2PermissionGrants for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_oauth2_permission_grant.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_oauth2_permission_grant.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/oauth2PermissionGrants/$ref'}  # type: ignore

    def list_owned_object(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum58"]]] = None,
        select: Optional[List[Union[str, "models.Enum59"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDirectoryObject2"]:
        """Get ownedObjects from servicePrincipals.

        Get ownedObjects from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum58]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum59]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDirectoryObject2 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfDirectoryObject2]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDirectoryObject2"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_owned_object.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDirectoryObject2', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_owned_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/ownedObjects'}  # type: ignore

    def list_ref_owned_object(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum60"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfDirectoryObject2"]:
        """Get ref of ownedObjects from servicePrincipals.

        Get ref of ownedObjects from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum60]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfDirectoryObject2 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfDirectoryObject2]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfDirectoryObject2"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_owned_object.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfDirectoryObject2', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_owned_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/ownedObjects/$ref'}  # type: ignore

    async def create_ref_owned_object(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to ownedObjects for servicePrincipals.

        Create new navigation property ref to ownedObjects for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_owned_object.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_owned_object.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/ownedObjects/$ref'}  # type: ignore

    def list_owner(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum61"]]] = None,
        select: Optional[List[Union[str, "models.Enum62"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDirectoryObject3"]:
        """Get owners from servicePrincipals.

        Get owners from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum61]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum62]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDirectoryObject3 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfDirectoryObject3]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDirectoryObject3"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_owner.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDirectoryObject3', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_owner.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/owners'}  # type: ignore

    def list_ref_owner(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum63"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfDirectoryObject3"]:
        """Get ref of owners from servicePrincipals.

        Get ref of owners from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum63]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfDirectoryObject3 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfDirectoryObject3]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfDirectoryObject3"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_owner.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfDirectoryObject3', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_owner.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/owners/$ref'}  # type: ignore

    async def create_ref_owner(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to owners for servicePrincipals.

        Create new navigation property ref to owners for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_owner.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_owner.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/owners/$ref'}  # type: ignore

    def list_token_issuance_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum64"]]] = None,
        select: Optional[List[Union[str, "models.Enum65"]]] = None,
        expand: Optional[List[Union[str, "models.Enum66"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTokenIssuancePolicy0"]:
        """Get tokenIssuancePolicies from servicePrincipals.

        Get tokenIssuancePolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum64]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum65]
        :param expand: Expand related entities.
        :type expand: list[str or ~applications.models.Enum66]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenIssuancePolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfTokenIssuancePolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenIssuancePolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_issuance_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenIssuancePolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_token_issuance_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/tokenIssuancePolicies'}  # type: ignore

    def list_ref_token_issuance_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum67"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfTokenIssuancePolicy0"]:
        """Get ref of tokenIssuancePolicies from servicePrincipals.

        Get ref of tokenIssuancePolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum67]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfTokenIssuancePolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfTokenIssuancePolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfTokenIssuancePolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_token_issuance_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfTokenIssuancePolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_token_issuance_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/tokenIssuancePolicies/$ref'}  # type: ignore

    async def create_ref_token_issuance_policy(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to tokenIssuancePolicies for servicePrincipals.

        Create new navigation property ref to tokenIssuancePolicies for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_token_issuance_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/tokenIssuancePolicies/$ref'}  # type: ignore

    def list_token_lifetime_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum68"]]] = None,
        select: Optional[List[Union[str, "models.Enum69"]]] = None,
        expand: Optional[List[Union[str, "models.Enum70"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTokenLifetimePolicy0"]:
        """Get tokenLifetimePolicies from servicePrincipals.

        Get tokenLifetimePolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum68]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum69]
        :param expand: Expand related entities.
        :type expand: list[str or ~applications.models.Enum70]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenLifetimePolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfTokenLifetimePolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenLifetimePolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_lifetime_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenLifetimePolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_token_lifetime_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/tokenLifetimePolicies'}  # type: ignore

    def list_ref_token_lifetime_policy(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum71"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfTokenLifetimePolicy0"]:
        """Get ref of tokenLifetimePolicies from servicePrincipals.

        Get ref of tokenLifetimePolicies from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum71]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfTokenLifetimePolicy0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfTokenLifetimePolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfTokenLifetimePolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_token_lifetime_policy.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfTokenLifetimePolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_token_lifetime_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/tokenLifetimePolicies/$ref'}  # type: ignore

    async def create_ref_token_lifetime_policy(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to tokenLifetimePolicies for servicePrincipals.

        Create new navigation property ref to tokenLifetimePolicies for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_token_lifetime_policy.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/tokenLifetimePolicies/$ref'}  # type: ignore

    def list_transitive_member_of(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum72"]]] = None,
        select: Optional[List[Union[str, "models.Enum73"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDirectoryObject4"]:
        """Get transitiveMemberOf from servicePrincipals.

        Get transitiveMemberOf from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum72]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Enum73]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDirectoryObject4 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfDirectoryObject4]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDirectoryObject4"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_transitive_member_of.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDirectoryObject4', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_transitive_member_of.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/transitiveMemberOf'}  # type: ignore

    def list_ref_transitive_member_of(
        self,
        service_principal_id: str,
        orderby: Optional[List[Union[str, "models.Enum74"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfDirectoryObject4"]:
        """Get ref of transitiveMemberOf from servicePrincipals.

        Get ref of transitiveMemberOf from servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Enum74]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfDirectoryObject4 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfLinksOfDirectoryObject4]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfDirectoryObject4"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_transitive_member_of.metadata['url']  # type: ignore
                path_format_arguments = {
                    'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfDirectoryObject4', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_transitive_member_of.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/transitiveMemberOf/$ref'}  # type: ignore

    async def create_ref_transitive_member_of(
        self,
        service_principal_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to transitiveMemberOf for servicePrincipals.

        Create new navigation property ref to transitiveMemberOf for servicePrincipals.

        :param service_principal_id: key: id of servicePrincipal.
        :type service_principal_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_transitive_member_of.metadata['url']  # type: ignore
        path_format_arguments = {
            'servicePrincipal-id': self._serialize.url("service_principal_id", service_principal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_transitive_member_of.metadata = {'url': '/servicePrincipals/{servicePrincipal-id}/transitiveMemberOf/$ref'}  # type: ignore

    async def delta(
        self,
        **kwargs
    ) -> List["models.MicrosoftGraphServicePrincipal"]:
        """Invoke function delta.

        Invoke function delta.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphServicePrincipal, or the result of cls(response)
        :rtype: list[~applications.models.MicrosoftGraphServicePrincipal]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphServicePrincipal"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delta.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphServicePrincipal]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delta.metadata = {'url': '/servicePrincipals/microsoft.graph.delta()'}  # type: ignore

    async def get_available_extension_property(
        self,
        is_synced_from_on_premises: Optional[bool] = False,
        **kwargs
    ) -> List["models.MicrosoftGraphExtensionProperty"]:
        """Invoke action getAvailableExtensionProperties.

        Invoke action getAvailableExtensionProperties.

        :param is_synced_from_on_premises:
        :type is_synced_from_on_premises: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphExtensionProperty, or the result of cls(response)
        :rtype: list[~applications.models.MicrosoftGraphExtensionProperty]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphExtensionProperty"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsGo2T4HServiceprincipalsMicrosoftGraphGetavailableextensionpropertiesPostRequestbodyContentApplicationJsonSchema(is_synced_from_on_premises=is_synced_from_on_premises)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.get_available_extension_property.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsGo2T4HServiceprincipalsMicrosoftGraphGetavailableextensionpropertiesPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphExtensionProperty]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_available_extension_property.metadata = {'url': '/servicePrincipals/microsoft.graph.getAvailableExtensionProperties'}  # type: ignore

    async def get_by_id(
        self,
        ids: Optional[List[str]] = None,
        types: Optional[List[str]] = None,
        **kwargs
    ) -> List["models.MicrosoftGraphDirectoryObject"]:
        """Invoke action getByIds.

        Invoke action getByIds.

        :param ids:
        :type ids: list[str]
        :param types:
        :type types: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphDirectoryObject, or the result of cls(response)
        :rtype: list[~applications.models.MicrosoftGraphDirectoryObject]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphDirectoryObject"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths15YkyvsServiceprincipalsMicrosoftGraphGetbyidsPostRequestbodyContentApplicationJsonSchema(ids=ids, types=types)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.get_by_id.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths15YkyvsServiceprincipalsMicrosoftGraphGetbyidsPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphDirectoryObject]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_by_id.metadata = {'url': '/servicePrincipals/microsoft.graph.getByIds'}  # type: ignore

    async def validate_property(
        self,
        entity_type: Optional[str] = None,
        display_name: Optional[str] = None,
        mail_nickname: Optional[str] = None,
        on_behalf_of_user_id: Optional[str] = None,
        **kwargs
    ) -> None:
        """Invoke action validateProperties.

        Invoke action validateProperties.

        :param entity_type:
        :type entity_type: str
        :param display_name:
        :type display_name: str
        :param mail_nickname:
        :type mail_nickname: str
        :param on_behalf_of_user_id:
        :type on_behalf_of_user_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsYq15M4ServiceprincipalsMicrosoftGraphValidatepropertiesPostRequestbodyContentApplicationJsonSchema(entity_type=entity_type, display_name=display_name, mail_nickname=mail_nickname, on_behalf_of_user_id=on_behalf_of_user_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.validate_property.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsYq15M4ServiceprincipalsMicrosoftGraphValidatepropertiesPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    validate_property.metadata = {'url': '/servicePrincipals/microsoft.graph.validateProperties'}  # type: ignore
