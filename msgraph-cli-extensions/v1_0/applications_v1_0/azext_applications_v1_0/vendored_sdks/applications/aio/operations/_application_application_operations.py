# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class ApplicationApplicationOperations:
    """ApplicationApplicationOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~applications.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_application(
        self,
        orderby: Optional[List[Union[str, "models.Get5ItemsItem"]]] = None,
        select: Optional[List[Union[str, "models.Get6ItemsItem"]]] = None,
        expand: Optional[List[Union[str, "models.Get7ItemsItem"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfApplication"]:
        """Get entities from applications.

        Get entities from applications.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~applications.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str or ~applications.models.Get7ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfApplication or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~applications.models.CollectionOfApplication]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfApplication"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_application.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfApplication', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_application.metadata = {'url': '/applications'}  # type: ignore

    async def create_application(
        self,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        add_ins: Optional[List["models.MicrosoftGraphAddIn"]] = None,
        app_id: Optional[str] = None,
        application_template_id: Optional[str] = None,
        app_roles: Optional[List["models.MicrosoftGraphAppRole"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        group_membership_claims: Optional[str] = None,
        identifier_uris: Optional[List[str]] = None,
        info: Optional["models.MicrosoftGraphInformationalUrl"] = None,
        is_device_only_auth_supported: Optional[bool] = None,
        is_fallback_public_client: Optional[bool] = None,
        key_credentials: Optional[List["models.MicrosoftGraphKeyCredential"]] = None,
        logo: Optional[bytes] = None,
        notes: Optional[str] = None,
        oauth2_require_post_response: Optional[bool] = None,
        parental_control_settings: Optional["models.MicrosoftGraphParentalControlSettings"] = None,
        password_credentials: Optional[List["models.MicrosoftGraphPasswordCredential"]] = None,
        public_client: Optional["models.MicrosoftGraphPublicClientApplication"] = None,
        publisher_domain: Optional[str] = None,
        required_resource_access: Optional[List["models.MicrosoftGraphRequiredResourceAccess"]] = None,
        sign_in_audience: Optional[str] = None,
        tags: Optional[List[str]] = None,
        token_encryption_key_id: Optional[str] = None,
        created_on_behalf_of: Optional["models.MicrosoftGraphDirectoryObject"] = None,
        extension_properties: Optional[List["models.MicrosoftGraphExtensionProperty"]] = None,
        home_realm_discovery_policies: Optional[List["models.MicrosoftGraphHomeRealmDiscoveryPolicy"]] = None,
        owners: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        token_issuance_policies: Optional[List["models.MicrosoftGraphTokenIssuancePolicy"]] = None,
        token_lifetime_policies: Optional[List["models.MicrosoftGraphTokenLifetimePolicy"]] = None,
        home_page_url: Optional[str] = None,
        implicit_grant_settings: Optional["models.MicrosoftGraphImplicitGrantSettings"] = None,
        logout_url: Optional[str] = None,
        redirect_uris: Optional[List[str]] = None,
        access_token: Optional[List["models.MicrosoftGraphOptionalClaim"]] = None,
        id_token: Optional[List["models.MicrosoftGraphOptionalClaim"]] = None,
        saml2_token: Optional[List["models.MicrosoftGraphOptionalClaim"]] = None,
        accept_mapped_claims: Optional[bool] = None,
        known_client_applications: Optional[List[str]] = None,
        oauth2_permission_scopes: Optional[List["models.MicrosoftGraphPermissionScope"]] = None,
        pre_authorized_applications: Optional[List["models.MicrosoftGraphPreAuthorizedApplication"]] = None,
        requested_access_token_version: Optional[int] = None,
        **kwargs
    ) -> "models.MicrosoftGraphApplication":
        """Add new entity to applications.

        Add new entity to applications.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param add_ins: Defines custom behavior that a consuming service can use to call an app in
         specific contexts. For example, applications that can render file streams may set the addIns
         property for its 'FileHandler' functionality. This will let services like Microsoft 365 call
         the application in the context of a document the user is working on.
        :type add_ins: list[~applications.models.MicrosoftGraphAddIn]
        :param app_id: The unique identifier for the application that is assigned to an application by
         Azure AD. Not nullable. Read-only.
        :type app_id: str
        :param application_template_id:
        :type application_template_id: str
        :param app_roles: The collection of roles the application declares. With app role assignments,
         these roles can be assigned to users, groups, or other applications' service principals. Not
         nullable.
        :type app_roles: list[~applications.models.MicrosoftGraphAppRole]
        :param created_date_time: The date and time the application was registered. Read-only.
        :type created_date_time: ~datetime.datetime
        :param description:
        :type description: str
        :param display_name: The display name for the application.
        :type display_name: str
        :param group_membership_claims: Configures the groups claim issued in a user or OAuth 2.0
         access token that the application expects. To set this attribute, use one of the following
         valid string values:NoneSecurityGroup: For security groups and Azure AD rolesAll: This will get
         all of the security groups, distribution groups, and Azure AD directory roles that the signed-
         in user is a member of.
        :type group_membership_claims: str
        :param identifier_uris: The URIs that identify the application within its Azure AD tenant, or
         within a verified custom domain if the application is multi-tenant. For more information see
         Application Objects and Service Principal Objects. The any operator is required for filter
         expressions on multi-valued properties. Not nullable.
        :type identifier_uris: list[str]
        :param info: informationalUrl.
        :type info: ~applications.models.MicrosoftGraphInformationalUrl
        :param is_device_only_auth_supported:
        :type is_device_only_auth_supported: bool
        :param is_fallback_public_client: Specifies the fallback application type as public client,
         such as an installed application running on a mobile device. The default value is false which
         means the fallback application type is confidential client such as web app. There are certain
         scenarios where Azure AD cannot determine the client application type (e.g. ROPC flow where it
         is configured without specifying a redirect URI). In those cases Azure AD will interpret the
         application type based on the value of this property.
        :type is_fallback_public_client: bool
        :param key_credentials: The collection of key credentials associated with the application Not
         nullable.
        :type key_credentials: list[~applications.models.MicrosoftGraphKeyCredential]
        :param logo: The main logo for the application. Not nullable.
        :type logo: bytes
        :param notes:
        :type notes: str
        :param oauth2_require_post_response:
        :type oauth2_require_post_response: bool
        :param parental_control_settings: parentalControlSettings.
        :type parental_control_settings: ~applications.models.MicrosoftGraphParentalControlSettings
        :param password_credentials: The collection of password credentials associated with the
         application. Not nullable.
        :type password_credentials: list[~applications.models.MicrosoftGraphPasswordCredential]
        :param public_client: publicClientApplication.
        :type public_client: ~applications.models.MicrosoftGraphPublicClientApplication
        :param publisher_domain: The verified publisher domain for the application. Read-only.
        :type publisher_domain: str
        :param required_resource_access: Specifies resources that this application requires access to
         and the set of OAuth permission scopes and application roles that it needs under each of those
         resources. This pre-configuration of required resource access drives the consent experience.
         Not nullable.
        :type required_resource_access: list[~applications.models.MicrosoftGraphRequiredResourceAccess]
        :param sign_in_audience: Specifies the Microsoft accounts that are supported for the current
         application. Supported values are:AzureADMyOrg: Users with a Microsoft work or school account
         in my organization’s Azure AD tenant (single tenant)AzureADMultipleOrgs: Users with a Microsoft
         work or school account in any organization’s Azure AD tenant (multi-
         tenant)AzureADandPersonalMicrosoftAccount: Users with a personal Microsoft account, or a work
         or school account in any organization’s Azure AD tenant.
        :type sign_in_audience: str
        :param tags: Custom strings that can be used to categorize and identify the application. Not
         nullable.
        :type tags: list[str]
        :param token_encryption_key_id: Specifies the keyId of a public key from the keyCredentials
         collection. When configured, Azure AD encrypts all the tokens it emits by using the key this
         property points to. The application code that receives the encrypted token must use the
         matching private key to decrypt the token before it can be used for the signed-in user.
        :type token_encryption_key_id: str
        :param created_on_behalf_of: Represents an Azure Active Directory object. The directoryObject
         type is the base type for many other directory entity types.
        :type created_on_behalf_of: ~applications.models.MicrosoftGraphDirectoryObject
        :param extension_properties: Read-only. Nullable.
        :type extension_properties: list[~applications.models.MicrosoftGraphExtensionProperty]
        :param home_realm_discovery_policies:
        :type home_realm_discovery_policies: list[~applications.models.MicrosoftGraphHomeRealmDiscoveryPolicy]
        :param owners: Directory objects that are owners of the application. The owners are a set of
         non-admin users who are allowed to modify this object. Requires version 2013-11-08 or newer.
         Read-only. Nullable.
        :type owners: list[~applications.models.MicrosoftGraphDirectoryObject]
        :param token_issuance_policies:
        :type token_issuance_policies: list[~applications.models.MicrosoftGraphTokenIssuancePolicy]
        :param token_lifetime_policies:
        :type token_lifetime_policies: list[~applications.models.MicrosoftGraphTokenLifetimePolicy]
        :param home_page_url: Home page or landing page of the application.
        :type home_page_url: str
        :param implicit_grant_settings: implicitGrantSettings.
        :type implicit_grant_settings: ~applications.models.MicrosoftGraphImplicitGrantSettings
        :param logout_url: Specifies the URL that will be used by Microsoft's authorization service to
         logout an user using front-channel, back-channel or SAML logout protocols.
        :type logout_url: str
        :param redirect_uris: Specifies the URLs where user tokens are sent for sign-in, or the
         redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
        :type redirect_uris: list[str]
        :param access_token: The optional claims returned in the JWT access token.
        :type access_token: list[~applications.models.MicrosoftGraphOptionalClaim]
        :param id_token: The optional claims returned in the JWT ID token.
        :type id_token: list[~applications.models.MicrosoftGraphOptionalClaim]
        :param saml2_token: The optional claims returned in the SAML token.
        :type saml2_token: list[~applications.models.MicrosoftGraphOptionalClaim]
        :param accept_mapped_claims: When true, allows an application to use claims mapping without
         specifying a custom signing key.
        :type accept_mapped_claims: bool
        :param known_client_applications: Used for bundling consent if you have a solution that
         contains two parts: a client app and a custom web API app. If you set the appID of the client
         app to this value, the user only consents once to the client app. Azure AD knows that
         consenting to the client means implicitly consenting to the web API and automatically
         provisions service principals for both APIs at the same time. Both the client and the web API
         app must be registered in the same tenant.
        :type known_client_applications: list[str]
        :param oauth2_permission_scopes: The definition of the delegated permissions exposed by the web
         API represented by this application registration. These delegated permissions may be requested
         by a client application, and may be granted by users or administrators during consent.
         Delegated permissions are sometimes referred to as OAuth 2.0 scopes.
        :type oauth2_permission_scopes: list[~applications.models.MicrosoftGraphPermissionScope]
        :param pre_authorized_applications: Lists the client applications that are pre-authorized with
         the specified delegated permissions to access this application's APIs. Users are not required
         to consent to any pre-authorized application (for the permissions specified). However, any
         additional permissions not listed in preAuthorizedApplications (requested through incremental
         consent for example) will require user consent.
        :type pre_authorized_applications: list[~applications.models.MicrosoftGraphPreAuthorizedApplication]
        :param requested_access_token_version: Specifies the access token version expected by this
         resource. This changes the version and format of the JWT produced independent of the endpoint
         or client used to request the access token.  The endpoint used, v1.0 or v2.0, is chosen by the
         client and only impacts the version of id_tokens. Resources need to explicitly configure
         requestedAccessTokenVersion to indicate the supported access token format.  Possible values for
         requestedAccessTokenVersion are 1, 2, or null. If the value is null, this defaults to 1, which
         corresponds to the v1.0 endpoint.  If signInAudience on the application is configured as
         AzureADandPersonalMicrosoftAccount, the value for this property must be 2.
        :type requested_access_token_version: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphApplication, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphApplication
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphApplication"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphApplication(id=id, deleted_date_time=deleted_date_time, add_ins=add_ins, app_id=app_id, application_template_id=application_template_id, app_roles=app_roles, created_date_time=created_date_time, description=description, display_name=display_name, group_membership_claims=group_membership_claims, identifier_uris=identifier_uris, info=info, is_device_only_auth_supported=is_device_only_auth_supported, is_fallback_public_client=is_fallback_public_client, key_credentials=key_credentials, logo=logo, notes=notes, oauth2_require_post_response=oauth2_require_post_response, parental_control_settings=parental_control_settings, password_credentials=password_credentials, public_client=public_client, publisher_domain=publisher_domain, required_resource_access=required_resource_access, sign_in_audience=sign_in_audience, tags=tags, token_encryption_key_id=token_encryption_key_id, created_on_behalf_of=created_on_behalf_of, extension_properties=extension_properties, home_realm_discovery_policies=home_realm_discovery_policies, owners=owners, token_issuance_policies=token_issuance_policies, token_lifetime_policies=token_lifetime_policies, home_page_url=home_page_url, implicit_grant_settings=implicit_grant_settings, logout_url=logout_url, redirect_uris=redirect_uris, access_token=access_token, id_token=id_token, saml2_token=saml2_token, accept_mapped_claims=accept_mapped_claims, known_client_applications=known_client_applications, oauth2_permission_scopes=oauth2_permission_scopes, pre_authorized_applications=pre_authorized_applications, requested_access_token_version=requested_access_token_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_application.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphApplication')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphApplication', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_application.metadata = {'url': '/applications'}  # type: ignore

    async def get_application(
        self,
        application_id: str,
        select: Optional[List[Union[str, "models.Get1ItemsItem"]]] = None,
        expand: Optional[List[Union[str, "models.Get2ItemsItem"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphApplication":
        """Get entity from applications by key.

        Get entity from applications by key.

        :param application_id: key: id of application.
        :type application_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~applications.models.Get1ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str or ~applications.models.Get2ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphApplication, or the result of cls(response)
        :rtype: ~applications.models.MicrosoftGraphApplication
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphApplication"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_application.metadata['url']  # type: ignore
        path_format_arguments = {
            'application-id': self._serialize.url("application_id", application_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphApplication', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_application.metadata = {'url': '/applications/{application-id}'}  # type: ignore

    async def update_application(
        self,
        application_id: str,
        id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        add_ins: Optional[List["models.MicrosoftGraphAddIn"]] = None,
        app_id: Optional[str] = None,
        application_template_id: Optional[str] = None,
        app_roles: Optional[List["models.MicrosoftGraphAppRole"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        group_membership_claims: Optional[str] = None,
        identifier_uris: Optional[List[str]] = None,
        info: Optional["models.MicrosoftGraphInformationalUrl"] = None,
        is_device_only_auth_supported: Optional[bool] = None,
        is_fallback_public_client: Optional[bool] = None,
        key_credentials: Optional[List["models.MicrosoftGraphKeyCredential"]] = None,
        logo: Optional[bytes] = None,
        notes: Optional[str] = None,
        oauth2_require_post_response: Optional[bool] = None,
        parental_control_settings: Optional["models.MicrosoftGraphParentalControlSettings"] = None,
        password_credentials: Optional[List["models.MicrosoftGraphPasswordCredential"]] = None,
        public_client: Optional["models.MicrosoftGraphPublicClientApplication"] = None,
        publisher_domain: Optional[str] = None,
        required_resource_access: Optional[List["models.MicrosoftGraphRequiredResourceAccess"]] = None,
        sign_in_audience: Optional[str] = None,
        tags: Optional[List[str]] = None,
        token_encryption_key_id: Optional[str] = None,
        created_on_behalf_of: Optional["models.MicrosoftGraphDirectoryObject"] = None,
        extension_properties: Optional[List["models.MicrosoftGraphExtensionProperty"]] = None,
        home_realm_discovery_policies: Optional[List["models.MicrosoftGraphHomeRealmDiscoveryPolicy"]] = None,
        owners: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        token_issuance_policies: Optional[List["models.MicrosoftGraphTokenIssuancePolicy"]] = None,
        token_lifetime_policies: Optional[List["models.MicrosoftGraphTokenLifetimePolicy"]] = None,
        home_page_url: Optional[str] = None,
        implicit_grant_settings: Optional["models.MicrosoftGraphImplicitGrantSettings"] = None,
        logout_url: Optional[str] = None,
        redirect_uris: Optional[List[str]] = None,
        access_token: Optional[List["models.MicrosoftGraphOptionalClaim"]] = None,
        id_token: Optional[List["models.MicrosoftGraphOptionalClaim"]] = None,
        saml2_token: Optional[List["models.MicrosoftGraphOptionalClaim"]] = None,
        accept_mapped_claims: Optional[bool] = None,
        known_client_applications: Optional[List[str]] = None,
        oauth2_permission_scopes: Optional[List["models.MicrosoftGraphPermissionScope"]] = None,
        pre_authorized_applications: Optional[List["models.MicrosoftGraphPreAuthorizedApplication"]] = None,
        requested_access_token_version: Optional[int] = None,
        **kwargs
    ) -> None:
        """Update entity in applications.

        Update entity in applications.

        :param application_id: key: id of application.
        :type application_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param add_ins: Defines custom behavior that a consuming service can use to call an app in
         specific contexts. For example, applications that can render file streams may set the addIns
         property for its 'FileHandler' functionality. This will let services like Microsoft 365 call
         the application in the context of a document the user is working on.
        :type add_ins: list[~applications.models.MicrosoftGraphAddIn]
        :param app_id: The unique identifier for the application that is assigned to an application by
         Azure AD. Not nullable. Read-only.
        :type app_id: str
        :param application_template_id:
        :type application_template_id: str
        :param app_roles: The collection of roles the application declares. With app role assignments,
         these roles can be assigned to users, groups, or other applications' service principals. Not
         nullable.
        :type app_roles: list[~applications.models.MicrosoftGraphAppRole]
        :param created_date_time: The date and time the application was registered. Read-only.
        :type created_date_time: ~datetime.datetime
        :param description:
        :type description: str
        :param display_name: The display name for the application.
        :type display_name: str
        :param group_membership_claims: Configures the groups claim issued in a user or OAuth 2.0
         access token that the application expects. To set this attribute, use one of the following
         valid string values:NoneSecurityGroup: For security groups and Azure AD rolesAll: This will get
         all of the security groups, distribution groups, and Azure AD directory roles that the signed-
         in user is a member of.
        :type group_membership_claims: str
        :param identifier_uris: The URIs that identify the application within its Azure AD tenant, or
         within a verified custom domain if the application is multi-tenant. For more information see
         Application Objects and Service Principal Objects. The any operator is required for filter
         expressions on multi-valued properties. Not nullable.
        :type identifier_uris: list[str]
        :param info: informationalUrl.
        :type info: ~applications.models.MicrosoftGraphInformationalUrl
        :param is_device_only_auth_supported:
        :type is_device_only_auth_supported: bool
        :param is_fallback_public_client: Specifies the fallback application type as public client,
         such as an installed application running on a mobile device. The default value is false which
         means the fallback application type is confidential client such as web app. There are certain
         scenarios where Azure AD cannot determine the client application type (e.g. ROPC flow where it
         is configured without specifying a redirect URI). In those cases Azure AD will interpret the
         application type based on the value of this property.
        :type is_fallback_public_client: bool
        :param key_credentials: The collection of key credentials associated with the application Not
         nullable.
        :type key_credentials: list[~applications.models.MicrosoftGraphKeyCredential]
        :param logo: The main logo for the application. Not nullable.
        :type logo: bytes
        :param notes:
        :type notes: str
        :param oauth2_require_post_response:
        :type oauth2_require_post_response: bool
        :param parental_control_settings: parentalControlSettings.
        :type parental_control_settings: ~applications.models.MicrosoftGraphParentalControlSettings
        :param password_credentials: The collection of password credentials associated with the
         application. Not nullable.
        :type password_credentials: list[~applications.models.MicrosoftGraphPasswordCredential]
        :param public_client: publicClientApplication.
        :type public_client: ~applications.models.MicrosoftGraphPublicClientApplication
        :param publisher_domain: The verified publisher domain for the application. Read-only.
        :type publisher_domain: str
        :param required_resource_access: Specifies resources that this application requires access to
         and the set of OAuth permission scopes and application roles that it needs under each of those
         resources. This pre-configuration of required resource access drives the consent experience.
         Not nullable.
        :type required_resource_access: list[~applications.models.MicrosoftGraphRequiredResourceAccess]
        :param sign_in_audience: Specifies the Microsoft accounts that are supported for the current
         application. Supported values are:AzureADMyOrg: Users with a Microsoft work or school account
         in my organization’s Azure AD tenant (single tenant)AzureADMultipleOrgs: Users with a Microsoft
         work or school account in any organization’s Azure AD tenant (multi-
         tenant)AzureADandPersonalMicrosoftAccount: Users with a personal Microsoft account, or a work
         or school account in any organization’s Azure AD tenant.
        :type sign_in_audience: str
        :param tags: Custom strings that can be used to categorize and identify the application. Not
         nullable.
        :type tags: list[str]
        :param token_encryption_key_id: Specifies the keyId of a public key from the keyCredentials
         collection. When configured, Azure AD encrypts all the tokens it emits by using the key this
         property points to. The application code that receives the encrypted token must use the
         matching private key to decrypt the token before it can be used for the signed-in user.
        :type token_encryption_key_id: str
        :param created_on_behalf_of: Represents an Azure Active Directory object. The directoryObject
         type is the base type for many other directory entity types.
        :type created_on_behalf_of: ~applications.models.MicrosoftGraphDirectoryObject
        :param extension_properties: Read-only. Nullable.
        :type extension_properties: list[~applications.models.MicrosoftGraphExtensionProperty]
        :param home_realm_discovery_policies:
        :type home_realm_discovery_policies: list[~applications.models.MicrosoftGraphHomeRealmDiscoveryPolicy]
        :param owners: Directory objects that are owners of the application. The owners are a set of
         non-admin users who are allowed to modify this object. Requires version 2013-11-08 or newer.
         Read-only. Nullable.
        :type owners: list[~applications.models.MicrosoftGraphDirectoryObject]
        :param token_issuance_policies:
        :type token_issuance_policies: list[~applications.models.MicrosoftGraphTokenIssuancePolicy]
        :param token_lifetime_policies:
        :type token_lifetime_policies: list[~applications.models.MicrosoftGraphTokenLifetimePolicy]
        :param home_page_url: Home page or landing page of the application.
        :type home_page_url: str
        :param implicit_grant_settings: implicitGrantSettings.
        :type implicit_grant_settings: ~applications.models.MicrosoftGraphImplicitGrantSettings
        :param logout_url: Specifies the URL that will be used by Microsoft's authorization service to
         logout an user using front-channel, back-channel or SAML logout protocols.
        :type logout_url: str
        :param redirect_uris: Specifies the URLs where user tokens are sent for sign-in, or the
         redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
        :type redirect_uris: list[str]
        :param access_token: The optional claims returned in the JWT access token.
        :type access_token: list[~applications.models.MicrosoftGraphOptionalClaim]
        :param id_token: The optional claims returned in the JWT ID token.
        :type id_token: list[~applications.models.MicrosoftGraphOptionalClaim]
        :param saml2_token: The optional claims returned in the SAML token.
        :type saml2_token: list[~applications.models.MicrosoftGraphOptionalClaim]
        :param accept_mapped_claims: When true, allows an application to use claims mapping without
         specifying a custom signing key.
        :type accept_mapped_claims: bool
        :param known_client_applications: Used for bundling consent if you have a solution that
         contains two parts: a client app and a custom web API app. If you set the appID of the client
         app to this value, the user only consents once to the client app. Azure AD knows that
         consenting to the client means implicitly consenting to the web API and automatically
         provisions service principals for both APIs at the same time. Both the client and the web API
         app must be registered in the same tenant.
        :type known_client_applications: list[str]
        :param oauth2_permission_scopes: The definition of the delegated permissions exposed by the web
         API represented by this application registration. These delegated permissions may be requested
         by a client application, and may be granted by users or administrators during consent.
         Delegated permissions are sometimes referred to as OAuth 2.0 scopes.
        :type oauth2_permission_scopes: list[~applications.models.MicrosoftGraphPermissionScope]
        :param pre_authorized_applications: Lists the client applications that are pre-authorized with
         the specified delegated permissions to access this application's APIs. Users are not required
         to consent to any pre-authorized application (for the permissions specified). However, any
         additional permissions not listed in preAuthorizedApplications (requested through incremental
         consent for example) will require user consent.
        :type pre_authorized_applications: list[~applications.models.MicrosoftGraphPreAuthorizedApplication]
        :param requested_access_token_version: Specifies the access token version expected by this
         resource. This changes the version and format of the JWT produced independent of the endpoint
         or client used to request the access token.  The endpoint used, v1.0 or v2.0, is chosen by the
         client and only impacts the version of id_tokens. Resources need to explicitly configure
         requestedAccessTokenVersion to indicate the supported access token format.  Possible values for
         requestedAccessTokenVersion are 1, 2, or null. If the value is null, this defaults to 1, which
         corresponds to the v1.0 endpoint.  If signInAudience on the application is configured as
         AzureADandPersonalMicrosoftAccount, the value for this property must be 2.
        :type requested_access_token_version: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphApplication(id=id, deleted_date_time=deleted_date_time, add_ins=add_ins, app_id=app_id, application_template_id=application_template_id, app_roles=app_roles, created_date_time=created_date_time, description=description, display_name=display_name, group_membership_claims=group_membership_claims, identifier_uris=identifier_uris, info=info, is_device_only_auth_supported=is_device_only_auth_supported, is_fallback_public_client=is_fallback_public_client, key_credentials=key_credentials, logo=logo, notes=notes, oauth2_require_post_response=oauth2_require_post_response, parental_control_settings=parental_control_settings, password_credentials=password_credentials, public_client=public_client, publisher_domain=publisher_domain, required_resource_access=required_resource_access, sign_in_audience=sign_in_audience, tags=tags, token_encryption_key_id=token_encryption_key_id, created_on_behalf_of=created_on_behalf_of, extension_properties=extension_properties, home_realm_discovery_policies=home_realm_discovery_policies, owners=owners, token_issuance_policies=token_issuance_policies, token_lifetime_policies=token_lifetime_policies, home_page_url=home_page_url, implicit_grant_settings=implicit_grant_settings, logout_url=logout_url, redirect_uris=redirect_uris, access_token=access_token, id_token=id_token, saml2_token=saml2_token, accept_mapped_claims=accept_mapped_claims, known_client_applications=known_client_applications, oauth2_permission_scopes=oauth2_permission_scopes, pre_authorized_applications=pre_authorized_applications, requested_access_token_version=requested_access_token_version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_application.metadata['url']  # type: ignore
        path_format_arguments = {
            'application-id': self._serialize.url("application_id", application_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphApplication')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_application.metadata = {'url': '/applications/{application-id}'}  # type: ignore

    async def delete_application(
        self,
        application_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete entity from applications.

        Delete entity from applications.

        :param application_id: key: id of application.
        :type application_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_application.metadata['url']  # type: ignore
        path_format_arguments = {
            'application-id': self._serialize.url("application_id", application_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_application.metadata = {'url': '/applications/{application-id}'}  # type: ignore

    async def get_logo(
        self,
        application_id: str,
        **kwargs
    ) -> IO:
        """Get media content for application from applications.

        Get media content for application from applications.

        :param application_id: key: id of application.
        :type application_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/octet-stream, application/json"

        # Construct URL
        url = self.get_logo.metadata['url']  # type: ignore
        path_format_arguments = {
            'application-id': self._serialize.url("application_id", application_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_logo.metadata = {'url': '/applications/{application-id}/logo'}  # type: ignore

    async def set_logo(
        self,
        application_id: str,
        data: IO,
        **kwargs
    ) -> None:
        """Update media content for application in applications.

        Update media content for application in applications.

        :param application_id: key: id of application.
        :type application_id: str
        :param data: New media content.
        :type data: IO
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")
        accept = "application/json"

        # Construct URL
        url = self.set_logo.metadata['url']  # type: ignore
        path_format_arguments = {
            'application-id': self._serialize.url("application_id", application_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content_kwargs['stream_content'] = data
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_logo.metadata = {'url': '/applications/{application-id}/logo'}  # type: ignore
