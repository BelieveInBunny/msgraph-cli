# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddMobileAppCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMobileAppCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddVppTokens(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddVppTokens, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'apple-id':
                d['apple_id'] = v[0]
            elif kl == 'automatically-update-apps':
                d['automatically_update_apps'] = v[0]
            elif kl == 'country-or-region':
                d['country_or_region'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            elif kl == 'last-sync-status':
                d['last_sync_status'] = v[0]
            elif kl == 'organization-name':
                d['organization_name'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'token':
                d['token'] = v[0]
            elif kl == 'vpp-token-account-type':
                d['vpp_token_account_type'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddManagedAppPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddManagedAppPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddManagedAppStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddManagedAppStatuses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddMdmWindowsInformationProtectionPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMdmWindowsInformationProtectionPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'azure-rights-management-services-allowed':
                d['azure_rights_management_services_allowed'] = v[0]
            elif kl == 'data-recovery-certificate':
                d['data_recovery_certificate'] = v[0]
            elif kl == 'enforcement-level':
                d['enforcement_level'] = v[0]
            elif kl == 'enterprise-domain':
                d['enterprise_domain'] = v[0]
            elif kl == 'enterprise-internal-proxy-servers':
                d['enterprise_internal_proxy_servers'] = v
            elif kl == 'enterprise-ip-ranges':
                d['enterprise_ip_ranges'] = v
            elif kl == 'enterprise-ip-ranges-are-authoritative':
                d['enterprise_ip_ranges_are_authoritative'] = v[0]
            elif kl == 'enterprise-network-domain-names':
                d['enterprise_network_domain_names'] = v
            elif kl == 'enterprise-protected-domain-names':
                d['enterprise_protected_domain_names'] = v
            elif kl == 'enterprise-proxied-domains':
                d['enterprise_proxied_domains'] = v
            elif kl == 'enterprise-proxy-servers':
                d['enterprise_proxy_servers'] = v
            elif kl == 'enterprise-proxy-servers-are-authoritative':
                d['enterprise_proxy_servers_are_authoritative'] = v[0]
            elif kl == 'exempt-apps':
                d['exempt_apps'] = v
            elif kl == 'icons-visible':
                d['icons_visible'] = v[0]
            elif kl == 'indexing-encrypted-stores-or-items-blocked':
                d['indexing_encrypted_stores_or_items_blocked'] = v[0]
            elif kl == 'is-assigned':
                d['is_assigned'] = v[0]
            elif kl == 'neutral-domain-resources':
                d['neutral_domain_resources'] = v
            elif kl == 'protected-apps':
                d['protected_apps'] = v
            elif kl == 'protection-under-lock-config-required':
                d['protection_under_lock_config_required'] = v[0]
            elif kl == 'revoke-on-unenroll-disabled':
                d['revoke_on_unenroll_disabled'] = v[0]
            elif kl == 'rights-management-services-template-id':
                d['rights_management_services_template_id'] = v[0]
            elif kl == 'smb-auto-encrypted-file-extensions':
                d['smb_auto_encrypted_file_extensions'] = v
            elif kl == 'assignments':
                d['assignments'] = v
            elif kl == 'exempt-app-locker-files':
                d['exempt_app_locker_files'] = v
            elif kl == 'protected-app-locker-files':
                d['protected_app_locker_files'] = v
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddWindowsInformationProtectionPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddWindowsInformationProtectionPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'days-without-contact-before-unenroll':
                d['days_without_contact_before_unenroll'] = v[0]
            elif kl == 'mdm-enrollment-url':
                d['mdm_enrollment_url'] = v[0]
            elif kl == 'minutes-of-inactivity-before-device-lock':
                d['minutes_of_inactivity_before_device_lock'] = v[0]
            elif kl == 'number-of-past-pins-remembered':
                d['number_of_past_pins_remembered'] = v[0]
            elif kl == 'password-maximum-attempt-count':
                d['password_maximum_attempt_count'] = v[0]
            elif kl == 'pin-expiration-days':
                d['pin_expiration_days'] = v[0]
            elif kl == 'pin-lowercase-letters':
                d['pin_lowercase_letters'] = v[0]
            elif kl == 'pin-minimum-length':
                d['pin_minimum_length'] = v[0]
            elif kl == 'pin-special-characters':
                d['pin_special_characters'] = v[0]
            elif kl == 'pin-uppercase-letters':
                d['pin_uppercase_letters'] = v[0]
            elif kl == 'revoke-on-mdm-handoff-disabled':
                d['revoke_on_mdm_handoff_disabled'] = v[0]
            elif kl == 'windows-hello-for-business-blocked':
                d['windows_hello_for_business_blocked'] = v[0]
            elif kl == 'azure-rights-management-services-allowed':
                d['azure_rights_management_services_allowed'] = v[0]
            elif kl == 'data-recovery-certificate':
                d['data_recovery_certificate'] = v[0]
            elif kl == 'enforcement-level':
                d['enforcement_level'] = v[0]
            elif kl == 'enterprise-domain':
                d['enterprise_domain'] = v[0]
            elif kl == 'enterprise-internal-proxy-servers':
                d['enterprise_internal_proxy_servers'] = v
            elif kl == 'enterprise-ip-ranges':
                d['enterprise_ip_ranges'] = v
            elif kl == 'enterprise-ip-ranges-are-authoritative':
                d['enterprise_ip_ranges_are_authoritative'] = v[0]
            elif kl == 'enterprise-network-domain-names':
                d['enterprise_network_domain_names'] = v
            elif kl == 'enterprise-protected-domain-names':
                d['enterprise_protected_domain_names'] = v
            elif kl == 'enterprise-proxied-domains':
                d['enterprise_proxied_domains'] = v
            elif kl == 'enterprise-proxy-servers':
                d['enterprise_proxy_servers'] = v
            elif kl == 'enterprise-proxy-servers-are-authoritative':
                d['enterprise_proxy_servers_are_authoritative'] = v[0]
            elif kl == 'exempt-apps':
                d['exempt_apps'] = v
            elif kl == 'icons-visible':
                d['icons_visible'] = v[0]
            elif kl == 'indexing-encrypted-stores-or-items-blocked':
                d['indexing_encrypted_stores_or_items_blocked'] = v[0]
            elif kl == 'is-assigned':
                d['is_assigned'] = v[0]
            elif kl == 'neutral-domain-resources':
                d['neutral_domain_resources'] = v
            elif kl == 'protected-apps':
                d['protected_apps'] = v
            elif kl == 'protection-under-lock-config-required':
                d['protection_under_lock_config_required'] = v[0]
            elif kl == 'revoke-on-unenroll-disabled':
                d['revoke_on_unenroll_disabled'] = v[0]
            elif kl == 'rights-management-services-template-id':
                d['rights_management_services_template_id'] = v[0]
            elif kl == 'smb-auto-encrypted-file-extensions':
                d['smb_auto_encrypted_file_extensions'] = v
            elif kl == 'assignments':
                d['assignments'] = v
            elif kl == 'exempt-app-locker-files':
                d['exempt_app_locker_files'] = v
            elif kl == 'protected-app-locker-files':
                d['protected_app_locker_files'] = v
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddAppliedPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppliedPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddIntendedPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIntendedPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddOperations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOperations, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddLargeCover(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.large_cover = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
        return d


class AddDeviceappmanagementDeviceStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceappmanagementDeviceStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'device-id':
                d['device_id'] = v[0]
            elif kl == 'device-name':
                d['device_name'] = v[0]
            elif kl == 'error-code':
                d['error_code'] = v[0]
            elif kl == 'install-state':
                d['install_state'] = v[0]
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            elif kl == 'os-description':
                d['os_description'] = v[0]
            elif kl == 'os-version':
                d['os_version'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddInstallSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.install_summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'failed-device-count':
                d['failed_device_count'] = v[0]
            elif kl == 'failed-user-count':
                d['failed_user_count'] = v[0]
            elif kl == 'installed-device-count':
                d['installed_device_count'] = v[0]
            elif kl == 'installed-user-count':
                d['installed_user_count'] = v[0]
            elif kl == 'not-installed-device-count':
                d['not_installed_device_count'] = v[0]
            elif kl == 'not-installed-user-count':
                d['not_installed_user_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddUserStateSummary(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserStateSummary, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'failed-device-count':
                d['failed_device_count'] = v[0]
            elif kl == 'installed-device-count':
                d['installed_device_count'] = v[0]
            elif kl == 'not-installed-device-count':
                d['not_installed_device_count'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'device-states':
                d['device_states'] = v
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddDataRecoveryCertificate(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.data_recovery_certificate = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'certificate':
                d['certificate'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'subject-name':
                d['subject_name'] = v[0]
        return d


class AddEnterpriseInternalProxyServers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseInternalProxyServers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
        return d


class AddEnterpriseIpRanges(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseIpRanges, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'ranges':
                d['ranges'] = v
        return d


class AddEnterpriseNetworkDomainNames(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseNetworkDomainNames, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
        return d


class AddEnterpriseProtectedDomainNames(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProtectedDomainNames, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
        return d


class AddEnterpriseProxiedDomains(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProxiedDomains, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'proxied-domains':
                d['proxied_domains'] = v
        return d


class AddEnterpriseProxyServers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProxyServers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
        return d


class AddExemptApps(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExemptApps, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'denied':
                d['denied'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'product-name':
                d['product_name'] = v[0]
            elif kl == 'publisher-name':
                d['publisher_name'] = v[0]
        return d


class AddNeutralDomainResources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNeutralDomainResources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
        return d


class AddProtectedApps(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProtectedApps, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'denied':
                d['denied'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'product-name':
                d['product_name'] = v[0]
            elif kl == 'publisher-name':
                d['publisher_name'] = v[0]
        return d


class AddSmbAutoEncryptedFileExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSmbAutoEncryptedFileExtensions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
        return d


class AddExemptAppLockerFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExemptAppLockerFiles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'file':
                d['file'] = v[0]
            elif kl == 'file-hash':
                d['file_hash'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddProtectedAppLockerFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProtectedAppLockerFiles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'file':
                d['file'] = v[0]
            elif kl == 'file-hash':
                d['file_hash'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddDeviceStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceStatuses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'compliance-grace-period-expiration-date-time':
                d['compliance_grace_period_expiration_date_time'] = v[0]
            elif kl == 'device-display-name':
                d['device_display_name'] = v[0]
            elif kl == 'device-model':
                d['device_model'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddDeviceStatusSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.device_status_summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'configuration-version':
                d['configuration_version'] = v[0]
            elif kl == 'error-count':
                d['error_count'] = v[0]
            elif kl == 'failed-count':
                d['failed_count'] = v[0]
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            elif kl == 'not-applicable-count':
                d['not_applicable_count'] = v[0]
            elif kl == 'pending-count':
                d['pending_count'] = v[0]
            elif kl == 'success-count':
                d['success_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddUserStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserStatuses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'devices-count':
                d['devices_count'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'user-display-name':
                d['user_display_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddUserStatusSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.user_status_summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'configuration-version':
                d['configuration_version'] = v[0]
            elif kl == 'error-count':
                d['error_count'] = v[0]
            elif kl == 'failed-count':
                d['failed_count'] = v[0]
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            elif kl == 'not-applicable-count':
                d['not_applicable_count'] = v[0]
            elif kl == 'pending-count':
                d['pending_count'] = v[0]
            elif kl == 'success-count':
                d['success_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddCustomSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCustomSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
        return d


class AddDeviceappmanagementManagedebooksDeviceStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceappmanagementManagedebooksDeviceStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'device-id':
                d['device_id'] = v[0]
            elif kl == 'device-name':
                d['device_name'] = v[0]
            elif kl == 'error-code':
                d['error_code'] = v[0]
            elif kl == 'install-state':
                d['install_state'] = v[0]
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            elif kl == 'os-description':
                d['os_description'] = v[0]
            elif kl == 'os-version':
                d['os_version'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddDevicescorporatemanagementCreateDeviceCompliancePolicyStateSettingStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDevicescorporatemanagementCreateDeviceCompliancePolicyStateSettingStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'current-value':
                d['current_value'] = v[0]
            elif kl == 'error-code':
                d['error_code'] = v[0]
            elif kl == 'error-description':
                d['error_description'] = v[0]
            elif kl == 'instance-display-name':
                d['instance_display_name'] = v[0]
            elif kl == 'setting':
                d['setting'] = v[0]
            elif kl == 'setting-name':
                d['setting_name'] = v[0]
            elif kl == 'sources':
                d['sources'] = v
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'user-email':
                d['user_email'] = v[0]
            elif kl == 'user-id':
                d['user_id'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
        return d


class AddDevicescorporatemanagementCreateDeviceConfigurationStateSettingStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDevicescorporatemanagementCreateDeviceConfigurationStateSettingStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'current-value':
                d['current_value'] = v[0]
            elif kl == 'error-code':
                d['error_code'] = v[0]
            elif kl == 'error-description':
                d['error_description'] = v[0]
            elif kl == 'instance-display-name':
                d['instance_display_name'] = v[0]
            elif kl == 'setting':
                d['setting'] = v[0]
            elif kl == 'setting-name':
                d['setting_name'] = v[0]
            elif kl == 'sources':
                d['sources'] = v
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'user-email':
                d['user_email'] = v[0]
            elif kl == 'user-id':
                d['user_id'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
        return d
