# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AuditLogOperations:
    """AuditLogOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~reports.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_directory_audit(
        self,
        orderby: Optional[List[Union[str, "models.Get5ItemsItem"]]] = None,
        select: Optional[List[Union[str, "models.Get6ItemsItem"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDirectoryAudit"]:
        """Get directoryAudits from auditLogs.

        Get directoryAudits from auditLogs.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDirectoryAudit or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.CollectionOfDirectoryAudit]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDirectoryAudit"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_directory_audit.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDirectoryAudit', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_directory_audit.metadata = {'url': '/auditLogs/directoryAudits'}  # type: ignore

    async def create_directory_audit(
        self,
        id: Optional[str] = None,
        activity_date_time: Optional[datetime.datetime] = None,
        activity_display_name: Optional[str] = None,
        additional_details: Optional[List["models.MicrosoftGraphKeyValue"]] = None,
        category: Optional[str] = None,
        correlation_id: Optional[str] = None,
        logged_by_service: Optional[str] = None,
        operation_type: Optional[str] = None,
        result: Optional[Union[str, "models.MicrosoftGraphOperationResult"]] = None,
        result_reason: Optional[str] = None,
        target_resources: Optional[List["models.MicrosoftGraphTargetResource"]] = None,
        app: Optional["models.MicrosoftGraphAppIdentity"] = None,
        user: Optional["models.MicrosoftGraphUserIdentity"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDirectoryAudit":
        """Create new navigation property to directoryAudits for auditLogs.

        Create new navigation property to directoryAudits for auditLogs.

        :param id: Read-only.
        :type id: str
        :param activity_date_time: Indicates the date and time the activity was performed. The
         Timestamp type is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type activity_date_time: ~datetime.datetime
        :param activity_display_name: Indicates the activity name or the operation name (examples:
         'Create User' and 'Add member to group'). For full list, see Azure AD activity list.
        :type activity_display_name: str
        :param additional_details: Indicates additional details on the activity.
        :type additional_details: list[~reports.models.MicrosoftGraphKeyValue]
        :param category: Indicates which resource category that's targeted by the activity. (For
         example: User Management, Group Management etc..).
        :type category: str
        :param correlation_id: Indicates a unique ID that helps correlate activities that span across
         various services. Can be used to trace logs across services.
        :type correlation_id: str
        :param logged_by_service: Indicates information on which service initiated the activity (For
         example: Self-service Password Management, Core Directory, B2C, Invited Users, Microsoft
         Identity Manager, Privileged Identity Management.
        :type logged_by_service: str
        :param operation_type:
        :type operation_type: str
        :param result:
        :type result: str or ~reports.models.MicrosoftGraphOperationResult
        :param result_reason: Describes cause of 'failure' or 'timeout' results.
        :type result_reason: str
        :param target_resources: Indicates information on which resource was changed due to the
         activity. Target Resource Type can be User, Device, Directory, App, Role, Group, Policy or
         Other.
        :type target_resources: list[~reports.models.MicrosoftGraphTargetResource]
        :param app: appIdentity.
        :type app: ~reports.models.MicrosoftGraphAppIdentity
        :param user: userIdentity.
        :type user: ~reports.models.MicrosoftGraphUserIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDirectoryAudit, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphDirectoryAudit
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDirectoryAudit"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphDirectoryAudit(id=id, activity_date_time=activity_date_time, activity_display_name=activity_display_name, additional_details=additional_details, category=category, correlation_id=correlation_id, logged_by_service=logged_by_service, operation_type=operation_type, result=result, result_reason=result_reason, target_resources=target_resources, app=app, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_directory_audit.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphDirectoryAudit')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDirectoryAudit', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_directory_audit.metadata = {'url': '/auditLogs/directoryAudits'}  # type: ignore

    async def get_directory_audit(
        self,
        directory_audit_id: str,
        select: Optional[List[Union[str, "models.Enum12"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDirectoryAudit":
        """Get directoryAudits from auditLogs.

        Get directoryAudits from auditLogs.

        :param directory_audit_id: key: id of directoryAudit.
        :type directory_audit_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum12]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDirectoryAudit, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphDirectoryAudit
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDirectoryAudit"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_directory_audit.metadata['url']  # type: ignore
        path_format_arguments = {
            'directoryAudit-id': self._serialize.url("directory_audit_id", directory_audit_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDirectoryAudit', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_directory_audit.metadata = {'url': '/auditLogs/directoryAudits/{directoryAudit-id}'}  # type: ignore

    async def update_directory_audit(
        self,
        directory_audit_id: str,
        id: Optional[str] = None,
        activity_date_time: Optional[datetime.datetime] = None,
        activity_display_name: Optional[str] = None,
        additional_details: Optional[List["models.MicrosoftGraphKeyValue"]] = None,
        category: Optional[str] = None,
        correlation_id: Optional[str] = None,
        logged_by_service: Optional[str] = None,
        operation_type: Optional[str] = None,
        result: Optional[Union[str, "models.MicrosoftGraphOperationResult"]] = None,
        result_reason: Optional[str] = None,
        target_resources: Optional[List["models.MicrosoftGraphTargetResource"]] = None,
        app: Optional["models.MicrosoftGraphAppIdentity"] = None,
        user: Optional["models.MicrosoftGraphUserIdentity"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property directoryAudits in auditLogs.

        Update the navigation property directoryAudits in auditLogs.

        :param directory_audit_id: key: id of directoryAudit.
        :type directory_audit_id: str
        :param id: Read-only.
        :type id: str
        :param activity_date_time: Indicates the date and time the activity was performed. The
         Timestamp type is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type activity_date_time: ~datetime.datetime
        :param activity_display_name: Indicates the activity name or the operation name (examples:
         'Create User' and 'Add member to group'). For full list, see Azure AD activity list.
        :type activity_display_name: str
        :param additional_details: Indicates additional details on the activity.
        :type additional_details: list[~reports.models.MicrosoftGraphKeyValue]
        :param category: Indicates which resource category that's targeted by the activity. (For
         example: User Management, Group Management etc..).
        :type category: str
        :param correlation_id: Indicates a unique ID that helps correlate activities that span across
         various services. Can be used to trace logs across services.
        :type correlation_id: str
        :param logged_by_service: Indicates information on which service initiated the activity (For
         example: Self-service Password Management, Core Directory, B2C, Invited Users, Microsoft
         Identity Manager, Privileged Identity Management.
        :type logged_by_service: str
        :param operation_type:
        :type operation_type: str
        :param result:
        :type result: str or ~reports.models.MicrosoftGraphOperationResult
        :param result_reason: Describes cause of 'failure' or 'timeout' results.
        :type result_reason: str
        :param target_resources: Indicates information on which resource was changed due to the
         activity. Target Resource Type can be User, Device, Directory, App, Role, Group, Policy or
         Other.
        :type target_resources: list[~reports.models.MicrosoftGraphTargetResource]
        :param app: appIdentity.
        :type app: ~reports.models.MicrosoftGraphAppIdentity
        :param user: userIdentity.
        :type user: ~reports.models.MicrosoftGraphUserIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphDirectoryAudit(id=id, activity_date_time=activity_date_time, activity_display_name=activity_display_name, additional_details=additional_details, category=category, correlation_id=correlation_id, logged_by_service=logged_by_service, operation_type=operation_type, result=result, result_reason=result_reason, target_resources=target_resources, app=app, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_directory_audit.metadata['url']  # type: ignore
        path_format_arguments = {
            'directoryAudit-id': self._serialize.url("directory_audit_id", directory_audit_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphDirectoryAudit')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_directory_audit.metadata = {'url': '/auditLogs/directoryAudits/{directoryAudit-id}'}  # type: ignore

    async def delete_directory_audit(
        self,
        directory_audit_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property directoryAudits for auditLogs.

        Delete navigation property directoryAudits for auditLogs.

        :param directory_audit_id: key: id of directoryAudit.
        :type directory_audit_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_directory_audit.metadata['url']  # type: ignore
        path_format_arguments = {
            'directoryAudit-id': self._serialize.url("directory_audit_id", directory_audit_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_directory_audit.metadata = {'url': '/auditLogs/directoryAudits/{directoryAudit-id}'}  # type: ignore

    def list_restricted_sign_in(
        self,
        orderby: Optional[List[Union[str, "models.Enum13"]]] = None,
        select: Optional[List[Union[str, "models.Enum14"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfRestrictedSignIn"]:
        """Get restrictedSignIns from auditLogs.

        Get restrictedSignIns from auditLogs.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum13]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum14]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfRestrictedSignIn or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.CollectionOfRestrictedSignIn]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfRestrictedSignIn"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_restricted_sign_in.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfRestrictedSignIn', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_restricted_sign_in.metadata = {'url': '/auditLogs/restrictedSignIns'}  # type: ignore

    async def create_restricted_sign_in(
        self,
        id: Optional[str] = None,
        app_display_name: Optional[str] = None,
        app_id: Optional[str] = None,
        applied_conditional_access_policies: Optional[List["models.MicrosoftGraphAppliedConditionalAccessPolicy"]] = None,
        client_app_used: Optional[str] = None,
        conditional_access_status: Optional[Union[str, "models.MicrosoftGraphConditionalAccessStatus"]] = None,
        correlation_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        device_detail: Optional["models.MicrosoftGraphDeviceDetail"] = None,
        ip_address: Optional[str] = None,
        is_interactive: Optional[bool] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        risk_detail: Optional[Union[str, "models.MicrosoftGraphRiskDetail"]] = None,
        risk_event_types: Optional[List[Union[str, "models.MicrosoftGraphRiskEventType"]]] = None,
        risk_event_types_v2: Optional[List[str]] = None,
        risk_level_aggregated: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_level_during_sign_in: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_state: Optional[Union[str, "models.MicrosoftGraphRiskState"]] = None,
        status: Optional["models.MicrosoftGraphSignInStatus"] = None,
        user_display_name: Optional[str] = None,
        user_id: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        city: Optional[str] = None,
        country_or_region: Optional[str] = None,
        geo_coordinates: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        state: Optional[str] = None,
        target_tenant_id: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphRestrictedSignIn":
        """Create new navigation property to restrictedSignIns for auditLogs.

        Create new navigation property to restrictedSignIns for auditLogs.

        :param id: Read-only.
        :type id: str
        :param app_display_name: App name displayed in the Azure Portal.
        :type app_display_name: str
        :param app_id: Unique GUID representing the app ID in the Azure Active Directory.
        :type app_id: str
        :param applied_conditional_access_policies:
        :type applied_conditional_access_policies: list[~reports.models.MicrosoftGraphAppliedConditionalAccessPolicy]
        :param client_app_used: Identifies the legacy client used for sign-in activity.  Includes
         Browser, Exchange Active Sync, modern clients, IMAP, MAPI, SMTP, and POP.
        :type client_app_used: str
        :param conditional_access_status:
        :type conditional_access_status: str or ~reports.models.MicrosoftGraphConditionalAccessStatus
        :param correlation_id: The request ID sent from the client when the sign-in is initiated; used
         to troubleshoot sign-in activity.
        :type correlation_id: str
        :param created_date_time: Date and time (UTC) the sign-in was initiated. Example: midnight on
         Jan 1, 2014 is reported as '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param device_detail: deviceDetail.
        :type device_detail: ~reports.models.MicrosoftGraphDeviceDetail
        :param ip_address: IP address of the client used to sign in.
        :type ip_address: str
        :param is_interactive: Indicates if a sign-in is interactive or not.
        :type is_interactive: bool
        :param resource_display_name: Name of the resource the user signed into.
        :type resource_display_name: str
        :param resource_id: ID of the resource that the user signed into.
        :type resource_id: str
        :param risk_detail:
        :type risk_detail: str or ~reports.models.MicrosoftGraphRiskDetail
        :param risk_event_types: Risk event types associated with the sign-in. The possible values are:
         unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, and unknownFutureValue.
        :type risk_event_types: list[str or ~reports.models.MicrosoftGraphRiskEventType]
        :param risk_event_types_v2: The list of risk event types associated with the sign-in. Possible
         values: unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, or unknownFutureValue.
        :type risk_event_types_v2: list[str]
        :param risk_level_aggregated:
        :type risk_level_aggregated: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_level_during_sign_in:
        :type risk_level_during_sign_in: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_state:
        :type risk_state: str or ~reports.models.MicrosoftGraphRiskState
        :param status: signInStatus.
        :type status: ~reports.models.MicrosoftGraphSignInStatus
        :param user_display_name: Display name of the user that initiated the sign-in.
        :type user_display_name: str
        :param user_id: ID of the user that initiated the sign-in.
        :type user_id: str
        :param user_principal_name: User principal name of the user that initiated the sign-in.
        :type user_principal_name: str
        :param city: Provides the city where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type city: str
        :param country_or_region: Provides the country code info (2 letter code) where the sign-in
         originated.  This is calculated using latitude/longitude information from the sign-in activity.
        :type country_or_region: str
        :param geo_coordinates: geoCoordinates.
        :type geo_coordinates: ~reports.models.MicrosoftGraphGeoCoordinates
        :param state: Provides the State where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type state: str
        :param target_tenant_id:
        :type target_tenant_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphRestrictedSignIn, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphRestrictedSignIn
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphRestrictedSignIn"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphRestrictedSignIn(id=id, app_display_name=app_display_name, app_id=app_id, applied_conditional_access_policies=applied_conditional_access_policies, client_app_used=client_app_used, conditional_access_status=conditional_access_status, correlation_id=correlation_id, created_date_time=created_date_time, device_detail=device_detail, ip_address=ip_address, is_interactive=is_interactive, resource_display_name=resource_display_name, resource_id=resource_id, risk_detail=risk_detail, risk_event_types=risk_event_types, risk_event_types_v2=risk_event_types_v2, risk_level_aggregated=risk_level_aggregated, risk_level_during_sign_in=risk_level_during_sign_in, risk_state=risk_state, status=status, user_display_name=user_display_name, user_id=user_id, user_principal_name=user_principal_name, city=city, country_or_region=country_or_region, geo_coordinates=geo_coordinates, state=state, target_tenant_id=target_tenant_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_restricted_sign_in.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphRestrictedSignIn')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphRestrictedSignIn', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_restricted_sign_in.metadata = {'url': '/auditLogs/restrictedSignIns'}  # type: ignore

    async def get_restricted_sign_in(
        self,
        restricted_sign_in_id: str,
        select: Optional[List[Union[str, "models.Enum15"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphRestrictedSignIn":
        """Get restrictedSignIns from auditLogs.

        Get restrictedSignIns from auditLogs.

        :param restricted_sign_in_id: key: id of restrictedSignIn.
        :type restricted_sign_in_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum15]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphRestrictedSignIn, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphRestrictedSignIn
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphRestrictedSignIn"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_restricted_sign_in.metadata['url']  # type: ignore
        path_format_arguments = {
            'restrictedSignIn-id': self._serialize.url("restricted_sign_in_id", restricted_sign_in_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphRestrictedSignIn', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_restricted_sign_in.metadata = {'url': '/auditLogs/restrictedSignIns/{restrictedSignIn-id}'}  # type: ignore

    async def update_restricted_sign_in(
        self,
        restricted_sign_in_id: str,
        id: Optional[str] = None,
        app_display_name: Optional[str] = None,
        app_id: Optional[str] = None,
        applied_conditional_access_policies: Optional[List["models.MicrosoftGraphAppliedConditionalAccessPolicy"]] = None,
        client_app_used: Optional[str] = None,
        conditional_access_status: Optional[Union[str, "models.MicrosoftGraphConditionalAccessStatus"]] = None,
        correlation_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        device_detail: Optional["models.MicrosoftGraphDeviceDetail"] = None,
        ip_address: Optional[str] = None,
        is_interactive: Optional[bool] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        risk_detail: Optional[Union[str, "models.MicrosoftGraphRiskDetail"]] = None,
        risk_event_types: Optional[List[Union[str, "models.MicrosoftGraphRiskEventType"]]] = None,
        risk_event_types_v2: Optional[List[str]] = None,
        risk_level_aggregated: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_level_during_sign_in: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_state: Optional[Union[str, "models.MicrosoftGraphRiskState"]] = None,
        status: Optional["models.MicrosoftGraphSignInStatus"] = None,
        user_display_name: Optional[str] = None,
        user_id: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        city: Optional[str] = None,
        country_or_region: Optional[str] = None,
        geo_coordinates: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        state: Optional[str] = None,
        target_tenant_id: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property restrictedSignIns in auditLogs.

        Update the navigation property restrictedSignIns in auditLogs.

        :param restricted_sign_in_id: key: id of restrictedSignIn.
        :type restricted_sign_in_id: str
        :param id: Read-only.
        :type id: str
        :param app_display_name: App name displayed in the Azure Portal.
        :type app_display_name: str
        :param app_id: Unique GUID representing the app ID in the Azure Active Directory.
        :type app_id: str
        :param applied_conditional_access_policies:
        :type applied_conditional_access_policies: list[~reports.models.MicrosoftGraphAppliedConditionalAccessPolicy]
        :param client_app_used: Identifies the legacy client used for sign-in activity.  Includes
         Browser, Exchange Active Sync, modern clients, IMAP, MAPI, SMTP, and POP.
        :type client_app_used: str
        :param conditional_access_status:
        :type conditional_access_status: str or ~reports.models.MicrosoftGraphConditionalAccessStatus
        :param correlation_id: The request ID sent from the client when the sign-in is initiated; used
         to troubleshoot sign-in activity.
        :type correlation_id: str
        :param created_date_time: Date and time (UTC) the sign-in was initiated. Example: midnight on
         Jan 1, 2014 is reported as '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param device_detail: deviceDetail.
        :type device_detail: ~reports.models.MicrosoftGraphDeviceDetail
        :param ip_address: IP address of the client used to sign in.
        :type ip_address: str
        :param is_interactive: Indicates if a sign-in is interactive or not.
        :type is_interactive: bool
        :param resource_display_name: Name of the resource the user signed into.
        :type resource_display_name: str
        :param resource_id: ID of the resource that the user signed into.
        :type resource_id: str
        :param risk_detail:
        :type risk_detail: str or ~reports.models.MicrosoftGraphRiskDetail
        :param risk_event_types: Risk event types associated with the sign-in. The possible values are:
         unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, and unknownFutureValue.
        :type risk_event_types: list[str or ~reports.models.MicrosoftGraphRiskEventType]
        :param risk_event_types_v2: The list of risk event types associated with the sign-in. Possible
         values: unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, or unknownFutureValue.
        :type risk_event_types_v2: list[str]
        :param risk_level_aggregated:
        :type risk_level_aggregated: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_level_during_sign_in:
        :type risk_level_during_sign_in: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_state:
        :type risk_state: str or ~reports.models.MicrosoftGraphRiskState
        :param status: signInStatus.
        :type status: ~reports.models.MicrosoftGraphSignInStatus
        :param user_display_name: Display name of the user that initiated the sign-in.
        :type user_display_name: str
        :param user_id: ID of the user that initiated the sign-in.
        :type user_id: str
        :param user_principal_name: User principal name of the user that initiated the sign-in.
        :type user_principal_name: str
        :param city: Provides the city where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type city: str
        :param country_or_region: Provides the country code info (2 letter code) where the sign-in
         originated.  This is calculated using latitude/longitude information from the sign-in activity.
        :type country_or_region: str
        :param geo_coordinates: geoCoordinates.
        :type geo_coordinates: ~reports.models.MicrosoftGraphGeoCoordinates
        :param state: Provides the State where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type state: str
        :param target_tenant_id:
        :type target_tenant_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphRestrictedSignIn(id=id, app_display_name=app_display_name, app_id=app_id, applied_conditional_access_policies=applied_conditional_access_policies, client_app_used=client_app_used, conditional_access_status=conditional_access_status, correlation_id=correlation_id, created_date_time=created_date_time, device_detail=device_detail, ip_address=ip_address, is_interactive=is_interactive, resource_display_name=resource_display_name, resource_id=resource_id, risk_detail=risk_detail, risk_event_types=risk_event_types, risk_event_types_v2=risk_event_types_v2, risk_level_aggregated=risk_level_aggregated, risk_level_during_sign_in=risk_level_during_sign_in, risk_state=risk_state, status=status, user_display_name=user_display_name, user_id=user_id, user_principal_name=user_principal_name, city=city, country_or_region=country_or_region, geo_coordinates=geo_coordinates, state=state, target_tenant_id=target_tenant_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_restricted_sign_in.metadata['url']  # type: ignore
        path_format_arguments = {
            'restrictedSignIn-id': self._serialize.url("restricted_sign_in_id", restricted_sign_in_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphRestrictedSignIn')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_restricted_sign_in.metadata = {'url': '/auditLogs/restrictedSignIns/{restrictedSignIn-id}'}  # type: ignore

    async def delete_restricted_sign_in(
        self,
        restricted_sign_in_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property restrictedSignIns for auditLogs.

        Delete navigation property restrictedSignIns for auditLogs.

        :param restricted_sign_in_id: key: id of restrictedSignIn.
        :type restricted_sign_in_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_restricted_sign_in.metadata['url']  # type: ignore
        path_format_arguments = {
            'restrictedSignIn-id': self._serialize.url("restricted_sign_in_id", restricted_sign_in_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_restricted_sign_in.metadata = {'url': '/auditLogs/restrictedSignIns/{restrictedSignIn-id}'}  # type: ignore

    def list_sign_in(
        self,
        orderby: Optional[List[Union[str, "models.Enum16"]]] = None,
        select: Optional[List[Union[str, "models.Enum17"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSignIn"]:
        """Get signIns from auditLogs.

        Get signIns from auditLogs.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum16]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum17]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSignIn or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.CollectionOfSignIn]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSignIn"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_sign_in.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSignIn', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sign_in.metadata = {'url': '/auditLogs/signIns'}  # type: ignore

    async def create_sign_in(
        self,
        id: Optional[str] = None,
        app_display_name: Optional[str] = None,
        app_id: Optional[str] = None,
        applied_conditional_access_policies: Optional[List["models.MicrosoftGraphAppliedConditionalAccessPolicy"]] = None,
        client_app_used: Optional[str] = None,
        conditional_access_status: Optional[Union[str, "models.MicrosoftGraphConditionalAccessStatus"]] = None,
        correlation_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        device_detail: Optional["models.MicrosoftGraphDeviceDetail"] = None,
        ip_address: Optional[str] = None,
        is_interactive: Optional[bool] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        risk_detail: Optional[Union[str, "models.MicrosoftGraphRiskDetail"]] = None,
        risk_event_types: Optional[List[Union[str, "models.MicrosoftGraphRiskEventType"]]] = None,
        risk_event_types_v2: Optional[List[str]] = None,
        risk_level_aggregated: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_level_during_sign_in: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_state: Optional[Union[str, "models.MicrosoftGraphRiskState"]] = None,
        status: Optional["models.MicrosoftGraphSignInStatus"] = None,
        user_display_name: Optional[str] = None,
        user_id: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        city: Optional[str] = None,
        country_or_region: Optional[str] = None,
        geo_coordinates: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        state: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSignIn":
        """Create new navigation property to signIns for auditLogs.

        Create new navigation property to signIns for auditLogs.

        :param id: Read-only.
        :type id: str
        :param app_display_name: App name displayed in the Azure Portal.
        :type app_display_name: str
        :param app_id: Unique GUID representing the app ID in the Azure Active Directory.
        :type app_id: str
        :param applied_conditional_access_policies:
        :type applied_conditional_access_policies: list[~reports.models.MicrosoftGraphAppliedConditionalAccessPolicy]
        :param client_app_used: Identifies the legacy client used for sign-in activity.  Includes
         Browser, Exchange Active Sync, modern clients, IMAP, MAPI, SMTP, and POP.
        :type client_app_used: str
        :param conditional_access_status:
        :type conditional_access_status: str or ~reports.models.MicrosoftGraphConditionalAccessStatus
        :param correlation_id: The request ID sent from the client when the sign-in is initiated; used
         to troubleshoot sign-in activity.
        :type correlation_id: str
        :param created_date_time: Date and time (UTC) the sign-in was initiated. Example: midnight on
         Jan 1, 2014 is reported as '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param device_detail: deviceDetail.
        :type device_detail: ~reports.models.MicrosoftGraphDeviceDetail
        :param ip_address: IP address of the client used to sign in.
        :type ip_address: str
        :param is_interactive: Indicates if a sign-in is interactive or not.
        :type is_interactive: bool
        :param resource_display_name: Name of the resource the user signed into.
        :type resource_display_name: str
        :param resource_id: ID of the resource that the user signed into.
        :type resource_id: str
        :param risk_detail:
        :type risk_detail: str or ~reports.models.MicrosoftGraphRiskDetail
        :param risk_event_types: Risk event types associated with the sign-in. The possible values are:
         unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, and unknownFutureValue.
        :type risk_event_types: list[str or ~reports.models.MicrosoftGraphRiskEventType]
        :param risk_event_types_v2: The list of risk event types associated with the sign-in. Possible
         values: unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, or unknownFutureValue.
        :type risk_event_types_v2: list[str]
        :param risk_level_aggregated:
        :type risk_level_aggregated: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_level_during_sign_in:
        :type risk_level_during_sign_in: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_state:
        :type risk_state: str or ~reports.models.MicrosoftGraphRiskState
        :param status: signInStatus.
        :type status: ~reports.models.MicrosoftGraphSignInStatus
        :param user_display_name: Display name of the user that initiated the sign-in.
        :type user_display_name: str
        :param user_id: ID of the user that initiated the sign-in.
        :type user_id: str
        :param user_principal_name: User principal name of the user that initiated the sign-in.
        :type user_principal_name: str
        :param city: Provides the city where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type city: str
        :param country_or_region: Provides the country code info (2 letter code) where the sign-in
         originated.  This is calculated using latitude/longitude information from the sign-in activity.
        :type country_or_region: str
        :param geo_coordinates: geoCoordinates.
        :type geo_coordinates: ~reports.models.MicrosoftGraphGeoCoordinates
        :param state: Provides the State where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type state: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSignIn, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphSignIn
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSignIn"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSignIn(id=id, app_display_name=app_display_name, app_id=app_id, applied_conditional_access_policies=applied_conditional_access_policies, client_app_used=client_app_used, conditional_access_status=conditional_access_status, correlation_id=correlation_id, created_date_time=created_date_time, device_detail=device_detail, ip_address=ip_address, is_interactive=is_interactive, resource_display_name=resource_display_name, resource_id=resource_id, risk_detail=risk_detail, risk_event_types=risk_event_types, risk_event_types_v2=risk_event_types_v2, risk_level_aggregated=risk_level_aggregated, risk_level_during_sign_in=risk_level_during_sign_in, risk_state=risk_state, status=status, user_display_name=user_display_name, user_id=user_id, user_principal_name=user_principal_name, city=city, country_or_region=country_or_region, geo_coordinates=geo_coordinates, state=state)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sign_in.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSignIn')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSignIn', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sign_in.metadata = {'url': '/auditLogs/signIns'}  # type: ignore

    async def get_sign_in(
        self,
        sign_in_id: str,
        select: Optional[List[Union[str, "models.Enum18"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSignIn":
        """Get signIns from auditLogs.

        Get signIns from auditLogs.

        :param sign_in_id: key: id of signIn.
        :type sign_in_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum18]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSignIn, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphSignIn
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSignIn"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sign_in.metadata['url']  # type: ignore
        path_format_arguments = {
            'signIn-id': self._serialize.url("sign_in_id", sign_in_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSignIn', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sign_in.metadata = {'url': '/auditLogs/signIns/{signIn-id}'}  # type: ignore

    async def update_sign_in(
        self,
        sign_in_id: str,
        id: Optional[str] = None,
        app_display_name: Optional[str] = None,
        app_id: Optional[str] = None,
        applied_conditional_access_policies: Optional[List["models.MicrosoftGraphAppliedConditionalAccessPolicy"]] = None,
        client_app_used: Optional[str] = None,
        conditional_access_status: Optional[Union[str, "models.MicrosoftGraphConditionalAccessStatus"]] = None,
        correlation_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        device_detail: Optional["models.MicrosoftGraphDeviceDetail"] = None,
        ip_address: Optional[str] = None,
        is_interactive: Optional[bool] = None,
        resource_display_name: Optional[str] = None,
        resource_id: Optional[str] = None,
        risk_detail: Optional[Union[str, "models.MicrosoftGraphRiskDetail"]] = None,
        risk_event_types: Optional[List[Union[str, "models.MicrosoftGraphRiskEventType"]]] = None,
        risk_event_types_v2: Optional[List[str]] = None,
        risk_level_aggregated: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_level_during_sign_in: Optional[Union[str, "models.MicrosoftGraphRiskLevel"]] = None,
        risk_state: Optional[Union[str, "models.MicrosoftGraphRiskState"]] = None,
        status: Optional["models.MicrosoftGraphSignInStatus"] = None,
        user_display_name: Optional[str] = None,
        user_id: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        city: Optional[str] = None,
        country_or_region: Optional[str] = None,
        geo_coordinates: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        state: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property signIns in auditLogs.

        Update the navigation property signIns in auditLogs.

        :param sign_in_id: key: id of signIn.
        :type sign_in_id: str
        :param id: Read-only.
        :type id: str
        :param app_display_name: App name displayed in the Azure Portal.
        :type app_display_name: str
        :param app_id: Unique GUID representing the app ID in the Azure Active Directory.
        :type app_id: str
        :param applied_conditional_access_policies:
        :type applied_conditional_access_policies: list[~reports.models.MicrosoftGraphAppliedConditionalAccessPolicy]
        :param client_app_used: Identifies the legacy client used for sign-in activity.  Includes
         Browser, Exchange Active Sync, modern clients, IMAP, MAPI, SMTP, and POP.
        :type client_app_used: str
        :param conditional_access_status:
        :type conditional_access_status: str or ~reports.models.MicrosoftGraphConditionalAccessStatus
        :param correlation_id: The request ID sent from the client when the sign-in is initiated; used
         to troubleshoot sign-in activity.
        :type correlation_id: str
        :param created_date_time: Date and time (UTC) the sign-in was initiated. Example: midnight on
         Jan 1, 2014 is reported as '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param device_detail: deviceDetail.
        :type device_detail: ~reports.models.MicrosoftGraphDeviceDetail
        :param ip_address: IP address of the client used to sign in.
        :type ip_address: str
        :param is_interactive: Indicates if a sign-in is interactive or not.
        :type is_interactive: bool
        :param resource_display_name: Name of the resource the user signed into.
        :type resource_display_name: str
        :param resource_id: ID of the resource that the user signed into.
        :type resource_id: str
        :param risk_detail:
        :type risk_detail: str or ~reports.models.MicrosoftGraphRiskDetail
        :param risk_event_types: Risk event types associated with the sign-in. The possible values are:
         unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, and unknownFutureValue.
        :type risk_event_types: list[str or ~reports.models.MicrosoftGraphRiskEventType]
        :param risk_event_types_v2: The list of risk event types associated with the sign-in. Possible
         values: unlikelyTravel, anonymizedIPAddress, maliciousIPAddress, unfamiliarFeatures,
         malwareInfectedIPAddress, suspiciousIPAddress, leakedCredentials,
         investigationsThreatIntelligence,  generic, or unknownFutureValue.
        :type risk_event_types_v2: list[str]
        :param risk_level_aggregated:
        :type risk_level_aggregated: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_level_during_sign_in:
        :type risk_level_during_sign_in: str or ~reports.models.MicrosoftGraphRiskLevel
        :param risk_state:
        :type risk_state: str or ~reports.models.MicrosoftGraphRiskState
        :param status: signInStatus.
        :type status: ~reports.models.MicrosoftGraphSignInStatus
        :param user_display_name: Display name of the user that initiated the sign-in.
        :type user_display_name: str
        :param user_id: ID of the user that initiated the sign-in.
        :type user_id: str
        :param user_principal_name: User principal name of the user that initiated the sign-in.
        :type user_principal_name: str
        :param city: Provides the city where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type city: str
        :param country_or_region: Provides the country code info (2 letter code) where the sign-in
         originated.  This is calculated using latitude/longitude information from the sign-in activity.
        :type country_or_region: str
        :param geo_coordinates: geoCoordinates.
        :type geo_coordinates: ~reports.models.MicrosoftGraphGeoCoordinates
        :param state: Provides the State where the sign-in originated. This is calculated using
         latitude/longitude information from the sign-in activity.
        :type state: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSignIn(id=id, app_display_name=app_display_name, app_id=app_id, applied_conditional_access_policies=applied_conditional_access_policies, client_app_used=client_app_used, conditional_access_status=conditional_access_status, correlation_id=correlation_id, created_date_time=created_date_time, device_detail=device_detail, ip_address=ip_address, is_interactive=is_interactive, resource_display_name=resource_display_name, resource_id=resource_id, risk_detail=risk_detail, risk_event_types=risk_event_types, risk_event_types_v2=risk_event_types_v2, risk_level_aggregated=risk_level_aggregated, risk_level_during_sign_in=risk_level_during_sign_in, risk_state=risk_state, status=status, user_display_name=user_display_name, user_id=user_id, user_principal_name=user_principal_name, city=city, country_or_region=country_or_region, geo_coordinates=geo_coordinates, state=state)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sign_in.metadata['url']  # type: ignore
        path_format_arguments = {
            'signIn-id': self._serialize.url("sign_in_id", sign_in_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSignIn')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sign_in.metadata = {'url': '/auditLogs/signIns/{signIn-id}'}  # type: ignore

    async def delete_sign_in(
        self,
        sign_in_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property signIns for auditLogs.

        Delete navigation property signIns for auditLogs.

        :param sign_in_id: key: id of signIn.
        :type sign_in_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sign_in.metadata['url']  # type: ignore
        path_format_arguments = {
            'signIn-id': self._serialize.url("sign_in_id", sign_in_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sign_in.metadata = {'url': '/auditLogs/signIns/{signIn-id}'}  # type: ignore
