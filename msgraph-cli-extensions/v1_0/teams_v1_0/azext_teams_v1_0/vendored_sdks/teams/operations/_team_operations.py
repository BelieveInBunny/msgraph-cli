# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class TeamOperations(object):
    """TeamOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~teams.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_channel(
        self,
        team_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum67"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum68"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Get8ItemsItem"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfChannel"]
        """Get channels from teams.

        Get channels from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum67]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum68]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Get8ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfChannel or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~teams.models.CollectionOfChannel]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_channel.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfChannel', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_channel.metadata = {'url': '/teams/{team-id}/channels'}  # type: ignore

    def create_channel(
        self,
        team_id,  # type: str
        id=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        email=None,  # type: Optional[str]
        membership_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphChannelMembershipType"]]
        web_url=None,  # type: Optional[str]
        files_folder=None,  # type: Optional["models.MicrosoftGraphDriveItem"]
        members=None,  # type: Optional[List["models.MicrosoftGraphConversationMember"]]
        messages=None,  # type: Optional[List["models.MicrosoftGraphChatMessage"]]
        tabs=None,  # type: Optional[List["models.MicrosoftGraphTeamsTab"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphChannel"
        """Create new navigation property to channels for teams.

        Create new navigation property to channels for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param description: Optional textual description for the channel.
        :type description: str
        :param display_name: Channel name as it will appear to the user in Microsoft Teams.
        :type display_name: str
        :param email: The email address for sending messages to the channel. Read-only.
        :type email: str
        :param membership_type:
        :type membership_type: str or ~teams.models.MicrosoftGraphChannelMembershipType
        :param web_url: A hyperlink that will navigate to the channel in Microsoft Teams. This is the
         URL that you get when you right-click a channel in Microsoft Teams and select Get link to
         channel. This URL should be treated as an opaque blob, and not parsed. Read-only.
        :type web_url: str
        :param files_folder: driveItem.
        :type files_folder: ~teams.models.MicrosoftGraphDriveItem
        :param members:
        :type members: list[~teams.models.MicrosoftGraphConversationMember]
        :param messages: A collection of all the messages in the channel. A navigation property.
         Nullable.
        :type messages: list[~teams.models.MicrosoftGraphChatMessage]
        :param tabs: A collection of all the tabs in the channel. A navigation property.
        :type tabs: list[~teams.models.MicrosoftGraphTeamsTab]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphChannel, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphChannel
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphChannel(id=id, description=description, display_name=display_name, email=email, membership_type=membership_type, web_url=web_url, files_folder=files_folder, members=members, messages=messages, tabs=tabs)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphChannel')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphChannel', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_channel.metadata = {'url': '/teams/{team-id}/channels'}  # type: ignore

    def get_channel(
        self,
        team_id,  # type: str
        channel_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum70"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Get3ItemsItem"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphChannel"
        """Get channels from teams.

        Get channels from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param channel_id: key: id of channel.
        :type channel_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum70]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Get3ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphChannel, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphChannel
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'channel-id': self._serialize.url("channel_id", channel_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphChannel', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_channel.metadata = {'url': '/teams/{team-id}/channels/{channel-id}'}  # type: ignore

    def update_channel(
        self,
        team_id,  # type: str
        channel_id,  # type: str
        id=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        email=None,  # type: Optional[str]
        membership_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphChannelMembershipType"]]
        web_url=None,  # type: Optional[str]
        files_folder=None,  # type: Optional["models.MicrosoftGraphDriveItem"]
        members=None,  # type: Optional[List["models.MicrosoftGraphConversationMember"]]
        messages=None,  # type: Optional[List["models.MicrosoftGraphChatMessage"]]
        tabs=None,  # type: Optional[List["models.MicrosoftGraphTeamsTab"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property channels in teams.

        Update the navigation property channels in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param channel_id: key: id of channel.
        :type channel_id: str
        :param id: Read-only.
        :type id: str
        :param description: Optional textual description for the channel.
        :type description: str
        :param display_name: Channel name as it will appear to the user in Microsoft Teams.
        :type display_name: str
        :param email: The email address for sending messages to the channel. Read-only.
        :type email: str
        :param membership_type:
        :type membership_type: str or ~teams.models.MicrosoftGraphChannelMembershipType
        :param web_url: A hyperlink that will navigate to the channel in Microsoft Teams. This is the
         URL that you get when you right-click a channel in Microsoft Teams and select Get link to
         channel. This URL should be treated as an opaque blob, and not parsed. Read-only.
        :type web_url: str
        :param files_folder: driveItem.
        :type files_folder: ~teams.models.MicrosoftGraphDriveItem
        :param members:
        :type members: list[~teams.models.MicrosoftGraphConversationMember]
        :param messages: A collection of all the messages in the channel. A navigation property.
         Nullable.
        :type messages: list[~teams.models.MicrosoftGraphChatMessage]
        :param tabs: A collection of all the tabs in the channel. A navigation property.
        :type tabs: list[~teams.models.MicrosoftGraphTeamsTab]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphChannel(id=id, description=description, display_name=display_name, email=email, membership_type=membership_type, web_url=web_url, files_folder=files_folder, members=members, messages=messages, tabs=tabs)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'channel-id': self._serialize.url("channel_id", channel_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphChannel')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_channel.metadata = {'url': '/teams/{team-id}/channels/{channel-id}'}  # type: ignore

    def delete_channel(
        self,
        team_id,  # type: str
        channel_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property channels for teams.

        Delete navigation property channels for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param channel_id: key: id of channel.
        :type channel_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'channel-id': self._serialize.url("channel_id", channel_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_channel.metadata = {'url': '/teams/{team-id}/channels/{channel-id}'}  # type: ignore

    def get_group(
        self,
        team_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum95"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum96"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphGroup"
        """Get group from teams.

        Get group from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum95]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum96]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphGroup, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphGroup
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphGroup"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphGroup', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_group.metadata = {'url': '/teams/{team-id}/group'}  # type: ignore

    def get_ref_group(
        self,
        team_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> str
        """Get ref of group from teams.

        Get ref of group from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_ref_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_ref_group.metadata = {'url': '/teams/{team-id}/group/$ref'}  # type: ignore

    def set_ref_group(
        self,
        team_id,  # type: str
        body,  # type: Dict[str, object]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the ref of navigation property group in teams.

        Update the ref of navigation property group in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param body: New navigation property ref values.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.set_ref_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_ref_group.metadata = {'url': '/teams/{team-id}/group/$ref'}  # type: ignore

    def delete_ref_group(
        self,
        team_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete ref of navigation property group for teams.

        Delete ref of navigation property group for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_ref_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_ref_group.metadata = {'url': '/teams/{team-id}/group/$ref'}  # type: ignore

    def list_installed_app(
        self,
        team_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum97"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum98"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum99"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfTeamsAppInstallation"]
        """Get installedApps from teams.

        Get installedApps from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum97]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum98]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum99]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTeamsAppInstallation or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~teams.models.CollectionOfTeamsAppInstallation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTeamsAppInstallation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_installed_app.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTeamsAppInstallation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_installed_app.metadata = {'url': '/teams/{team-id}/installedApps'}  # type: ignore

    def create_installed_app(
        self,
        team_id,  # type: str
        id=None,  # type: Optional[str]
        teams_app_definition=None,  # type: Optional["models.MicrosoftGraphTeamsAppDefinition"]
        microsoft_graph_entity_id=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        distribution_method=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamsAppDistributionMethod"]]
        external_id=None,  # type: Optional[str]
        app_definitions=None,  # type: Optional[List["models.MicrosoftGraphTeamsAppDefinition"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTeamsAppInstallation"
        """Create new navigation property to installedApps for teams.

        Create new navigation property to installedApps for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param teams_app_definition: teamsAppDefinition.
        :type teams_app_definition: ~teams.models.MicrosoftGraphTeamsAppDefinition
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param display_name: The name of the catalog app provided by the app developer in the Microsoft
         Teams zip app package.
        :type display_name: str
        :param distribution_method:
        :type distribution_method: str or ~teams.models.MicrosoftGraphTeamsAppDistributionMethod
        :param external_id: The ID of the catalog provided by the app developer in the Microsoft Teams
         zip app package.
        :type external_id: str
        :param app_definitions: The details for each version of the app.
        :type app_definitions: list[~teams.models.MicrosoftGraphTeamsAppDefinition]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAppInstallation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAppInstallation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAppInstallation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAppInstallation(id=id, teams_app_definition=teams_app_definition, id_teams_app_id=microsoft_graph_entity_id, display_name=display_name, distribution_method=distribution_method, external_id=external_id, app_definitions=app_definitions)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAppInstallation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAppInstallation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_installed_app.metadata = {'url': '/teams/{team-id}/installedApps'}  # type: ignore

    def get_installed_app(
        self,
        team_id,  # type: str
        teams_app_installation_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum100"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum101"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTeamsAppInstallation"
        """Get installedApps from teams.

        Get installedApps from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_app_installation_id: key: id of teamsAppInstallation.
        :type teams_app_installation_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum100]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum101]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAppInstallation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAppInstallation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAppInstallation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAppInstallation-id': self._serialize.url("teams_app_installation_id", teams_app_installation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAppInstallation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_installed_app.metadata = {'url': '/teams/{team-id}/installedApps/{teamsAppInstallation-id}'}  # type: ignore

    def update_installed_app(
        self,
        team_id,  # type: str
        teams_app_installation_id,  # type: str
        id=None,  # type: Optional[str]
        teams_app_definition=None,  # type: Optional["models.MicrosoftGraphTeamsAppDefinition"]
        microsoft_graph_entity_id=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        distribution_method=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamsAppDistributionMethod"]]
        external_id=None,  # type: Optional[str]
        app_definitions=None,  # type: Optional[List["models.MicrosoftGraphTeamsAppDefinition"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property installedApps in teams.

        Update the navigation property installedApps in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_app_installation_id: key: id of teamsAppInstallation.
        :type teams_app_installation_id: str
        :param id: Read-only.
        :type id: str
        :param teams_app_definition: teamsAppDefinition.
        :type teams_app_definition: ~teams.models.MicrosoftGraphTeamsAppDefinition
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param display_name: The name of the catalog app provided by the app developer in the Microsoft
         Teams zip app package.
        :type display_name: str
        :param distribution_method:
        :type distribution_method: str or ~teams.models.MicrosoftGraphTeamsAppDistributionMethod
        :param external_id: The ID of the catalog provided by the app developer in the Microsoft Teams
         zip app package.
        :type external_id: str
        :param app_definitions: The details for each version of the app.
        :type app_definitions: list[~teams.models.MicrosoftGraphTeamsAppDefinition]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAppInstallation(id=id, teams_app_definition=teams_app_definition, id_teams_app_id=microsoft_graph_entity_id, display_name=display_name, distribution_method=distribution_method, external_id=external_id, app_definitions=app_definitions)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAppInstallation-id': self._serialize.url("teams_app_installation_id", teams_app_installation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAppInstallation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_installed_app.metadata = {'url': '/teams/{team-id}/installedApps/{teamsAppInstallation-id}'}  # type: ignore

    def delete_installed_app(
        self,
        team_id,  # type: str
        teams_app_installation_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property installedApps for teams.

        Delete navigation property installedApps for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_app_installation_id: key: id of teamsAppInstallation.
        :type teams_app_installation_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAppInstallation-id': self._serialize.url("teams_app_installation_id", teams_app_installation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_installed_app.metadata = {'url': '/teams/{team-id}/installedApps/{teamsAppInstallation-id}'}  # type: ignore

    def list_member(
        self,
        team_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum105"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum106"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfConversationMember0"]
        """Get members from teams.

        Get members from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum105]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum106]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfConversationMember0 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~teams.models.CollectionOfConversationMember0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfConversationMember0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_member.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfConversationMember0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_member.metadata = {'url': '/teams/{team-id}/members'}  # type: ignore

    def create_member(
        self,
        team_id,  # type: str
        id=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        roles=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphConversationMember"
        """Create new navigation property to members for teams.

        Create new navigation property to members for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param display_name: The display name of the user.
        :type display_name: str
        :param roles: The roles for that user.
        :type roles: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConversationMember, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphConversationMember
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConversationMember"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConversationMember(id=id, display_name=display_name, roles=roles)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConversationMember')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConversationMember', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_member.metadata = {'url': '/teams/{team-id}/members'}  # type: ignore

    def get_member(
        self,
        team_id,  # type: str
        conversation_member_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum107"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphConversationMember"
        """Get members from teams.

        Get members from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param conversation_member_id: key: id of conversationMember.
        :type conversation_member_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum107]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConversationMember, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphConversationMember
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConversationMember"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'conversationMember-id': self._serialize.url("conversation_member_id", conversation_member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConversationMember', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_member.metadata = {'url': '/teams/{team-id}/members/{conversationMember-id}'}  # type: ignore

    def update_member(
        self,
        team_id,  # type: str
        conversation_member_id,  # type: str
        id=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        roles=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property members in teams.

        Update the navigation property members in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param conversation_member_id: key: id of conversationMember.
        :type conversation_member_id: str
        :param id: Read-only.
        :type id: str
        :param display_name: The display name of the user.
        :type display_name: str
        :param roles: The roles for that user.
        :type roles: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConversationMember(id=id, display_name=display_name, roles=roles)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'conversationMember-id': self._serialize.url("conversation_member_id", conversation_member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConversationMember')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_member.metadata = {'url': '/teams/{team-id}/members/{conversationMember-id}'}  # type: ignore

    def delete_member(
        self,
        team_id,  # type: str
        conversation_member_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property members for teams.

        Delete navigation property members for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param conversation_member_id: key: id of conversationMember.
        :type conversation_member_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'conversationMember-id': self._serialize.url("conversation_member_id", conversation_member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_member.metadata = {'url': '/teams/{team-id}/members/{conversationMember-id}'}  # type: ignore

    def archive(
        self,
        team_id,  # type: str
        should_set_spo_site_read_only_for_members=False,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Invoke action archive.

        Invoke action archive.

        :param team_id: key: id of team.
        :type team_id: str
        :param should_set_spo_site_read_only_for_members:
        :type should_set_spo_site_read_only_for_members: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsBezc4TeamsTeamIdMicrosoftGraphArchivePostRequestbodyContentApplicationJsonSchema(should_set_spo_site_read_only_for_members=should_set_spo_site_read_only_for_members)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.archive.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsBezc4TeamsTeamIdMicrosoftGraphArchivePostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    archive.metadata = {'url': '/teams/{team-id}/microsoft.graph.archive'}  # type: ignore

    def clone(
        self,
        team_id,  # type: str
        display_name=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        mail_nickname=None,  # type: Optional[str]
        classification=None,  # type: Optional[str]
        visibility=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamVisibilityType"]]
        parts_to_clone=None,  # type: Optional[Union[str, "models.MicrosoftGraphClonableTeamParts"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Invoke action clone.

        Invoke action clone.

        :param team_id: key: id of team.
        :type team_id: str
        :param display_name:
        :type display_name: str
        :param description:
        :type description: str
        :param mail_nickname:
        :type mail_nickname: str
        :param classification:
        :type classification: str
        :param visibility:
        :type visibility: str or ~teams.models.MicrosoftGraphTeamVisibilityType
        :param parts_to_clone:
        :type parts_to_clone: str or ~teams.models.MicrosoftGraphClonableTeamParts
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1Izic0UTeamsTeamIdMicrosoftGraphClonePostRequestbodyContentApplicationJsonSchema(display_name=display_name, description=description, mail_nickname=mail_nickname, classification=classification, visibility=visibility, parts_to_clone=parts_to_clone)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.clone.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1Izic0UTeamsTeamIdMicrosoftGraphClonePostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    clone.metadata = {'url': '/teams/{team-id}/microsoft.graph.clone'}  # type: ignore

    def unarchive(
        self,
        team_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Invoke action unarchive.

        Invoke action unarchive.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.unarchive.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    unarchive.metadata = {'url': '/teams/{team-id}/microsoft.graph.unarchive'}  # type: ignore

    def list_operation(
        self,
        team_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum109"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum110"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfTeamsAsyncOperation"]
        """Get operations from teams.

        Get operations from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum109]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum110]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTeamsAsyncOperation or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~teams.models.CollectionOfTeamsAsyncOperation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTeamsAsyncOperation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_operation.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTeamsAsyncOperation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_operation.metadata = {'url': '/teams/{team-id}/operations'}  # type: ignore

    def create_operation(
        self,
        team_id,  # type: str
        id=None,  # type: Optional[str]
        attempts_count=None,  # type: Optional[int]
        created_date_time=None,  # type: Optional[datetime.datetime]
        error=None,  # type: Optional["models.MicrosoftGraphOperationError"]
        last_action_date_time=None,  # type: Optional[datetime.datetime]
        operation_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationType"]]
        status=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationStatus"]]
        target_resource_id=None,  # type: Optional[str]
        target_resource_location=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTeamsAsyncOperation"
        """Create new navigation property to operations for teams.

        Create new navigation property to operations for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param attempts_count: Number of times the operation was attempted before being marked
         successful or failed.
        :type attempts_count: int
        :param created_date_time: Time when the operation was created.
        :type created_date_time: ~datetime.datetime
        :param error: operationError.
        :type error: ~teams.models.MicrosoftGraphOperationError
        :param last_action_date_time: Time when the async operation was last updated.
        :type last_action_date_time: ~datetime.datetime
        :param operation_type:
        :type operation_type: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationType
        :param status:
        :type status: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationStatus
        :param target_resource_id: The ID of the object that's created or modified as result of this
         async operation, typically a team.
        :type target_resource_id: str
        :param target_resource_location: The location of the object that's created or modified as
         result of this async operation. This URL should be treated as an opaque value and not parsed
         into its component paths.
        :type target_resource_location: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAsyncOperation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAsyncOperation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAsyncOperation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAsyncOperation(id=id, attempts_count=attempts_count, created_date_time=created_date_time, error=error, last_action_date_time=last_action_date_time, operation_type=operation_type, status=status, target_resource_id=target_resource_id, target_resource_location=target_resource_location)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAsyncOperation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAsyncOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_operation.metadata = {'url': '/teams/{team-id}/operations'}  # type: ignore

    def get_operation(
        self,
        team_id,  # type: str
        teams_async_operation_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum111"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTeamsAsyncOperation"
        """Get operations from teams.

        Get operations from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_async_operation_id: key: id of teamsAsyncOperation.
        :type teams_async_operation_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum111]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAsyncOperation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAsyncOperation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAsyncOperation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAsyncOperation-id': self._serialize.url("teams_async_operation_id", teams_async_operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAsyncOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_operation.metadata = {'url': '/teams/{team-id}/operations/{teamsAsyncOperation-id}'}  # type: ignore

    def update_operation(
        self,
        team_id,  # type: str
        teams_async_operation_id,  # type: str
        id=None,  # type: Optional[str]
        attempts_count=None,  # type: Optional[int]
        created_date_time=None,  # type: Optional[datetime.datetime]
        error=None,  # type: Optional["models.MicrosoftGraphOperationError"]
        last_action_date_time=None,  # type: Optional[datetime.datetime]
        operation_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationType"]]
        status=None,  # type: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationStatus"]]
        target_resource_id=None,  # type: Optional[str]
        target_resource_location=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property operations in teams.

        Update the navigation property operations in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_async_operation_id: key: id of teamsAsyncOperation.
        :type teams_async_operation_id: str
        :param id: Read-only.
        :type id: str
        :param attempts_count: Number of times the operation was attempted before being marked
         successful or failed.
        :type attempts_count: int
        :param created_date_time: Time when the operation was created.
        :type created_date_time: ~datetime.datetime
        :param error: operationError.
        :type error: ~teams.models.MicrosoftGraphOperationError
        :param last_action_date_time: Time when the async operation was last updated.
        :type last_action_date_time: ~datetime.datetime
        :param operation_type:
        :type operation_type: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationType
        :param status:
        :type status: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationStatus
        :param target_resource_id: The ID of the object that's created or modified as result of this
         async operation, typically a team.
        :type target_resource_id: str
        :param target_resource_location: The location of the object that's created or modified as
         result of this async operation. This URL should be treated as an opaque value and not parsed
         into its component paths.
        :type target_resource_location: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAsyncOperation(id=id, attempts_count=attempts_count, created_date_time=created_date_time, error=error, last_action_date_time=last_action_date_time, operation_type=operation_type, status=status, target_resource_id=target_resource_id, target_resource_location=target_resource_location)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAsyncOperation-id': self._serialize.url("teams_async_operation_id", teams_async_operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAsyncOperation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_operation.metadata = {'url': '/teams/{team-id}/operations/{teamsAsyncOperation-id}'}  # type: ignore

    def delete_operation(
        self,
        team_id,  # type: str
        teams_async_operation_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property operations for teams.

        Delete navigation property operations for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_async_operation_id: key: id of teamsAsyncOperation.
        :type teams_async_operation_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAsyncOperation-id': self._serialize.url("teams_async_operation_id", teams_async_operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_operation.metadata = {'url': '/teams/{team-id}/operations/{teamsAsyncOperation-id}'}  # type: ignore

    def get_primary_channel(
        self,
        team_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum112"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum113"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphChannel"
        """Get primaryChannel from teams.

        Get primaryChannel from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum112]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum113]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphChannel, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphChannel
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_primary_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphChannel', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_primary_channel.metadata = {'url': '/teams/{team-id}/primaryChannel'}  # type: ignore

    def update_primary_channel(
        self,
        team_id,  # type: str
        id=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        email=None,  # type: Optional[str]
        membership_type=None,  # type: Optional[Union[str, "models.MicrosoftGraphChannelMembershipType"]]
        web_url=None,  # type: Optional[str]
        files_folder=None,  # type: Optional["models.MicrosoftGraphDriveItem"]
        members=None,  # type: Optional[List["models.MicrosoftGraphConversationMember"]]
        messages=None,  # type: Optional[List["models.MicrosoftGraphChatMessage"]]
        tabs=None,  # type: Optional[List["models.MicrosoftGraphTeamsTab"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property primaryChannel in teams.

        Update the navigation property primaryChannel in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param description: Optional textual description for the channel.
        :type description: str
        :param display_name: Channel name as it will appear to the user in Microsoft Teams.
        :type display_name: str
        :param email: The email address for sending messages to the channel. Read-only.
        :type email: str
        :param membership_type:
        :type membership_type: str or ~teams.models.MicrosoftGraphChannelMembershipType
        :param web_url: A hyperlink that will navigate to the channel in Microsoft Teams. This is the
         URL that you get when you right-click a channel in Microsoft Teams and select Get link to
         channel. This URL should be treated as an opaque blob, and not parsed. Read-only.
        :type web_url: str
        :param files_folder: driveItem.
        :type files_folder: ~teams.models.MicrosoftGraphDriveItem
        :param members:
        :type members: list[~teams.models.MicrosoftGraphConversationMember]
        :param messages: A collection of all the messages in the channel. A navigation property.
         Nullable.
        :type messages: list[~teams.models.MicrosoftGraphChatMessage]
        :param tabs: A collection of all the tabs in the channel. A navigation property.
        :type tabs: list[~teams.models.MicrosoftGraphTeamsTab]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphChannel(id=id, description=description, display_name=display_name, email=email, membership_type=membership_type, web_url=web_url, files_folder=files_folder, members=members, messages=messages, tabs=tabs)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_primary_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphChannel')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_primary_channel.metadata = {'url': '/teams/{team-id}/primaryChannel'}  # type: ignore

    def delete_primary_channel(
        self,
        team_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property primaryChannel for teams.

        Delete navigation property primaryChannel for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_primary_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_primary_channel.metadata = {'url': '/teams/{team-id}/primaryChannel'}  # type: ignore

    def get_schedule(
        self,
        team_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum137"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum138"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphSchedule"
        """Get schedule from teams.

        Get schedule from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum137]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum138]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSchedule, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphSchedule
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSchedule"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSchedule', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_schedule.metadata = {'url': '/teams/{team-id}/schedule'}  # type: ignore

    def update_schedule(
        self,
        team_id,  # type: str
        id=None,  # type: Optional[str]
        enabled=None,  # type: Optional[bool]
        offer_shift_requests_enabled=None,  # type: Optional[bool]
        open_shifts_enabled=None,  # type: Optional[bool]
        provision_status=None,  # type: Optional[Union[str, "models.MicrosoftGraphOperationStatus"]]
        provision_status_code=None,  # type: Optional[str]
        swap_shifts_requests_enabled=None,  # type: Optional[bool]
        time_clock_enabled=None,  # type: Optional[bool]
        time_off_requests_enabled=None,  # type: Optional[bool]
        time_zone=None,  # type: Optional[str]
        workforce_integration_ids=None,  # type: Optional[List[str]]
        offer_shift_requests=None,  # type: Optional[List["models.MicrosoftGraphOfferShiftRequest"]]
        open_shift_change_requests=None,  # type: Optional[List["models.MicrosoftGraphOpenShiftChangeRequest"]]
        open_shifts=None,  # type: Optional[List["models.MicrosoftGraphOpenShift"]]
        scheduling_groups=None,  # type: Optional[List["models.MicrosoftGraphSchedulingGroup"]]
        shifts=None,  # type: Optional[List["models.MicrosoftGraphShift"]]
        swap_shifts_change_requests=None,  # type: Optional[List["models.MicrosoftGraphSwapShiftsChangeRequest"]]
        time_off_reasons=None,  # type: Optional[List["models.MicrosoftGraphTimeOffReason"]]
        time_off_requests=None,  # type: Optional[List["models.MicrosoftGraphTimeOffRequest"]]
        times_off=None,  # type: Optional[List["models.MicrosoftGraphTimeOff"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property schedule in teams.

        Update the navigation property schedule in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param enabled: Indicates whether the schedule is enabled for the team. Required.
        :type enabled: bool
        :param offer_shift_requests_enabled: Indicates whether offer shift requests are enabled for the
         schedule.
        :type offer_shift_requests_enabled: bool
        :param open_shifts_enabled: Indicates whether open shifts are enabled for the schedule.
        :type open_shifts_enabled: bool
        :param provision_status:
        :type provision_status: str or ~teams.models.MicrosoftGraphOperationStatus
        :param provision_status_code: Additional information about why schedule provisioning failed.
        :type provision_status_code: str
        :param swap_shifts_requests_enabled: Indicates whether swap shifts requests are enabled for the
         schedule.
        :type swap_shifts_requests_enabled: bool
        :param time_clock_enabled: Indicates whether time clock is enabled for the schedule.
        :type time_clock_enabled: bool
        :param time_off_requests_enabled: Indicates whether time off requests are enabled for the
         schedule.
        :type time_off_requests_enabled: bool
        :param time_zone: Indicates the time zone of the schedule team using tz database format.
         Required.
        :type time_zone: str
        :param workforce_integration_ids:
        :type workforce_integration_ids: list[str]
        :param offer_shift_requests:
        :type offer_shift_requests: list[~teams.models.MicrosoftGraphOfferShiftRequest]
        :param open_shift_change_requests:
        :type open_shift_change_requests: list[~teams.models.MicrosoftGraphOpenShiftChangeRequest]
        :param open_shifts:
        :type open_shifts: list[~teams.models.MicrosoftGraphOpenShift]
        :param scheduling_groups: The logical grouping of users in the schedule (usually by role).
        :type scheduling_groups: list[~teams.models.MicrosoftGraphSchedulingGroup]
        :param shifts: The shifts in the schedule.
        :type shifts: list[~teams.models.MicrosoftGraphShift]
        :param swap_shifts_change_requests:
        :type swap_shifts_change_requests: list[~teams.models.MicrosoftGraphSwapShiftsChangeRequest]
        :param time_off_reasons: The set of reasons for a time off in the schedule.
        :type time_off_reasons: list[~teams.models.MicrosoftGraphTimeOffReason]
        :param time_off_requests:
        :type time_off_requests: list[~teams.models.MicrosoftGraphTimeOffRequest]
        :param times_off: The instances of times off in the schedule.
        :type times_off: list[~teams.models.MicrosoftGraphTimeOff]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSchedule(id=id, enabled=enabled, offer_shift_requests_enabled=offer_shift_requests_enabled, open_shifts_enabled=open_shifts_enabled, provision_status=provision_status, provision_status_code=provision_status_code, swap_shifts_requests_enabled=swap_shifts_requests_enabled, time_clock_enabled=time_clock_enabled, time_off_requests_enabled=time_off_requests_enabled, time_zone=time_zone, workforce_integration_ids=workforce_integration_ids, offer_shift_requests=offer_shift_requests, open_shift_change_requests=open_shift_change_requests, open_shifts=open_shifts, scheduling_groups=scheduling_groups, shifts=shifts, swap_shifts_change_requests=swap_shifts_change_requests, time_off_reasons=time_off_reasons, time_off_requests=time_off_requests, times_off=times_off)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSchedule')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_schedule.metadata = {'url': '/teams/{team-id}/schedule'}  # type: ignore

    def delete_schedule(
        self,
        team_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property schedule for teams.

        Delete navigation property schedule for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_schedule.metadata = {'url': '/teams/{team-id}/schedule'}  # type: ignore

    def get_template(
        self,
        team_id,  # type: str
        select=None,  # type: Optional[List[str]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTeamsTemplate"
        """Get template from teams.

        Get template from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsTemplate, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsTemplate
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsTemplate"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsTemplate', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_template.metadata = {'url': '/teams/{team-id}/template'}  # type: ignore

    def get_ref_template(
        self,
        team_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> str
        """Get ref of template from teams.

        Get ref of template from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_ref_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_ref_template.metadata = {'url': '/teams/{team-id}/template/$ref'}  # type: ignore

    def set_ref_template(
        self,
        team_id,  # type: str
        body,  # type: Dict[str, object]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the ref of navigation property template in teams.

        Update the ref of navigation property template in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param body: New navigation property ref values.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.set_ref_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_ref_template.metadata = {'url': '/teams/{team-id}/template/$ref'}  # type: ignore

    def delete_ref_template(
        self,
        team_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete ref of navigation property template for teams.

        Delete ref of navigation property template for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_ref_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_ref_template.metadata = {'url': '/teams/{team-id}/template/$ref'}  # type: ignore

    def get_all_message(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphChatMessage"]
        """Invoke function getAllMessages.

        Invoke function getAllMessages.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphChatMessage, or the result of cls(response)
        :rtype: list[~teams.models.MicrosoftGraphChatMessage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphChatMessage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_all_message.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphChatMessage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_message.metadata = {'url': '/teams/microsoft.graph.getAllMessages()'}  # type: ignore
