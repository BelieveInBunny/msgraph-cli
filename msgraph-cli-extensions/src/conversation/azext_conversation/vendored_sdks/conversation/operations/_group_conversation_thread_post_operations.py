# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class GroupConversationThreadPostOperations(object):
    """GroupConversationThreadPostOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~groups_conversation.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_attachment(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum17"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum18"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfAttachment"]
        """Get attachments from groups.

        Get attachments from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~groups_conversation.models.Enum17]
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum18]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAttachment or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~groups_conversation.models.CollectionOfAttachment]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAttachment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_attachment.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
                    'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
                    'post-id': self._serialize.url("post_id", post_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAttachment', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_attachment.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments'}  # type: ignore

    def create_attachment(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        id=None,  # type: Optional[str]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        name=None,  # type: Optional[str]
        content_type_parameter=None,  # type: Optional[str]
        size=None,  # type: Optional[int]
        is_inline=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAttachment"
        """Create new navigation property to attachments for groups.

        Create new navigation property to attachments for groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param id: Read-only.
        :type id: str
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param name: The attachment's file name.
        :type name: str
        :param content_type_parameter: The MIME type.
        :type content_type_parameter: str
        :param size: The length of the attachment in bytes.
        :type size: int
        :param is_inline: true if the attachment is an inline attachment; otherwise, false.
        :type is_inline: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAttachment, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphAttachment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAttachment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAttachment(id=id, last_modified_date_time=last_modified_date_time, name=name, content_type=content_type_parameter, size=size, is_inline=is_inline)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAttachment')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAttachment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_attachment.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments'}  # type: ignore

    def get_attachment(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        attachment_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum19"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAttachment"
        """Get attachments from groups.

        Get attachments from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param attachment_id: key: attachment-id of attachment.
        :type attachment_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum19]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAttachment, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphAttachment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAttachment"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'attachment-id': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAttachment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_attachment.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}'}  # type: ignore

    def update_attachment(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        attachment_id,  # type: str
        id=None,  # type: Optional[str]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        name=None,  # type: Optional[str]
        content_type_parameter=None,  # type: Optional[str]
        size=None,  # type: Optional[int]
        is_inline=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property attachments in groups.

        Update the navigation property attachments in groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param attachment_id: key: attachment-id of attachment.
        :type attachment_id: str
        :param id: Read-only.
        :type id: str
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param name: The attachment's file name.
        :type name: str
        :param content_type_parameter: The MIME type.
        :type content_type_parameter: str
        :param size: The length of the attachment in bytes.
        :type size: int
        :param is_inline: true if the attachment is an inline attachment; otherwise, false.
        :type is_inline: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAttachment(id=id, last_modified_date_time=last_modified_date_time, name=name, content_type=content_type_parameter, size=size, is_inline=is_inline)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'attachment-id': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAttachment')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_attachment.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/attachments/{attachment-id}'}  # type: ignore

    def list_extension(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum20"]]]
        select=None,  # type: Optional[List[str]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfExtension"]
        """Get extensions from groups.

        Get extensions from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~groups_conversation.models.Enum20]
        :param select: Select properties to be returned.
        :type select: list[str]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfExtension or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~groups_conversation.models.CollectionOfExtension]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfExtension"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_extension.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
                    'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
                    'post-id': self._serialize.url("post_id", post_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfExtension', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_extension.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions'}  # type: ignore

    def create_extension(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEntity"
        """Create new navigation property to extensions for groups.

        Create new navigation property to extensions for groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param id: Read-only.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEntity, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphEntity
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEntity"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEntity(id=id)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_extension.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEntity')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEntity', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_extension.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions'}  # type: ignore

    def get_extension(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        extension_id,  # type: str
        select=None,  # type: Optional[List[str]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEntity"
        """Get extensions from groups.

        Get extensions from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param extension_id: key: extension-id of extension.
        :type extension_id: str
        :param select: Select properties to be returned.
        :type select: list[str]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEntity, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphEntity
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEntity"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_extension.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'extension-id': self._serialize.url("extension_id", extension_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEntity', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_extension.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}'}  # type: ignore

    def update_extension(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        extension_id,  # type: str
        id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property extensions in groups.

        Update the navigation property extensions in groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param extension_id: key: extension-id of extension.
        :type extension_id: str
        :param id: Read-only.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEntity(id=id)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_extension.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'extension-id': self._serialize.url("extension_id", extension_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEntity')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_extension.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/extensions/{extension-id}'}  # type: ignore

    def get_in_reply_to(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum21"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum22"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPost"
        """Get inReplyTo from groups.

        Get inReplyTo from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum21]
        :param expand: Expand related entities.
        :type expand: list[str or ~groups_conversation.models.Enum22]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPost, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphPost
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPost"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_in_reply_to.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPost', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_in_reply_to.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo'}  # type: ignore

    def update_in_reply_to(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        id=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        last_modified_date_time=None,  # type: Optional[datetime.datetime]
        change_key=None,  # type: Optional[str]
        categories=None,  # type: Optional[List[str]]
        body=None,  # type: Optional["models.MicrosoftGraphItemBody"]
        received_date_time=None,  # type: Optional[datetime.datetime]
        has_attachments=None,  # type: Optional[bool]
        microsoft_graph_post_conversation_thread_id_conversation_thread_id=None,  # type: Optional[str]
        new_participants=None,  # type: Optional[List["models.MicrosoftGraphRecipient"]]
        microsoft_graph_post_conversation_id=None,  # type: Optional[str]
        importance=None,  # type: Optional[Union[str, "models.MicrosoftGraphImportance"]]
        in_reply_to=None,  # type: Optional["models.MicrosoftGraphPost"]
        single_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]]
        multi_value_extended_properties=None,  # type: Optional[List["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]]
        extensions=None,  # type: Optional[List["models.MicrosoftGraphEntity"]]
        attachments=None,  # type: Optional[List["models.MicrosoftGraphAttachment"]]
        mentions=None,  # type: Optional[List["models.MicrosoftGraphMention"]]
        name=None,  # type: Optional[str]
        address=None,  # type: Optional[str]
        microsoft_graph_email_address_name=None,  # type: Optional[str]
        microsoft_graph_email_address=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property inReplyTo in groups.

        Update the navigation property inReplyTo in groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'.
        :type created_date_time: ~datetime.datetime
        :param last_modified_date_time: The Timestamp type represents date and time information using
         ISO 8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look
         like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param change_key: Identifies the version of the item. Every time the item is changed,
         changeKey changes as well. This allows Exchange to apply changes to the correct version of the
         object. Read-only.
        :type change_key: str
        :param categories: The categories associated with the item.
        :type categories: list[str]
        :param body: itemBody.
        :type body: ~groups_conversation.models.MicrosoftGraphItemBody
        :param received_date_time: Specifies when the post was received. The DateTimeOffset type
         represents date and time information using ISO 8601 format and is always in UTC time. For
         example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
        :type received_date_time: ~datetime.datetime
        :param has_attachments: Indicates whether the post has at least one attachment. This is a
         default property.
        :type has_attachments: bool
        :param microsoft_graph_post_conversation_thread_id_conversation_thread_id: Unique ID of the
         conversation thread. Read-only.
        :type microsoft_graph_post_conversation_thread_id_conversation_thread_id: str
        :param new_participants: Conversation participants that were added to the thread as part of
         this post.
        :type new_participants: list[~groups_conversation.models.MicrosoftGraphRecipient]
        :param microsoft_graph_post_conversation_id: Unique ID of the conversation. Read-only.
        :type microsoft_graph_post_conversation_id: str
        :param importance: importance.
        :type importance: str or ~groups_conversation.models.MicrosoftGraphImportance
        :param in_reply_to: post.
        :type in_reply_to: ~groups_conversation.models.MicrosoftGraphPost
        :param single_value_extended_properties: The collection of single-value extended properties
         defined for the post. Read-only. Nullable.
        :type single_value_extended_properties: list[~groups_conversation.models.MicrosoftGraphSingleValueLegacyExtendedProperty]
        :param multi_value_extended_properties: The collection of multi-value extended properties
         defined for the post. Read-only. Nullable.
        :type multi_value_extended_properties: list[~groups_conversation.models.MicrosoftGraphMultiValueLegacyExtendedProperty]
        :param extensions: The collection of open extensions defined for the post. Read-only. Nullable.
        :type extensions: list[~groups_conversation.models.MicrosoftGraphEntity]
        :param attachments: Read-only. Nullable.
        :type attachments: list[~groups_conversation.models.MicrosoftGraphAttachment]
        :param mentions:
        :type mentions: list[~groups_conversation.models.MicrosoftGraphMention]
        :param name: The display name of the person or entity.
        :type name: str
        :param address: The email address of the person or entity.
        :type address: str
        :param microsoft_graph_email_address_name: The display name of the person or entity.
        :type microsoft_graph_email_address_name: str
        :param microsoft_graph_email_address: The email address of the person or entity.
        :type microsoft_graph_email_address: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPost(id=id, created_date_time=created_date_time, last_modified_date_time=last_modified_date_time, change_key=change_key, categories=categories, body=body, received_date_time=received_date_time, has_attachments=has_attachments, conversation_thread_id=microsoft_graph_post_conversation_thread_id_conversation_thread_id, new_participants=new_participants, conversation_id=microsoft_graph_post_conversation_id, importance=importance, in_reply_to=in_reply_to, single_value_extended_properties=single_value_extended_properties, multi_value_extended_properties=multi_value_extended_properties, extensions=extensions, attachments=attachments, mentions=mentions, name_sender_email_address_name=name, address_sender_email_address=address, name_from_email_address_name=microsoft_graph_email_address_name, address_from_email_address=microsoft_graph_email_address)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_in_reply_to.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPost')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_in_reply_to.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/inReplyTo'}  # type: ignore

    def list_mention(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum23"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum24"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfMention"]
        """Get mentions from groups.

        Get mentions from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~groups_conversation.models.Enum23]
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum24]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfMention or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~groups_conversation.models.CollectionOfMention]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfMention"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_mention.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
                    'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
                    'post-id': self._serialize.url("post_id", post_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfMention', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_mention.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/mentions'}  # type: ignore

    def create_mention(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        id=None,  # type: Optional[str]
        mentioned=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        mention_text=None,  # type: Optional[str]
        client_reference=None,  # type: Optional[str]
        created_by=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        created_date_time=None,  # type: Optional[datetime.datetime]
        server_created_date_time=None,  # type: Optional[datetime.datetime]
        deep_link=None,  # type: Optional[str]
        application=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphMention"
        """Create new navigation property to mentions for groups.

        Create new navigation property to mentions for groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param id: Read-only.
        :type id: str
        :param mentioned: emailAddress.
        :type mentioned: ~groups_conversation.models.MicrosoftGraphEmailAddress
        :param mention_text:
        :type mention_text: str
        :param client_reference:
        :type client_reference: str
        :param created_by: emailAddress.
        :type created_by: ~groups_conversation.models.MicrosoftGraphEmailAddress
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param server_created_date_time:
        :type server_created_date_time: ~datetime.datetime
        :param deep_link:
        :type deep_link: str
        :param application:
        :type application: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMention, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphMention
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMention"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphMention(id=id, mentioned=mentioned, mention_text=mention_text, client_reference=client_reference, created_by=created_by, created_date_time=created_date_time, server_created_date_time=server_created_date_time, deep_link=deep_link, application=application)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_mention.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphMention')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMention', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_mention.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/mentions'}  # type: ignore

    def get_mention(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        mention_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum25"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphMention"
        """Get mentions from groups.

        Get mentions from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param mention_id: key: mention-id of mention.
        :type mention_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMention, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphMention
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMention"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_mention.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'mention-id': self._serialize.url("mention_id", mention_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMention', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mention.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/mentions/{mention-id}'}  # type: ignore

    def update_mention(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        mention_id,  # type: str
        id=None,  # type: Optional[str]
        mentioned=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        mention_text=None,  # type: Optional[str]
        client_reference=None,  # type: Optional[str]
        created_by=None,  # type: Optional["models.MicrosoftGraphEmailAddress"]
        created_date_time=None,  # type: Optional[datetime.datetime]
        server_created_date_time=None,  # type: Optional[datetime.datetime]
        deep_link=None,  # type: Optional[str]
        application=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property mentions in groups.

        Update the navigation property mentions in groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param mention_id: key: mention-id of mention.
        :type mention_id: str
        :param id: Read-only.
        :type id: str
        :param mentioned: emailAddress.
        :type mentioned: ~groups_conversation.models.MicrosoftGraphEmailAddress
        :param mention_text:
        :type mention_text: str
        :param client_reference:
        :type client_reference: str
        :param created_by: emailAddress.
        :type created_by: ~groups_conversation.models.MicrosoftGraphEmailAddress
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param server_created_date_time:
        :type server_created_date_time: ~datetime.datetime
        :param deep_link:
        :type deep_link: str
        :param application:
        :type application: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphMention(id=id, mentioned=mentioned, mention_text=mention_text, client_reference=client_reference, created_by=created_by, created_date_time=created_date_time, server_created_date_time=server_created_date_time, deep_link=deep_link, application=application)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_mention.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'mention-id': self._serialize.url("mention_id", mention_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphMention')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_mention.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/mentions/{mention-id}'}  # type: ignore

    def list_multi_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum26"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum27"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfMultiValueLegacyExtendedProperty"]
        """Get multiValueExtendedProperties from groups.

        Get multiValueExtendedProperties from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~groups_conversation.models.Enum26]
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum27]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfMultiValueLegacyExtendedProperty or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~groups_conversation.models.CollectionOfMultiValueLegacyExtendedProperty]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfMultiValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_multi_value_extended_property.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
                    'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
                    'post-id': self._serialize.url("post_id", post_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfMultiValueLegacyExtendedProperty', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties'}  # type: ignore

    def create_multi_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphMultiValueLegacyExtendedProperty"
        """Create new navigation property to multiValueExtendedProperties for groups.

        Create new navigation property to multiValueExtendedProperties for groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param id: Read-only.
        :type id: str
        :param value: A collection of property values.
        :type value: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMultiValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphMultiValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphMultiValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphMultiValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMultiValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties'}  # type: ignore

    def get_multi_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        multi_value_legacy_extended_property_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum28"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphMultiValueLegacyExtendedProperty"
        """Get multiValueExtendedProperties from groups.

        Get multiValueExtendedProperties from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param multi_value_legacy_extended_property_id: key: multiValueLegacyExtendedProperty-id of
         multiValueLegacyExtendedProperty.
        :type multi_value_legacy_extended_property_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum28]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphMultiValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphMultiValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphMultiValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'multiValueLegacyExtendedProperty-id': self._serialize.url("multi_value_legacy_extended_property_id", multi_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphMultiValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}'}  # type: ignore

    def update_multi_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        multi_value_legacy_extended_property_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property multiValueExtendedProperties in groups.

        Update the navigation property multiValueExtendedProperties in groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param multi_value_legacy_extended_property_id: key: multiValueLegacyExtendedProperty-id of
         multiValueLegacyExtendedProperty.
        :type multi_value_legacy_extended_property_id: str
        :param id: Read-only.
        :type id: str
        :param value: A collection of property values.
        :type value: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphMultiValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_multi_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'multiValueLegacyExtendedProperty-id': self._serialize.url("multi_value_legacy_extended_property_id", multi_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphMultiValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_multi_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/multiValueExtendedProperties/{multiValueLegacyExtendedProperty-id}'}  # type: ignore

    def list_single_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        orderby=None,  # type: Optional[List[Union[str, "models.Enum29"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum30"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfSingleValueLegacyExtendedProperty"]
        """Get singleValueExtendedProperties from groups.

        Get singleValueExtendedProperties from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~groups_conversation.models.Enum29]
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum30]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSingleValueLegacyExtendedProperty or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~groups_conversation.models.CollectionOfSingleValueLegacyExtendedProperty]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSingleValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_single_value_extended_property.metadata['url']  # type: ignore
                path_format_arguments = {
                    'group-id': self._serialize.url("group_id", group_id, 'str'),
                    'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
                    'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
                    'post-id': self._serialize.url("post_id", post_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSingleValueLegacyExtendedProperty', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_single_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties'}  # type: ignore

    def create_single_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphSingleValueLegacyExtendedProperty"
        """Create new navigation property to singleValueExtendedProperties for groups.

        Create new navigation property to singleValueExtendedProperties for groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param id: Read-only.
        :type id: str
        :param value: A property value.
        :type value: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSingleValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphSingleValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSingleValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSingleValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSingleValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_single_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties'}  # type: ignore

    def get_single_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        single_value_legacy_extended_property_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum31"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphSingleValueLegacyExtendedProperty"
        """Get singleValueExtendedProperties from groups.

        Get singleValueExtendedProperties from groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param single_value_legacy_extended_property_id: key: singleValueLegacyExtendedProperty-id of
         singleValueLegacyExtendedProperty.
        :type single_value_legacy_extended_property_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~groups_conversation.models.Enum31]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSingleValueLegacyExtendedProperty, or the result of cls(response)
        :rtype: ~groups_conversation.models.MicrosoftGraphSingleValueLegacyExtendedProperty
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSingleValueLegacyExtendedProperty"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'singleValueLegacyExtendedProperty-id': self._serialize.url("single_value_legacy_extended_property_id", single_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSingleValueLegacyExtendedProperty', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_single_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}'}  # type: ignore

    def update_single_value_extended_property(
        self,
        group_id,  # type: str
        conversation_id,  # type: str
        conversation_thread_id,  # type: str
        post_id,  # type: str
        single_value_legacy_extended_property_id,  # type: str
        id=None,  # type: Optional[str]
        value=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property singleValueExtendedProperties in groups.

        Update the navigation property singleValueExtendedProperties in groups.

        :param group_id: key: group-id of group.
        :type group_id: str
        :param conversation_id: key: conversation-id of conversation.
        :type conversation_id: str
        :param conversation_thread_id: key: conversationThread-id of conversationThread.
        :type conversation_thread_id: str
        :param post_id: key: post-id of post.
        :type post_id: str
        :param single_value_legacy_extended_property_id: key: singleValueLegacyExtendedProperty-id of
         singleValueLegacyExtendedProperty.
        :type single_value_legacy_extended_property_id: str
        :param id: Read-only.
        :type id: str
        :param value: A property value.
        :type value: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSingleValueLegacyExtendedProperty(id=id, value=value)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_single_value_extended_property.metadata['url']  # type: ignore
        path_format_arguments = {
            'group-id': self._serialize.url("group_id", group_id, 'str'),
            'conversation-id': self._serialize.url("conversation_id", conversation_id, 'str'),
            'conversationThread-id': self._serialize.url("conversation_thread_id", conversation_thread_id, 'str'),
            'post-id': self._serialize.url("post_id", post_id, 'str'),
            'singleValueLegacyExtendedProperty-id': self._serialize.url("single_value_legacy_extended_property_id", single_value_legacy_extended_property_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSingleValueLegacyExtendedProperty')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_single_value_extended_property.metadata = {'url': '/groups/{group-id}/conversations/{conversation-id}/threads/{conversationThread-id}/posts/{post-id}/singleValueExtendedProperties/{singleValueLegacyExtendedProperty-id}'}  # type: ignore
