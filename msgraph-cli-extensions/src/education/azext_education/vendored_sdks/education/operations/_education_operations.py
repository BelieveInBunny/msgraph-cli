# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class EducationOperations(object):
    """EducationOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~education.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_class(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Get5ItemsItem"]]]
        select=None,  # type: Optional[List[Union[str, "models.Get6ItemsItem"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Get7ItemsItem"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfEducationClass"]
        """Get classes from education.

        Get classes from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Get7ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationClass or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~education.models.CollectionOfEducationClass]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationClass"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_class.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationClass', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_class.metadata = {'url': '/education/classes'}  # type: ignore

    def create_class(
        self,
        id=None,  # type: Optional[str]
        class_code=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_id=None,  # type: Optional[str]
        external_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        mail_nickname=None,  # type: Optional[str]
        term=None,  # type: Optional["models.MicrosoftGraphEducationTerm"]
        group=None,  # type: Optional["models.MicrosoftGraphGroup"]
        members=None,  # type: Optional[List["models.MicrosoftGraphEducationUser"]]
        schools=None,  # type: Optional[List["models.MicrosoftGraphEducationSchool"]]
        teachers=None,  # type: Optional[List["models.MicrosoftGraphEducationUser"]]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationClass"
        """Create new navigation property to classes for education.

        Create new navigation property to classes for education.

        :param id: Read-only.
        :type id: str
        :param class_code: Class code used by the school to identify the class.
        :type class_code: str
        :param description: Description of the class.
        :type description: str
        :param display_name: Name of the class.
        :type display_name: str
        :param external_id: ID of the class from the syncing system.
        :type external_id: str
        :param external_name: Name of the class in the syncing system.
        :type external_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param mail_nickname: Mail name for sending email to all members, if this is enabled.
        :type mail_nickname: str
        :param term: educationTerm.
        :type term: ~education.models.MicrosoftGraphEducationTerm
        :param group: Represents an Azure Active Directory object. The directoryObject type is the base
         type for many other directory entity types.
        :type group: ~education.models.MicrosoftGraphGroup
        :param members: All users in the class. Nullable.
        :type members: list[~education.models.MicrosoftGraphEducationUser]
        :param schools: All schools that this class is associated with. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param teachers: All teachers in the class. Nullable.
        :type teachers: list[~education.models.MicrosoftGraphEducationUser]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationClass, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationClass
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationClass"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationClass(id=id, class_code=class_code, description=description, display_name=display_name, external_id=external_id, external_name=external_name, external_source=external_source, mail_nickname=mail_nickname, term=term, group=group, members=members, schools=schools, teachers=teachers, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_class.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationClass')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationClass', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_class.metadata = {'url': '/education/classes'}  # type: ignore

    def get_class(
        self,
        education_class_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum69"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Get2ItemsItem"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationClass"
        """Get classes from education.

        Get classes from education.

        :param education_class_id: key: id of educationClass.
        :type education_class_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum69]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Get2ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationClass, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationClass
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationClass"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_class.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationClass-id': self._serialize.url("education_class_id", education_class_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationClass', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_class.metadata = {'url': '/education/classes/{educationClass-id}'}  # type: ignore

    def update_class(
        self,
        education_class_id,  # type: str
        id=None,  # type: Optional[str]
        class_code=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_id=None,  # type: Optional[str]
        external_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        mail_nickname=None,  # type: Optional[str]
        term=None,  # type: Optional["models.MicrosoftGraphEducationTerm"]
        group=None,  # type: Optional["models.MicrosoftGraphGroup"]
        members=None,  # type: Optional[List["models.MicrosoftGraphEducationUser"]]
        schools=None,  # type: Optional[List["models.MicrosoftGraphEducationSchool"]]
        teachers=None,  # type: Optional[List["models.MicrosoftGraphEducationUser"]]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property classes in education.

        Update the navigation property classes in education.

        :param education_class_id: key: id of educationClass.
        :type education_class_id: str
        :param id: Read-only.
        :type id: str
        :param class_code: Class code used by the school to identify the class.
        :type class_code: str
        :param description: Description of the class.
        :type description: str
        :param display_name: Name of the class.
        :type display_name: str
        :param external_id: ID of the class from the syncing system.
        :type external_id: str
        :param external_name: Name of the class in the syncing system.
        :type external_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param mail_nickname: Mail name for sending email to all members, if this is enabled.
        :type mail_nickname: str
        :param term: educationTerm.
        :type term: ~education.models.MicrosoftGraphEducationTerm
        :param group: Represents an Azure Active Directory object. The directoryObject type is the base
         type for many other directory entity types.
        :type group: ~education.models.MicrosoftGraphGroup
        :param members: All users in the class. Nullable.
        :type members: list[~education.models.MicrosoftGraphEducationUser]
        :param schools: All schools that this class is associated with. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param teachers: All teachers in the class. Nullable.
        :type teachers: list[~education.models.MicrosoftGraphEducationUser]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationClass(id=id, class_code=class_code, description=description, display_name=display_name, external_id=external_id, external_name=external_name, external_source=external_source, mail_nickname=mail_nickname, term=term, group=group, members=members, schools=schools, teachers=teachers, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_class.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationClass-id': self._serialize.url("education_class_id", education_class_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationClass')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_class.metadata = {'url': '/education/classes/{educationClass-id}'}  # type: ignore

    def delete_class(
        self,
        education_class_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property classes for education.

        Delete navigation property classes for education.

        :param education_class_id: key: id of educationClass.
        :type education_class_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_class.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationClass-id': self._serialize.url("education_class_id", education_class_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_class.metadata = {'url': '/education/classes/{educationClass-id}'}  # type: ignore

    def get_me(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum85"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum86"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationUser"
        """Get me from education.

        Get me from education.

        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum85]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum86]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationUser, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_me.metadata = {'url': '/education/me'}  # type: ignore

    def update_me(
        self,
        id=None,  # type: Optional[str]
        account_enabled=None,  # type: Optional[bool]
        assigned_licenses=None,  # type: Optional[List["models.MicrosoftGraphAssignedLicense"]]
        assigned_plans=None,  # type: Optional[List["models.MicrosoftGraphAssignedPlan"]]
        business_phones=None,  # type: Optional[List[str]]
        department=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        given_name=None,  # type: Optional[str]
        mail=None,  # type: Optional[str]
        mailing_address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        mail_nickname=None,  # type: Optional[str]
        middle_name=None,  # type: Optional[str]
        mobile_phone=None,  # type: Optional[str]
        office_location=None,  # type: Optional[str]
        password_policies=None,  # type: Optional[str]
        password_profile=None,  # type: Optional["models.MicrosoftGraphPasswordProfile"]
        preferred_language=None,  # type: Optional[str]
        primary_role=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationUserRole"]]
        provisioned_plans=None,  # type: Optional[List["models.MicrosoftGraphProvisionedPlan"]]
        refresh_tokens_valid_from_date_time=None,  # type: Optional[datetime.datetime]
        residence_address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        show_in_address_list=None,  # type: Optional[bool]
        student=None,  # type: Optional["models.MicrosoftGraphEducationStudent"]
        surname=None,  # type: Optional[str]
        teacher=None,  # type: Optional["models.MicrosoftGraphEducationTeacher"]
        usage_location=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        user_type=None,  # type: Optional[str]
        classes=None,  # type: Optional[List["models.MicrosoftGraphEducationClass"]]
        schools=None,  # type: Optional[List["models.MicrosoftGraphEducationSchool"]]
        user=None,  # type: Optional["models.MicrosoftGraphUser"]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        microsoft_graph_identity_user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property me in education.

        Update the navigation property me in education.

        :param id: Read-only.
        :type id: str
        :param account_enabled: True if the account is enabled; otherwise, false. This property is
         required when a user is created. Supports $filter.
        :type account_enabled: bool
        :param assigned_licenses: The licenses that are assigned to the user. Not nullable.
        :type assigned_licenses: list[~education.models.MicrosoftGraphAssignedLicense]
        :param assigned_plans: The plans that are assigned to the user. Read-only. Not nullable.
        :type assigned_plans: list[~education.models.MicrosoftGraphAssignedPlan]
        :param business_phones: The telephone numbers for the user. Note: Although this is a string
         collection, only one number can be set for this property.
        :type business_phones: list[str]
        :param department: The name for the department in which the user works. Supports $filter.
        :type department: str
        :param display_name: The name displayed in the address book for the user. This is usually the
         combination of the user's first name, middle initial, and last name. This property is required
         when a user is created and it cannot be cleared during updates. Supports $filter and $orderby.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param given_name: The given name (first name) of the user. Supports $filter.
        :type given_name: str
        :param mail: The SMTP address for the user; for example, 'jeff@contoso.onmicrosoft.com'. Read-
         Only. Supports $filter.
        :type mail: str
        :param mailing_address: physicalAddress.
        :type mailing_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param mail_nickname: The mail alias for the user. This property must be specified when a user
         is created. Supports $filter.
        :type mail_nickname: str
        :param middle_name: The middle name of user.
        :type middle_name: str
        :param mobile_phone: The primary cellular telephone number for the user.
        :type mobile_phone: str
        :param office_location:
        :type office_location: str
        :param password_policies: Specifies password policies for the user. This value is an
         enumeration with one possible value being 'DisableStrongPassword', which allows weaker
         passwords than the default policy to be specified. 'DisablePasswordExpiration' can also be
         specified. The two can be specified together; for example: 'DisablePasswordExpiration,
         DisableStrongPassword'.
        :type password_policies: str
        :param password_profile: passwordProfile.
        :type password_profile: ~education.models.MicrosoftGraphPasswordProfile
        :param preferred_language: The preferred language for the user. Should follow ISO 639-1 Code;
         for example, 'en-US'.
        :type preferred_language: str
        :param primary_role:
        :type primary_role: str or ~education.models.MicrosoftGraphEducationUserRole
        :param provisioned_plans: The plans that are provisioned for the user. Read-only. Not nullable.
        :type provisioned_plans: list[~education.models.MicrosoftGraphProvisionedPlan]
        :param refresh_tokens_valid_from_date_time:
        :type refresh_tokens_valid_from_date_time: ~datetime.datetime
        :param residence_address: physicalAddress.
        :type residence_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param show_in_address_list:
        :type show_in_address_list: bool
        :param student: educationStudent.
        :type student: ~education.models.MicrosoftGraphEducationStudent
        :param surname: The user's surname (family name or last name). Supports $filter.
        :type surname: str
        :param teacher: educationTeacher.
        :type teacher: ~education.models.MicrosoftGraphEducationTeacher
        :param usage_location: A two-letter country code (ISO standard 3166). Required for users who
         will be assigned licenses due to a legal requirement to check for availability of services in
         countries or regions. Examples include: 'US', 'JP', and 'GB'. Not nullable. Supports $filter.
        :type usage_location: str
        :param user_principal_name: The user principal name (UPN) of the user. The UPN is an Internet-
         style login name for the user based on the Internet standard RFC 822. By convention, this
         should map to the user's email name. The general format is alias@domain, where domain must be
         present in the tenant's collection of verified domains. This property is required when a user
         is created. The verified domains for the tenant can be accessed from the verifiedDomains
         property of organization. Supports $filter and $orderby.
        :type user_principal_name: str
        :param user_type: A string value that can be used to classify user types in your directory,
         such as 'Member' and 'Guest'. Supports $filter.
        :type user_type: str
        :param classes: Classes to which the user belongs. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param schools: Schools to which the user belongs. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param user: Represents an Azure Active Directory user object.
        :type user: ~education.models.MicrosoftGraphUser
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationUser(id=id, account_enabled=account_enabled, assigned_licenses=assigned_licenses, assigned_plans=assigned_plans, business_phones=business_phones, department=department, display_name=display_name, external_source=external_source, given_name=given_name, mail=mail, mailing_address=mailing_address, mail_nickname=mail_nickname, middle_name=middle_name, mobile_phone=mobile_phone, office_location=office_location, password_policies=password_policies, password_profile=password_profile, preferred_language=preferred_language, primary_role=primary_role, provisioned_plans=provisioned_plans, refresh_tokens_valid_from_date_time=refresh_tokens_valid_from_date_time, residence_address=residence_address, show_in_address_list=show_in_address_list, student=student, surname=surname, teacher=teacher, usage_location=usage_location, user_principal_name=user_principal_name, user_type=user_type, classes=classes, schools=schools, user=user, application=application, device=device, user_created_by_user=microsoft_graph_identity_user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationUser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_me.metadata = {'url': '/education/me'}  # type: ignore

    def delete_me(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property me for education.

        Delete navigation property me for education.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_me.metadata = {'url': '/education/me'}  # type: ignore

    def list_school(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum97"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum98"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum99"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfEducationSchool1"]
        """Get schools from education.

        Get schools from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Enum97]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum98]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum99]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationSchool1 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~education.models.CollectionOfEducationSchool1]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationSchool1"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_school.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationSchool1', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_school.metadata = {'url': '/education/schools'}  # type: ignore

    def create_school(
        self,
        id=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        external_id=None,  # type: Optional[str]
        external_principal_id=None,  # type: Optional[str]
        fax=None,  # type: Optional[str]
        highest_grade=None,  # type: Optional[str]
        lowest_grade=None,  # type: Optional[str]
        phone=None,  # type: Optional[str]
        principal_email=None,  # type: Optional[str]
        principal_name=None,  # type: Optional[str]
        school_number=None,  # type: Optional[str]
        classes=None,  # type: Optional[List["models.MicrosoftGraphEducationClass"]]
        users=None,  # type: Optional[List["models.MicrosoftGraphEducationUser"]]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationSchool"
        """Create new navigation property to schools for education.

        Create new navigation property to schools for education.

        :param id: Read-only.
        :type id: str
        :param description: Organization description.
        :type description: str
        :param display_name: Organization display name.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param address: physicalAddress.
        :type address: ~education.models.MicrosoftGraphPhysicalAddress
        :param external_id: ID of school in syncing system.
        :type external_id: str
        :param external_principal_id: ID of principal in syncing system.
        :type external_principal_id: str
        :param fax:
        :type fax: str
        :param highest_grade: Highest grade taught.
        :type highest_grade: str
        :param lowest_grade: Lowest grade taught.
        :type lowest_grade: str
        :param phone: Phone number of school.
        :type phone: str
        :param principal_email: Email address of the principal.
        :type principal_email: str
        :param principal_name: Name of the principal.
        :type principal_name: str
        :param school_number: School Number.
        :type school_number: str
        :param classes: Classes taught at the school. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param users: Users in the school. Nullable.
        :type users: list[~education.models.MicrosoftGraphEducationUser]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationSchool, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationSchool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationSchool"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationSchool(id=id, description=description, display_name=display_name, external_source=external_source, address=address, external_id=external_id, external_principal_id=external_principal_id, fax=fax, highest_grade=highest_grade, lowest_grade=lowest_grade, phone=phone, principal_email=principal_email, principal_name=principal_name, school_number=school_number, classes=classes, users=users, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_school.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationSchool')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationSchool', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_school.metadata = {'url': '/education/schools'}  # type: ignore

    def get_school(
        self,
        education_school_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum100"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum101"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationSchool"
        """Get schools from education.

        Get schools from education.

        :param education_school_id: key: id of educationSchool.
        :type education_school_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum100]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum101]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationSchool, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationSchool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationSchool"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_school.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSchool-id': self._serialize.url("education_school_id", education_school_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationSchool', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_school.metadata = {'url': '/education/schools/{educationSchool-id}'}  # type: ignore

    def update_school(
        self,
        education_school_id,  # type: str
        id=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        external_id=None,  # type: Optional[str]
        external_principal_id=None,  # type: Optional[str]
        fax=None,  # type: Optional[str]
        highest_grade=None,  # type: Optional[str]
        lowest_grade=None,  # type: Optional[str]
        phone=None,  # type: Optional[str]
        principal_email=None,  # type: Optional[str]
        principal_name=None,  # type: Optional[str]
        school_number=None,  # type: Optional[str]
        classes=None,  # type: Optional[List["models.MicrosoftGraphEducationClass"]]
        users=None,  # type: Optional[List["models.MicrosoftGraphEducationUser"]]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property schools in education.

        Update the navigation property schools in education.

        :param education_school_id: key: id of educationSchool.
        :type education_school_id: str
        :param id: Read-only.
        :type id: str
        :param description: Organization description.
        :type description: str
        :param display_name: Organization display name.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param address: physicalAddress.
        :type address: ~education.models.MicrosoftGraphPhysicalAddress
        :param external_id: ID of school in syncing system.
        :type external_id: str
        :param external_principal_id: ID of principal in syncing system.
        :type external_principal_id: str
        :param fax:
        :type fax: str
        :param highest_grade: Highest grade taught.
        :type highest_grade: str
        :param lowest_grade: Lowest grade taught.
        :type lowest_grade: str
        :param phone: Phone number of school.
        :type phone: str
        :param principal_email: Email address of the principal.
        :type principal_email: str
        :param principal_name: Name of the principal.
        :type principal_name: str
        :param school_number: School Number.
        :type school_number: str
        :param classes: Classes taught at the school. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param users: Users in the school. Nullable.
        :type users: list[~education.models.MicrosoftGraphEducationUser]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationSchool(id=id, description=description, display_name=display_name, external_source=external_source, address=address, external_id=external_id, external_principal_id=external_principal_id, fax=fax, highest_grade=highest_grade, lowest_grade=lowest_grade, phone=phone, principal_email=principal_email, principal_name=principal_name, school_number=school_number, classes=classes, users=users, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_school.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSchool-id': self._serialize.url("education_school_id", education_school_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationSchool')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_school.metadata = {'url': '/education/schools/{educationSchool-id}'}  # type: ignore

    def delete_school(
        self,
        education_school_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property schools for education.

        Delete navigation property schools for education.

        :param education_school_id: key: id of educationSchool.
        :type education_school_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_school.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSchool-id': self._serialize.url("education_school_id", education_school_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_school.metadata = {'url': '/education/schools/{educationSchool-id}'}  # type: ignore

    def list_user(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum110"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum111"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum112"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfEducationUser2"]
        """Get users from education.

        Get users from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Enum110]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum111]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum112]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationUser2 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~education.models.CollectionOfEducationUser2]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationUser2"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_user.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationUser2', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_user.metadata = {'url': '/education/users'}  # type: ignore

    def create_user(
        self,
        id=None,  # type: Optional[str]
        account_enabled=None,  # type: Optional[bool]
        assigned_licenses=None,  # type: Optional[List["models.MicrosoftGraphAssignedLicense"]]
        assigned_plans=None,  # type: Optional[List["models.MicrosoftGraphAssignedPlan"]]
        business_phones=None,  # type: Optional[List[str]]
        department=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        given_name=None,  # type: Optional[str]
        mail=None,  # type: Optional[str]
        mailing_address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        mail_nickname=None,  # type: Optional[str]
        middle_name=None,  # type: Optional[str]
        mobile_phone=None,  # type: Optional[str]
        office_location=None,  # type: Optional[str]
        password_policies=None,  # type: Optional[str]
        password_profile=None,  # type: Optional["models.MicrosoftGraphPasswordProfile"]
        preferred_language=None,  # type: Optional[str]
        primary_role=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationUserRole"]]
        provisioned_plans=None,  # type: Optional[List["models.MicrosoftGraphProvisionedPlan"]]
        refresh_tokens_valid_from_date_time=None,  # type: Optional[datetime.datetime]
        residence_address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        show_in_address_list=None,  # type: Optional[bool]
        student=None,  # type: Optional["models.MicrosoftGraphEducationStudent"]
        surname=None,  # type: Optional[str]
        teacher=None,  # type: Optional["models.MicrosoftGraphEducationTeacher"]
        usage_location=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        user_type=None,  # type: Optional[str]
        classes=None,  # type: Optional[List["models.MicrosoftGraphEducationClass"]]
        schools=None,  # type: Optional[List["models.MicrosoftGraphEducationSchool"]]
        user=None,  # type: Optional["models.MicrosoftGraphUser"]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        microsoft_graph_identity_user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationUser"
        """Create new navigation property to users for education.

        Create new navigation property to users for education.

        :param id: Read-only.
        :type id: str
        :param account_enabled: True if the account is enabled; otherwise, false. This property is
         required when a user is created. Supports $filter.
        :type account_enabled: bool
        :param assigned_licenses: The licenses that are assigned to the user. Not nullable.
        :type assigned_licenses: list[~education.models.MicrosoftGraphAssignedLicense]
        :param assigned_plans: The plans that are assigned to the user. Read-only. Not nullable.
        :type assigned_plans: list[~education.models.MicrosoftGraphAssignedPlan]
        :param business_phones: The telephone numbers for the user. Note: Although this is a string
         collection, only one number can be set for this property.
        :type business_phones: list[str]
        :param department: The name for the department in which the user works. Supports $filter.
        :type department: str
        :param display_name: The name displayed in the address book for the user. This is usually the
         combination of the user's first name, middle initial, and last name. This property is required
         when a user is created and it cannot be cleared during updates. Supports $filter and $orderby.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param given_name: The given name (first name) of the user. Supports $filter.
        :type given_name: str
        :param mail: The SMTP address for the user; for example, 'jeff@contoso.onmicrosoft.com'. Read-
         Only. Supports $filter.
        :type mail: str
        :param mailing_address: physicalAddress.
        :type mailing_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param mail_nickname: The mail alias for the user. This property must be specified when a user
         is created. Supports $filter.
        :type mail_nickname: str
        :param middle_name: The middle name of user.
        :type middle_name: str
        :param mobile_phone: The primary cellular telephone number for the user.
        :type mobile_phone: str
        :param office_location:
        :type office_location: str
        :param password_policies: Specifies password policies for the user. This value is an
         enumeration with one possible value being 'DisableStrongPassword', which allows weaker
         passwords than the default policy to be specified. 'DisablePasswordExpiration' can also be
         specified. The two can be specified together; for example: 'DisablePasswordExpiration,
         DisableStrongPassword'.
        :type password_policies: str
        :param password_profile: passwordProfile.
        :type password_profile: ~education.models.MicrosoftGraphPasswordProfile
        :param preferred_language: The preferred language for the user. Should follow ISO 639-1 Code;
         for example, 'en-US'.
        :type preferred_language: str
        :param primary_role:
        :type primary_role: str or ~education.models.MicrosoftGraphEducationUserRole
        :param provisioned_plans: The plans that are provisioned for the user. Read-only. Not nullable.
        :type provisioned_plans: list[~education.models.MicrosoftGraphProvisionedPlan]
        :param refresh_tokens_valid_from_date_time:
        :type refresh_tokens_valid_from_date_time: ~datetime.datetime
        :param residence_address: physicalAddress.
        :type residence_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param show_in_address_list:
        :type show_in_address_list: bool
        :param student: educationStudent.
        :type student: ~education.models.MicrosoftGraphEducationStudent
        :param surname: The user's surname (family name or last name). Supports $filter.
        :type surname: str
        :param teacher: educationTeacher.
        :type teacher: ~education.models.MicrosoftGraphEducationTeacher
        :param usage_location: A two-letter country code (ISO standard 3166). Required for users who
         will be assigned licenses due to a legal requirement to check for availability of services in
         countries or regions. Examples include: 'US', 'JP', and 'GB'. Not nullable. Supports $filter.
        :type usage_location: str
        :param user_principal_name: The user principal name (UPN) of the user. The UPN is an Internet-
         style login name for the user based on the Internet standard RFC 822. By convention, this
         should map to the user's email name. The general format is alias@domain, where domain must be
         present in the tenant's collection of verified domains. This property is required when a user
         is created. The verified domains for the tenant can be accessed from the verifiedDomains
         property of organization. Supports $filter and $orderby.
        :type user_principal_name: str
        :param user_type: A string value that can be used to classify user types in your directory,
         such as 'Member' and 'Guest'. Supports $filter.
        :type user_type: str
        :param classes: Classes to which the user belongs. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param schools: Schools to which the user belongs. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param user: Represents an Azure Active Directory user object.
        :type user: ~education.models.MicrosoftGraphUser
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationUser, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationUser(id=id, account_enabled=account_enabled, assigned_licenses=assigned_licenses, assigned_plans=assigned_plans, business_phones=business_phones, department=department, display_name=display_name, external_source=external_source, given_name=given_name, mail=mail, mailing_address=mailing_address, mail_nickname=mail_nickname, middle_name=middle_name, mobile_phone=mobile_phone, office_location=office_location, password_policies=password_policies, password_profile=password_profile, preferred_language=preferred_language, primary_role=primary_role, provisioned_plans=provisioned_plans, refresh_tokens_valid_from_date_time=refresh_tokens_valid_from_date_time, residence_address=residence_address, show_in_address_list=show_in_address_list, student=student, surname=surname, teacher=teacher, usage_location=usage_location, user_principal_name=user_principal_name, user_type=user_type, classes=classes, schools=schools, user=user, application=application, device=device, user_created_by_user=microsoft_graph_identity_user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationUser')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_user.metadata = {'url': '/education/users'}  # type: ignore

    def get_user(
        self,
        education_user_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum113"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum114"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphEducationUser"
        """Get users from education.

        Get users from education.

        :param education_user_id: key: id of educationUser.
        :type education_user_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum113]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum114]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationUser, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationUser-id': self._serialize.url("education_user_id", education_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user.metadata = {'url': '/education/users/{educationUser-id}'}  # type: ignore

    def update_user(
        self,
        education_user_id,  # type: str
        id=None,  # type: Optional[str]
        account_enabled=None,  # type: Optional[bool]
        assigned_licenses=None,  # type: Optional[List["models.MicrosoftGraphAssignedLicense"]]
        assigned_plans=None,  # type: Optional[List["models.MicrosoftGraphAssignedPlan"]]
        business_phones=None,  # type: Optional[List[str]]
        department=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        external_source=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]]
        given_name=None,  # type: Optional[str]
        mail=None,  # type: Optional[str]
        mailing_address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        mail_nickname=None,  # type: Optional[str]
        middle_name=None,  # type: Optional[str]
        mobile_phone=None,  # type: Optional[str]
        office_location=None,  # type: Optional[str]
        password_policies=None,  # type: Optional[str]
        password_profile=None,  # type: Optional["models.MicrosoftGraphPasswordProfile"]
        preferred_language=None,  # type: Optional[str]
        primary_role=None,  # type: Optional[Union[str, "models.MicrosoftGraphEducationUserRole"]]
        provisioned_plans=None,  # type: Optional[List["models.MicrosoftGraphProvisionedPlan"]]
        refresh_tokens_valid_from_date_time=None,  # type: Optional[datetime.datetime]
        residence_address=None,  # type: Optional["models.MicrosoftGraphPhysicalAddress"]
        show_in_address_list=None,  # type: Optional[bool]
        student=None,  # type: Optional["models.MicrosoftGraphEducationStudent"]
        surname=None,  # type: Optional[str]
        teacher=None,  # type: Optional["models.MicrosoftGraphEducationTeacher"]
        usage_location=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        user_type=None,  # type: Optional[str]
        classes=None,  # type: Optional[List["models.MicrosoftGraphEducationClass"]]
        schools=None,  # type: Optional[List["models.MicrosoftGraphEducationSchool"]]
        user=None,  # type: Optional["models.MicrosoftGraphUser"]
        application=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        device=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        microsoft_graph_identity_user=None,  # type: Optional["models.MicrosoftGraphIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property users in education.

        Update the navigation property users in education.

        :param education_user_id: key: id of educationUser.
        :type education_user_id: str
        :param id: Read-only.
        :type id: str
        :param account_enabled: True if the account is enabled; otherwise, false. This property is
         required when a user is created. Supports $filter.
        :type account_enabled: bool
        :param assigned_licenses: The licenses that are assigned to the user. Not nullable.
        :type assigned_licenses: list[~education.models.MicrosoftGraphAssignedLicense]
        :param assigned_plans: The plans that are assigned to the user. Read-only. Not nullable.
        :type assigned_plans: list[~education.models.MicrosoftGraphAssignedPlan]
        :param business_phones: The telephone numbers for the user. Note: Although this is a string
         collection, only one number can be set for this property.
        :type business_phones: list[str]
        :param department: The name for the department in which the user works. Supports $filter.
        :type department: str
        :param display_name: The name displayed in the address book for the user. This is usually the
         combination of the user's first name, middle initial, and last name. This property is required
         when a user is created and it cannot be cleared during updates. Supports $filter and $orderby.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param given_name: The given name (first name) of the user. Supports $filter.
        :type given_name: str
        :param mail: The SMTP address for the user; for example, 'jeff@contoso.onmicrosoft.com'. Read-
         Only. Supports $filter.
        :type mail: str
        :param mailing_address: physicalAddress.
        :type mailing_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param mail_nickname: The mail alias for the user. This property must be specified when a user
         is created. Supports $filter.
        :type mail_nickname: str
        :param middle_name: The middle name of user.
        :type middle_name: str
        :param mobile_phone: The primary cellular telephone number for the user.
        :type mobile_phone: str
        :param office_location:
        :type office_location: str
        :param password_policies: Specifies password policies for the user. This value is an
         enumeration with one possible value being 'DisableStrongPassword', which allows weaker
         passwords than the default policy to be specified. 'DisablePasswordExpiration' can also be
         specified. The two can be specified together; for example: 'DisablePasswordExpiration,
         DisableStrongPassword'.
        :type password_policies: str
        :param password_profile: passwordProfile.
        :type password_profile: ~education.models.MicrosoftGraphPasswordProfile
        :param preferred_language: The preferred language for the user. Should follow ISO 639-1 Code;
         for example, 'en-US'.
        :type preferred_language: str
        :param primary_role:
        :type primary_role: str or ~education.models.MicrosoftGraphEducationUserRole
        :param provisioned_plans: The plans that are provisioned for the user. Read-only. Not nullable.
        :type provisioned_plans: list[~education.models.MicrosoftGraphProvisionedPlan]
        :param refresh_tokens_valid_from_date_time:
        :type refresh_tokens_valid_from_date_time: ~datetime.datetime
        :param residence_address: physicalAddress.
        :type residence_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param show_in_address_list:
        :type show_in_address_list: bool
        :param student: educationStudent.
        :type student: ~education.models.MicrosoftGraphEducationStudent
        :param surname: The user's surname (family name or last name). Supports $filter.
        :type surname: str
        :param teacher: educationTeacher.
        :type teacher: ~education.models.MicrosoftGraphEducationTeacher
        :param usage_location: A two-letter country code (ISO standard 3166). Required for users who
         will be assigned licenses due to a legal requirement to check for availability of services in
         countries or regions. Examples include: 'US', 'JP', and 'GB'. Not nullable. Supports $filter.
        :type usage_location: str
        :param user_principal_name: The user principal name (UPN) of the user. The UPN is an Internet-
         style login name for the user based on the Internet standard RFC 822. By convention, this
         should map to the user's email name. The general format is alias@domain, where domain must be
         present in the tenant's collection of verified domains. This property is required when a user
         is created. The verified domains for the tenant can be accessed from the verifiedDomains
         property of organization. Supports $filter and $orderby.
        :type user_principal_name: str
        :param user_type: A string value that can be used to classify user types in your directory,
         such as 'Member' and 'Guest'. Supports $filter.
        :type user_type: str
        :param classes: Classes to which the user belongs. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param schools: Schools to which the user belongs. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param user: Represents an Azure Active Directory user object.
        :type user: ~education.models.MicrosoftGraphUser
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphEducationUser(id=id, account_enabled=account_enabled, assigned_licenses=assigned_licenses, assigned_plans=assigned_plans, business_phones=business_phones, department=department, display_name=display_name, external_source=external_source, given_name=given_name, mail=mail, mailing_address=mailing_address, mail_nickname=mail_nickname, middle_name=middle_name, mobile_phone=mobile_phone, office_location=office_location, password_policies=password_policies, password_profile=password_profile, preferred_language=preferred_language, primary_role=primary_role, provisioned_plans=provisioned_plans, refresh_tokens_valid_from_date_time=refresh_tokens_valid_from_date_time, residence_address=residence_address, show_in_address_list=show_in_address_list, student=student, surname=surname, teacher=teacher, usage_location=usage_location, user_principal_name=user_principal_name, user_type=user_type, classes=classes, schools=schools, user=user, application=application, device=device, user_created_by_user=microsoft_graph_identity_user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationUser-id': self._serialize.url("education_user_id", education_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphEducationUser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_user.metadata = {'url': '/education/users/{educationUser-id}'}  # type: ignore

    def delete_user(
        self,
        education_user_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property users for education.

        Delete navigation property users for education.

        :param education_user_id: key: id of educationUser.
        :type education_user_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationUser-id': self._serialize.url("education_user_id", education_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_user.metadata = {'url': '/education/users/{educationUser-id}'}  # type: ignore
