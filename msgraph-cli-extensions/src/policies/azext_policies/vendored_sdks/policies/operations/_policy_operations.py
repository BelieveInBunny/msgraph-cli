# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class PolicyOperations(object):
    """PolicyOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~identity_policies.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_activity_based_timeout_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Get5ItemsItem"]]]
        select=None,  # type: Optional[List[Union[str, "models.Get6ItemsItem"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Get7ItemsItem"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfActivityBasedTimeoutPolicy"]
        """Get activityBasedTimeoutPolicies from policies.

        Get activityBasedTimeoutPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_policies.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Get7ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfActivityBasedTimeoutPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_policies.models.CollectionOfActivityBasedTimeoutPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_activity_based_timeout_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfActivityBasedTimeoutPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies'}  # type: ignore

    def create_activity_based_timeout_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Create new navigation property to activityBasedTimeoutPolicies for policies.

        Create new navigation property to activityBasedTimeoutPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_activity_based_timeout_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies'}  # type: ignore

    def get_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum13"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Get2ItemsItem"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Get activityBasedTimeoutPolicies from policies.

        Get activityBasedTimeoutPolicies from policies.

        :param activity_based_timeout_policy_id: key: activityBasedTimeoutPolicy-id of
         activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum13]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Get2ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    def update_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property activityBasedTimeoutPolicies in policies.

        Update the navigation property activityBasedTimeoutPolicies in policies.

        :param activity_based_timeout_policy_id: key: activityBasedTimeoutPolicy-id of
         activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    def get_admin_consent_request_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum15"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAdminConsentRequestPolicy"
        """Get adminConsentRequestPolicy from policies.

        Get adminConsentRequestPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum15]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAdminConsentRequestPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphAdminConsentRequestPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAdminConsentRequestPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_admin_consent_request_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAdminConsentRequestPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_admin_consent_request_policy.metadata = {'url': '/policies/adminConsentRequestPolicy'}  # type: ignore

    def update_admin_consent_request_policy(
        self,
        id=None,  # type: Optional[str]
        is_enabled=None,  # type: Optional[bool]
        version=None,  # type: Optional[int]
        notify_reviewers=None,  # type: Optional[bool]
        reminders_enabled=None,  # type: Optional[bool]
        request_duration_in_days=None,  # type: Optional[int]
        reviewers=None,  # type: Optional[List["models.MicrosoftGraphAccessReviewScope"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property adminConsentRequestPolicy in policies.

        Update the navigation property adminConsentRequestPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param is_enabled:
        :type is_enabled: bool
        :param version:
        :type version: int
        :param notify_reviewers:
        :type notify_reviewers: bool
        :param reminders_enabled:
        :type reminders_enabled: bool
        :param request_duration_in_days:
        :type request_duration_in_days: int
        :param reviewers:
        :type reviewers: list[~identity_policies.models.MicrosoftGraphAccessReviewScope]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAdminConsentRequestPolicy(id=id, is_enabled=is_enabled, version=version, notify_reviewers=notify_reviewers, reminders_enabled=reminders_enabled, request_duration_in_days=request_duration_in_days, reviewers=reviewers)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_admin_consent_request_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAdminConsentRequestPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_admin_consent_request_policy.metadata = {'url': '/policies/adminConsentRequestPolicy'}  # type: ignore

    def list_claim_mapping_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum16"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum17"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum18"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfClaimsMappingPolicy"]
        """Get claimsMappingPolicies from policies.

        Get claimsMappingPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_policies.models.Enum16]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum17]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum18]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfClaimsMappingPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_policies.models.CollectionOfClaimsMappingPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_claim_mapping_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfClaimsMappingPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies'}  # type: ignore

    def create_claim_mapping_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Create new navigation property to claimsMappingPolicies for policies.

        Create new navigation property to claimsMappingPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_claim_mapping_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies'}  # type: ignore

    def get_claim_mapping_policy(
        self,
        claims_mapping_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum19"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum20"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Get claimsMappingPolicies from policies.

        Get claimsMappingPolicies from policies.

        :param claims_mapping_policy_id: key: claimsMappingPolicy-id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum19]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum20]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    def update_claim_mapping_policy(
        self,
        claims_mapping_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property claimsMappingPolicies in policies.

        Update the navigation property claimsMappingPolicies in policies.

        :param claims_mapping_policy_id: key: claimsMappingPolicy-id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    def list_conditional_access_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum21"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum22"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfConditionalAccessPolicy"]
        """Get conditionalAccessPolicies from policies.

        Get conditionalAccessPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_policies.models.Enum21]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum22]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfConditionalAccessPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_policies.models.CollectionOfConditionalAccessPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_conditional_access_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfConditionalAccessPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies'}  # type: ignore

    def create_conditional_access_policy(
        self,
        id=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        modified_date_time=None,  # type: Optional[datetime.datetime]
        display_name=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        state=None,  # type: Optional[Union[str, "models.MicrosoftGraphConditionalAccessPolicyState"]]
        grant_controls=None,  # type: Optional["models.MicrosoftGraphConditionalAccessGrantControls"]
        cloud_app_security=None,  # type: Optional["models.MicrosoftGraphCloudAppSecuritySessionControl"]
        sign_in_frequency=None,  # type: Optional["models.MicrosoftGraphSignInFrequencySessionControl"]
        persistent_browser=None,  # type: Optional["models.MicrosoftGraphPersistentBrowserSessionControl"]
        is_enabled=None,  # type: Optional[bool]
        applications=None,  # type: Optional["models.MicrosoftGraphConditionalAccessApplications"]
        users=None,  # type: Optional["models.MicrosoftGraphConditionalAccessUsers"]
        sign_in_risk_levels=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]]
        platforms=None,  # type: Optional["models.MicrosoftGraphConditionalAccessPlatforms"]
        locations=None,  # type: Optional["models.MicrosoftGraphConditionalAccessLocations"]
        client_app_types=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphConditionalAccessClientApp"]]]
        device_states=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDeviceStates"]
        devices=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDevices"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphConditionalAccessPolicy"
        """Create new navigation property to conditionalAccessPolicies for policies.

        Create new navigation property to conditionalAccessPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param modified_date_time:
        :type modified_date_time: ~datetime.datetime
        :param display_name:
        :type display_name: str
        :param description:
        :type description: str
        :param state: conditionalAccessPolicyState.
        :type state: str or ~identity_policies.models.MicrosoftGraphConditionalAccessPolicyState
        :param grant_controls: conditionalAccessGrantControls.
        :type grant_controls: ~identity_policies.models.MicrosoftGraphConditionalAccessGrantControls
        :param cloud_app_security: cloudAppSecuritySessionControl.
        :type cloud_app_security: ~identity_policies.models.MicrosoftGraphCloudAppSecuritySessionControl
        :param sign_in_frequency: signInFrequencySessionControl.
        :type sign_in_frequency: ~identity_policies.models.MicrosoftGraphSignInFrequencySessionControl
        :param persistent_browser: persistentBrowserSessionControl.
        :type persistent_browser: ~identity_policies.models.MicrosoftGraphPersistentBrowserSessionControl
        :param is_enabled:
        :type is_enabled: bool
        :param applications: conditionalAccessApplications.
        :type applications: ~identity_policies.models.MicrosoftGraphConditionalAccessApplications
        :param users: conditionalAccessUsers.
        :type users: ~identity_policies.models.MicrosoftGraphConditionalAccessUsers
        :param sign_in_risk_levels:
        :type sign_in_risk_levels: list[str or ~identity_policies.models.MicrosoftGraphRiskLevel]
        :param platforms: conditionalAccessPlatforms.
        :type platforms: ~identity_policies.models.MicrosoftGraphConditionalAccessPlatforms
        :param locations: conditionalAccessLocations.
        :type locations: ~identity_policies.models.MicrosoftGraphConditionalAccessLocations
        :param client_app_types:
        :type client_app_types: list[str or ~identity_policies.models.MicrosoftGraphConditionalAccessClientApp]
        :param device_states: conditionalAccessDeviceStates.
        :type device_states: ~identity_policies.models.MicrosoftGraphConditionalAccessDeviceStates
        :param devices: conditionalAccessDevices.
        :type devices: ~identity_policies.models.MicrosoftGraphConditionalAccessDevices
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConditionalAccessPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphConditionalAccessPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConditionalAccessPolicy(id=id, created_date_time=created_date_time, modified_date_time=modified_date_time, display_name=display_name, description=description, state=state, grant_controls=grant_controls, cloud_app_security=cloud_app_security, sign_in_frequency=sign_in_frequency, persistent_browser=persistent_browser, is_enabled=is_enabled, applications=applications, users=users, sign_in_risk_levels=sign_in_risk_levels, platforms=platforms, locations=locations, client_app_types=client_app_types, device_states=device_states, devices=devices)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_conditional_access_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConditionalAccessPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConditionalAccessPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies'}  # type: ignore

    def get_conditional_access_policy(
        self,
        conditional_access_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum23"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphConditionalAccessPolicy"
        """Get conditionalAccessPolicies from policies.

        Get conditionalAccessPolicies from policies.

        :param conditional_access_policy_id: key: conditionalAccessPolicy-id of
         conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum23]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConditionalAccessPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphConditionalAccessPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConditionalAccessPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    def update_conditional_access_policy(
        self,
        conditional_access_policy_id,  # type: str
        id=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        modified_date_time=None,  # type: Optional[datetime.datetime]
        display_name=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        state=None,  # type: Optional[Union[str, "models.MicrosoftGraphConditionalAccessPolicyState"]]
        grant_controls=None,  # type: Optional["models.MicrosoftGraphConditionalAccessGrantControls"]
        cloud_app_security=None,  # type: Optional["models.MicrosoftGraphCloudAppSecuritySessionControl"]
        sign_in_frequency=None,  # type: Optional["models.MicrosoftGraphSignInFrequencySessionControl"]
        persistent_browser=None,  # type: Optional["models.MicrosoftGraphPersistentBrowserSessionControl"]
        is_enabled=None,  # type: Optional[bool]
        applications=None,  # type: Optional["models.MicrosoftGraphConditionalAccessApplications"]
        users=None,  # type: Optional["models.MicrosoftGraphConditionalAccessUsers"]
        sign_in_risk_levels=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]]
        platforms=None,  # type: Optional["models.MicrosoftGraphConditionalAccessPlatforms"]
        locations=None,  # type: Optional["models.MicrosoftGraphConditionalAccessLocations"]
        client_app_types=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphConditionalAccessClientApp"]]]
        device_states=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDeviceStates"]
        devices=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDevices"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property conditionalAccessPolicies in policies.

        Update the navigation property conditionalAccessPolicies in policies.

        :param conditional_access_policy_id: key: conditionalAccessPolicy-id of
         conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param modified_date_time:
        :type modified_date_time: ~datetime.datetime
        :param display_name:
        :type display_name: str
        :param description:
        :type description: str
        :param state: conditionalAccessPolicyState.
        :type state: str or ~identity_policies.models.MicrosoftGraphConditionalAccessPolicyState
        :param grant_controls: conditionalAccessGrantControls.
        :type grant_controls: ~identity_policies.models.MicrosoftGraphConditionalAccessGrantControls
        :param cloud_app_security: cloudAppSecuritySessionControl.
        :type cloud_app_security: ~identity_policies.models.MicrosoftGraphCloudAppSecuritySessionControl
        :param sign_in_frequency: signInFrequencySessionControl.
        :type sign_in_frequency: ~identity_policies.models.MicrosoftGraphSignInFrequencySessionControl
        :param persistent_browser: persistentBrowserSessionControl.
        :type persistent_browser: ~identity_policies.models.MicrosoftGraphPersistentBrowserSessionControl
        :param is_enabled:
        :type is_enabled: bool
        :param applications: conditionalAccessApplications.
        :type applications: ~identity_policies.models.MicrosoftGraphConditionalAccessApplications
        :param users: conditionalAccessUsers.
        :type users: ~identity_policies.models.MicrosoftGraphConditionalAccessUsers
        :param sign_in_risk_levels:
        :type sign_in_risk_levels: list[str or ~identity_policies.models.MicrosoftGraphRiskLevel]
        :param platforms: conditionalAccessPlatforms.
        :type platforms: ~identity_policies.models.MicrosoftGraphConditionalAccessPlatforms
        :param locations: conditionalAccessLocations.
        :type locations: ~identity_policies.models.MicrosoftGraphConditionalAccessLocations
        :param client_app_types:
        :type client_app_types: list[str or ~identity_policies.models.MicrosoftGraphConditionalAccessClientApp]
        :param device_states: conditionalAccessDeviceStates.
        :type device_states: ~identity_policies.models.MicrosoftGraphConditionalAccessDeviceStates
        :param devices: conditionalAccessDevices.
        :type devices: ~identity_policies.models.MicrosoftGraphConditionalAccessDevices
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConditionalAccessPolicy(id=id, created_date_time=created_date_time, modified_date_time=modified_date_time, display_name=display_name, description=description, state=state, grant_controls=grant_controls, cloud_app_security=cloud_app_security, sign_in_frequency=sign_in_frequency, persistent_browser=persistent_browser, is_enabled=is_enabled, applications=applications, users=users, sign_in_risk_levels=sign_in_risk_levels, platforms=platforms, locations=locations, client_app_types=client_app_types, device_states=device_states, devices=devices)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConditionalAccessPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    def list_home_realm_discovery_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum24"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum25"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum26"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfHomeRealmDiscoveryPolicy"]
        """Get homeRealmDiscoveryPolicies from policies.

        Get homeRealmDiscoveryPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_policies.models.Enum24]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum26]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfHomeRealmDiscoveryPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_policies.models.CollectionOfHomeRealmDiscoveryPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_home_realm_discovery_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfHomeRealmDiscoveryPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies'}  # type: ignore

    def create_home_realm_discovery_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Create new navigation property to homeRealmDiscoveryPolicies for policies.

        Create new navigation property to homeRealmDiscoveryPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_home_realm_discovery_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies'}  # type: ignore

    def get_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum27"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum28"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Get homeRealmDiscoveryPolicies from policies.

        Get homeRealmDiscoveryPolicies from policies.

        :param home_realm_discovery_policy_id: key: homeRealmDiscoveryPolicy-id of
         homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum27]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum28]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    def update_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property homeRealmDiscoveryPolicies in policies.

        Update the navigation property homeRealmDiscoveryPolicies in policies.

        :param home_realm_discovery_policy_id: key: homeRealmDiscoveryPolicy-id of
         homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    def get_identity_security_default_enforcement_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum29"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy"
        """Get identitySecurityDefaultsEnforcementPolicy from policies.

        Get identitySecurityDefaultsEnforcementPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum29]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    def update_identity_security_default_enforcement_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        is_enabled=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property identitySecurityDefaultsEnforcementPolicy in policies.

        Update the navigation property identitySecurityDefaultsEnforcementPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param is_enabled:
        :type is_enabled: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, is_enabled=is_enabled)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    def list_token_issuance_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum30"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum31"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum32"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfTokenIssuancePolicy"]
        """Get tokenIssuancePolicies from policies.

        Get tokenIssuancePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_policies.models.Enum30]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum31]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum32]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenIssuancePolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_policies.models.CollectionOfTokenIssuancePolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_issuance_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenIssuancePolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies'}  # type: ignore

    def create_token_issuance_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Create new navigation property to tokenIssuancePolicies for policies.

        Create new navigation property to tokenIssuancePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_token_issuance_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies'}  # type: ignore

    def get_token_issuance_policy(
        self,
        token_issuance_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum33"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum34"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Get tokenIssuancePolicies from policies.

        Get tokenIssuancePolicies from policies.

        :param token_issuance_policy_id: key: tokenIssuancePolicy-id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum33]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum34]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    def update_token_issuance_policy(
        self,
        token_issuance_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property tokenIssuancePolicies in policies.

        Update the navigation property tokenIssuancePolicies in policies.

        :param token_issuance_policy_id: key: tokenIssuancePolicy-id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    def list_token_lifetime_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum35"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum36"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum37"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfTokenLifetimePolicy"]
        """Get tokenLifetimePolicies from policies.

        Get tokenLifetimePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_policies.models.Enum35]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum36]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum37]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenLifetimePolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_policies.models.CollectionOfTokenLifetimePolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_lifetime_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenLifetimePolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies'}  # type: ignore

    def create_token_lifetime_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Create new navigation property to tokenLifetimePolicies for policies.

        Create new navigation property to tokenLifetimePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_token_lifetime_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies'}  # type: ignore

    def get_token_lifetime_policy(
        self,
        token_lifetime_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum38"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum39"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphStsPolicy"
        """Get tokenLifetimePolicies from policies.

        Get tokenLifetimePolicies from policies.

        :param token_lifetime_policy_id: key: tokenLifetimePolicy-id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_policies.models.Enum38]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_policies.models.Enum39]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphStsPolicy, or the result of cls(response)
        :rtype: ~identity_policies.models.MicrosoftGraphStsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphStsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphStsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore

    def update_token_lifetime_policy(
        self,
        token_lifetime_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property tokenLifetimePolicies in policies.

        Update the navigation property tokenLifetimePolicies in policies.

        :param token_lifetime_policy_id: key: tokenLifetimePolicy-id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_policies.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphStsPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphStsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore
