# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class ReportOperations(object):
    """ReportOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~reports.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_application_sign_in_detailed_summary(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Get5ItemsItem"]]]
        select=None,  # type: Optional[List[Union[str, "models.Get6ItemsItem"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfApplicationSignInDetailedSummary"]
        """Get applicationSignInDetailedSummary from reports.

        Get applicationSignInDetailedSummary from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfApplicationSignInDetailedSummary or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfApplicationSignInDetailedSummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfApplicationSignInDetailedSummary"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_application_sign_in_detailed_summary.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfApplicationSignInDetailedSummary', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary'}  # type: ignore

    def create_application_sign_in_detailed_summary(
        self,
        id=None,  # type: Optional[str]
        app_id=None,  # type: Optional[str]
        app_display_name=None,  # type: Optional[str]
        sign_in_count=None,  # type: Optional[int]
        aggregated_event_date_time=None,  # type: Optional[datetime.datetime]
        error_code=None,  # type: Optional[int]
        failure_reason=None,  # type: Optional[str]
        additional_details=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphApplicationSignInDetailedSummary"
        """Create new navigation property to applicationSignInDetailedSummary for reports.

        Create new navigation property to applicationSignInDetailedSummary for reports.

        :param id: Read-only.
        :type id: str
        :param app_id:
        :type app_id: str
        :param app_display_name:
        :type app_display_name: str
        :param sign_in_count:
        :type sign_in_count: long
        :param aggregated_event_date_time:
        :type aggregated_event_date_time: ~datetime.datetime
        :param error_code: Provides the 5-6digit error code that's generated during a sign-in failure.
         Check out the list of error codes and messages.
        :type error_code: int
        :param failure_reason: Provides the error message or the reason for failure for the
         corresponding sign-in activity. Check out the list of error codes and messages.
        :type failure_reason: str
        :param additional_details: Provides additional details on the sign-in activity.
        :type additional_details: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphApplicationSignInDetailedSummary, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphApplicationSignInDetailedSummary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphApplicationSignInDetailedSummary"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphApplicationSignInDetailedSummary(id=id, app_id=app_id, app_display_name=app_display_name, sign_in_count=sign_in_count, aggregated_event_date_time=aggregated_event_date_time, error_code=error_code, failure_reason=failure_reason, additional_details=additional_details)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_application_sign_in_detailed_summary.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphApplicationSignInDetailedSummary')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphApplicationSignInDetailedSummary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary'}  # type: ignore

    def get_application_sign_in_detailed_summary(
        self,
        application_sign_in_detailed_summary_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum7"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphApplicationSignInDetailedSummary"
        """Get applicationSignInDetailedSummary from reports.

        Get applicationSignInDetailedSummary from reports.

        :param application_sign_in_detailed_summary_id: key: applicationSignInDetailedSummary-id of
         applicationSignInDetailedSummary.
        :type application_sign_in_detailed_summary_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum7]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphApplicationSignInDetailedSummary, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphApplicationSignInDetailedSummary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphApplicationSignInDetailedSummary"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_application_sign_in_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'applicationSignInDetailedSummary-id': self._serialize.url("application_sign_in_detailed_summary_id", application_sign_in_detailed_summary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphApplicationSignInDetailedSummary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary/{applicationSignInDetailedSummary-id}'}  # type: ignore

    def update_application_sign_in_detailed_summary(
        self,
        application_sign_in_detailed_summary_id,  # type: str
        id=None,  # type: Optional[str]
        app_id=None,  # type: Optional[str]
        app_display_name=None,  # type: Optional[str]
        sign_in_count=None,  # type: Optional[int]
        aggregated_event_date_time=None,  # type: Optional[datetime.datetime]
        error_code=None,  # type: Optional[int]
        failure_reason=None,  # type: Optional[str]
        additional_details=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property applicationSignInDetailedSummary in reports.

        Update the navigation property applicationSignInDetailedSummary in reports.

        :param application_sign_in_detailed_summary_id: key: applicationSignInDetailedSummary-id of
         applicationSignInDetailedSummary.
        :type application_sign_in_detailed_summary_id: str
        :param id: Read-only.
        :type id: str
        :param app_id:
        :type app_id: str
        :param app_display_name:
        :type app_display_name: str
        :param sign_in_count:
        :type sign_in_count: long
        :param aggregated_event_date_time:
        :type aggregated_event_date_time: ~datetime.datetime
        :param error_code: Provides the 5-6digit error code that's generated during a sign-in failure.
         Check out the list of error codes and messages.
        :type error_code: int
        :param failure_reason: Provides the error message or the reason for failure for the
         corresponding sign-in activity. Check out the list of error codes and messages.
        :type failure_reason: str
        :param additional_details: Provides additional details on the sign-in activity.
        :type additional_details: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphApplicationSignInDetailedSummary(id=id, app_id=app_id, app_display_name=app_display_name, sign_in_count=sign_in_count, aggregated_event_date_time=aggregated_event_date_time, error_code=error_code, failure_reason=failure_reason, additional_details=additional_details)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_application_sign_in_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'applicationSignInDetailedSummary-id': self._serialize.url("application_sign_in_detailed_summary_id", application_sign_in_detailed_summary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphApplicationSignInDetailedSummary')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary/{applicationSignInDetailedSummary-id}'}  # type: ignore

    def list_credential_user_registration_detail(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum8"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum9"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfCredentialUserRegistrationDetails"]
        """Get credentialUserRegistrationDetails from reports.

        Get credentialUserRegistrationDetails from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum8]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum9]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCredentialUserRegistrationDetails or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfCredentialUserRegistrationDetails]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCredentialUserRegistrationDetails"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_credential_user_registration_detail.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCredentialUserRegistrationDetails', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_credential_user_registration_detail.metadata = {'url': '/reports/credentialUserRegistrationDetails'}  # type: ignore

    def create_credential_user_registration_detail(
        self,
        id=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        user_display_name=None,  # type: Optional[str]
        auth_methods=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRegistrationAuthMethod"]]]
        is_registered=None,  # type: Optional[bool]
        is_enabled=None,  # type: Optional[bool]
        is_capable=None,  # type: Optional[bool]
        is_mfa_registered=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphCredentialUserRegistrationDetails"
        """Create new navigation property to credentialUserRegistrationDetails for reports.

        Create new navigation property to credentialUserRegistrationDetails for reports.

        :param id: Read-only.
        :type id: str
        :param user_principal_name:
        :type user_principal_name: str
        :param user_display_name:
        :type user_display_name: str
        :param auth_methods:
        :type auth_methods: list[str or ~reports.models.MicrosoftGraphRegistrationAuthMethod]
        :param is_registered:
        :type is_registered: bool
        :param is_enabled:
        :type is_enabled: bool
        :param is_capable:
        :type is_capable: bool
        :param is_mfa_registered:
        :type is_mfa_registered: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCredentialUserRegistrationDetails, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphCredentialUserRegistrationDetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCredentialUserRegistrationDetails"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphCredentialUserRegistrationDetails(id=id, user_principal_name=user_principal_name, user_display_name=user_display_name, auth_methods=auth_methods, is_registered=is_registered, is_enabled=is_enabled, is_capable=is_capable, is_mfa_registered=is_mfa_registered)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_credential_user_registration_detail.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphCredentialUserRegistrationDetails')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCredentialUserRegistrationDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_credential_user_registration_detail.metadata = {'url': '/reports/credentialUserRegistrationDetails'}  # type: ignore

    def get_credential_user_registration_detail(
        self,
        credential_user_registration_details_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum10"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphCredentialUserRegistrationDetails"
        """Get credentialUserRegistrationDetails from reports.

        Get credentialUserRegistrationDetails from reports.

        :param credential_user_registration_details_id: key: credentialUserRegistrationDetails-id of
         credentialUserRegistrationDetails.
        :type credential_user_registration_details_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum10]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCredentialUserRegistrationDetails, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphCredentialUserRegistrationDetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCredentialUserRegistrationDetails"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_credential_user_registration_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'credentialUserRegistrationDetails-id': self._serialize.url("credential_user_registration_details_id", credential_user_registration_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCredentialUserRegistrationDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_credential_user_registration_detail.metadata = {'url': '/reports/credentialUserRegistrationDetails/{credentialUserRegistrationDetails-id}'}  # type: ignore

    def update_credential_user_registration_detail(
        self,
        credential_user_registration_details_id,  # type: str
        id=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        user_display_name=None,  # type: Optional[str]
        auth_methods=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRegistrationAuthMethod"]]]
        is_registered=None,  # type: Optional[bool]
        is_enabled=None,  # type: Optional[bool]
        is_capable=None,  # type: Optional[bool]
        is_mfa_registered=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property credentialUserRegistrationDetails in reports.

        Update the navigation property credentialUserRegistrationDetails in reports.

        :param credential_user_registration_details_id: key: credentialUserRegistrationDetails-id of
         credentialUserRegistrationDetails.
        :type credential_user_registration_details_id: str
        :param id: Read-only.
        :type id: str
        :param user_principal_name:
        :type user_principal_name: str
        :param user_display_name:
        :type user_display_name: str
        :param auth_methods:
        :type auth_methods: list[str or ~reports.models.MicrosoftGraphRegistrationAuthMethod]
        :param is_registered:
        :type is_registered: bool
        :param is_enabled:
        :type is_enabled: bool
        :param is_capable:
        :type is_capable: bool
        :param is_mfa_registered:
        :type is_mfa_registered: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphCredentialUserRegistrationDetails(id=id, user_principal_name=user_principal_name, user_display_name=user_display_name, auth_methods=auth_methods, is_registered=is_registered, is_enabled=is_enabled, is_capable=is_capable, is_mfa_registered=is_mfa_registered)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_credential_user_registration_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'credentialUserRegistrationDetails-id': self._serialize.url("credential_user_registration_details_id", credential_user_registration_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphCredentialUserRegistrationDetails')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_credential_user_registration_detail.metadata = {'url': '/reports/credentialUserRegistrationDetails/{credentialUserRegistrationDetails-id}'}  # type: ignore

    def list_daily_print_usage_summary_by_printer(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum11"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum12"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfPrintUsageSummaryByPrinter"]
        """Get dailyPrintUsageSummariesByPrinter from reports.

        Get dailyPrintUsageSummariesByPrinter from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum11]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum12]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPrintUsageSummaryByPrinter or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfPrintUsageSummaryByPrinter]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPrintUsageSummaryByPrinter"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_daily_print_usage_summary_by_printer.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPrintUsageSummaryByPrinter', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_daily_print_usage_summary_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter'}  # type: ignore

    def create_daily_print_usage_summary_by_printer(
        self,
        id=None,  # type: Optional[str]
        printer_id=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByPrinter"
        """Create new navigation property to dailyPrintUsageSummariesByPrinter for reports.

        Create new navigation property to dailyPrintUsageSummariesByPrinter for reports.

        :param id: Read-only.
        :type id: str
        :param printer_id:
        :type printer_id: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByPrinter, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByPrinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByPrinter"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByPrinter(id=id, printer_id=printer_id, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_daily_print_usage_summary_by_printer.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByPrinter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByPrinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_daily_print_usage_summary_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter'}  # type: ignore

    def get_daily_print_usage_summary_by_printer(
        self,
        print_usage_summary_by_printer_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum13"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByPrinter"
        """Get dailyPrintUsageSummariesByPrinter from reports.

        Get dailyPrintUsageSummariesByPrinter from reports.

        :param print_usage_summary_by_printer_id: key: PrintUsageSummaryByPrinter-id of
         PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum13]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByPrinter, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByPrinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByPrinter"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_daily_print_usage_summary_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByPrinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_daily_print_usage_summary_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    def update_daily_print_usage_summary_by_printer(
        self,
        print_usage_summary_by_printer_id,  # type: str
        id=None,  # type: Optional[str]
        printer_id=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property dailyPrintUsageSummariesByPrinter in reports.

        Update the navigation property dailyPrintUsageSummariesByPrinter in reports.

        :param print_usage_summary_by_printer_id: key: PrintUsageSummaryByPrinter-id of
         PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param id: Read-only.
        :type id: str
        :param printer_id:
        :type printer_id: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByPrinter(id=id, printer_id=printer_id, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_daily_print_usage_summary_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByPrinter')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_daily_print_usage_summary_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    def list_daily_print_usage_summary_by_user(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum14"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum15"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfPrintUsageSummaryByUser"]
        """Get dailyPrintUsageSummariesByUser from reports.

        Get dailyPrintUsageSummariesByUser from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum14]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum15]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPrintUsageSummaryByUser or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfPrintUsageSummaryByUser]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPrintUsageSummaryByUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_daily_print_usage_summary_by_user.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPrintUsageSummaryByUser', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_daily_print_usage_summary_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser'}  # type: ignore

    def create_daily_print_usage_summary_by_user(
        self,
        id=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByUser"
        """Create new navigation property to dailyPrintUsageSummariesByUser for reports.

        Create new navigation property to dailyPrintUsageSummariesByUser for reports.

        :param id: Read-only.
        :type id: str
        :param user_principal_name:
        :type user_principal_name: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByUser, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByUser(id=id, user_principal_name=user_principal_name, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_daily_print_usage_summary_by_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByUser')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_daily_print_usage_summary_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser'}  # type: ignore

    def get_daily_print_usage_summary_by_user(
        self,
        print_usage_summary_by_user_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum16"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByUser"
        """Get dailyPrintUsageSummariesByUser from reports.

        Get dailyPrintUsageSummariesByUser from reports.

        :param print_usage_summary_by_user_id: key: PrintUsageSummaryByUser-id of
         PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum16]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByUser, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_daily_print_usage_summary_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_daily_print_usage_summary_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    def update_daily_print_usage_summary_by_user(
        self,
        print_usage_summary_by_user_id,  # type: str
        id=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property dailyPrintUsageSummariesByUser in reports.

        Update the navigation property dailyPrintUsageSummariesByUser in reports.

        :param print_usage_summary_by_user_id: key: PrintUsageSummaryByUser-id of
         PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param id: Read-only.
        :type id: str
        :param user_principal_name:
        :type user_principal_name: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByUser(id=id, user_principal_name=user_principal_name, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_daily_print_usage_summary_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByUser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_daily_print_usage_summary_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    def device_configuration_device_activity(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function deviceConfigurationDeviceActivity.

        Invoke function deviceConfigurationDeviceActivity.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.device_configuration_device_activity.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    device_configuration_device_activity.metadata = {'url': '/reports/microsoft.graph.deviceConfigurationDeviceActivity()'}  # type: ignore

    def device_configuration_user_activity(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function deviceConfigurationUserActivity.

        Invoke function deviceConfigurationUserActivity.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.device_configuration_user_activity.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    device_configuration_user_activity.metadata = {'url': '/reports/microsoft.graph.deviceConfigurationUserActivity()'}  # type: ignore

    def get_azure_ad_application_sign_in_summary(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphApplicationSignInSummary"]
        """Invoke function getAzureADApplicationSignInSummary.

        Invoke function getAzureADApplicationSignInSummary.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphApplicationSignInSummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphApplicationSignInSummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphApplicationSignInSummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_azure_ad_application_sign_in_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphApplicationSignInSummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_application_sign_in_summary.metadata = {'url': '/reports/microsoft.graph.getAzureADApplicationSignInSummary(period={period})'}  # type: ignore

    def get_azure_ad_feature_usage(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphAzureAdFeatureUsage"]
        """Invoke function getAzureADFeatureUsage.

        Invoke function getAzureADFeatureUsage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphAzureAdFeatureUsage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphAzureAdFeatureUsage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphAzureAdFeatureUsage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_azure_ad_feature_usage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphAzureAdFeatureUsage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_feature_usage.metadata = {'url': '/reports/microsoft.graph.getAzureADFeatureUsage(period={period})'}  # type: ignore

    def get_azure_ad_license_usage(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphAzureAdLicenseUsage"]
        """Invoke function getAzureADLicenseUsage.

        Invoke function getAzureADLicenseUsage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphAzureAdLicenseUsage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphAzureAdLicenseUsage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphAzureAdLicenseUsage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_azure_ad_license_usage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphAzureAdLicenseUsage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_license_usage.metadata = {'url': '/reports/microsoft.graph.getAzureADLicenseUsage(period={period})'}  # type: ignore

    def get_azure_ad_user_feature_usage(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphAzureAdUserFeatureUsage"]
        """Invoke function getAzureADUserFeatureUsage.

        Invoke function getAzureADUserFeatureUsage.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphAzureAdUserFeatureUsage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphAzureAdUserFeatureUsage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphAzureAdUserFeatureUsage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_azure_ad_user_feature_usage.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphAzureAdUserFeatureUsage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_user_feature_usage.metadata = {'url': '/reports/microsoft.graph.getAzureADUserFeatureUsage()'}  # type: ignore

    def get_credential_usage_summary(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphCredentialUsageSummary"]
        """Invoke function getCredentialUsageSummary.

        Invoke function getCredentialUsageSummary.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphCredentialUsageSummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphCredentialUsageSummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphCredentialUsageSummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_credential_usage_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphCredentialUsageSummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_credential_usage_summary.metadata = {'url': '/reports/microsoft.graph.getCredentialUsageSummary(period={period})'}  # type: ignore

    def get_credential_user_registration_count(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphCredentialUserRegistrationCount"]
        """Invoke function getCredentialUserRegistrationCount.

        Invoke function getCredentialUserRegistrationCount.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphCredentialUserRegistrationCount, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphCredentialUserRegistrationCount]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphCredentialUserRegistrationCount"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_credential_user_registration_count.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphCredentialUserRegistrationCount]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_credential_user_registration_count.metadata = {'url': '/reports/microsoft.graph.getCredentialUserRegistrationCount()'}  # type: ignore

    def get_email_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailActivitySummary"]
        """Invoke function getEmailActivityCounts.

        Invoke function getEmailActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_count.metadata = {'url': '/reports/microsoft.graph.getEmailActivityCounts(period={period})'}  # type: ignore

    def get_email_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailActivitySummary"]
        """Invoke function getEmailActivityUserCounts.

        Invoke function getEmailActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getEmailActivityUserCounts(period={period})'}  # type: ignore

    def get_email_activity_user_detail_fe32(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailActivityUserDetail"]
        """Invoke function getEmailActivityUserDetail.

        Invoke function getEmailActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_activity_user_detail_fe32.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_user_detail_fe32.metadata = {'url': '/reports/microsoft.graph.getEmailActivityUserDetail(date={date})'}  # type: ignore

    def get_email_activity_user_detail_ddb2(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailActivityUserDetail"]
        """Invoke function getEmailActivityUserDetail.

        Invoke function getEmailActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_activity_user_detail_ddb2.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_user_detail_ddb2.metadata = {'url': '/reports/microsoft.graph.getEmailActivityUserDetail(period={period})'}  # type: ignore

    def get_email_app_usage_app_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailAppUsageAppsUserCounts"]
        """Invoke function getEmailAppUsageAppsUserCounts.

        Invoke function getEmailAppUsageAppsUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailAppUsageAppsUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailAppUsageAppsUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailAppUsageAppsUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_app_usage_app_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailAppUsageAppsUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_app_user_count.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageAppsUserCounts(period={period})'}  # type: ignore

    def get_email_app_usage_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailAppUsageUserCounts"]
        """Invoke function getEmailAppUsageUserCounts.

        Invoke function getEmailAppUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailAppUsageUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailAppUsageUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailAppUsageUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_app_usage_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailAppUsageUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_user_count.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageUserCounts(period={period})'}  # type: ignore

    def get_email_app_usage_user_detail62_ec(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailAppUsageUserDetail"]
        """Invoke function getEmailAppUsageUserDetail.

        Invoke function getEmailAppUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailAppUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailAppUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailAppUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_app_usage_user_detail62_ec.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailAppUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_user_detail62_ec.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageUserDetail(date={date})'}  # type: ignore

    def get_email_app_usage_user_detail546_b(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailAppUsageUserDetail"]
        """Invoke function getEmailAppUsageUserDetail.

        Invoke function getEmailAppUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailAppUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailAppUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailAppUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_app_usage_user_detail546_b.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailAppUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_user_detail546_b.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageUserDetail(period={period})'}  # type: ignore

    def get_email_app_usage_version_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphEmailAppUsageVersionsUserCounts"]
        """Invoke function getEmailAppUsageVersionsUserCounts.

        Invoke function getEmailAppUsageVersionsUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphEmailAppUsageVersionsUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphEmailAppUsageVersionsUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphEmailAppUsageVersionsUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_email_app_usage_version_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphEmailAppUsageVersionsUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_version_user_count.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageVersionsUserCounts(period={period})'}  # type: ignore

    def get_mailbox_usage_detail(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphMailboxUsageDetail"]
        """Invoke function getMailboxUsageDetail.

        Invoke function getMailboxUsageDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphMailboxUsageDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphMailboxUsageDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphMailboxUsageDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_mailbox_usage_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphMailboxUsageDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_detail.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageDetail(period={period})'}  # type: ignore

    def get_mailbox_usage_mailbox_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphMailboxUsageMailboxCounts"]
        """Invoke function getMailboxUsageMailboxCounts.

        Invoke function getMailboxUsageMailboxCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphMailboxUsageMailboxCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphMailboxUsageMailboxCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphMailboxUsageMailboxCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_mailbox_usage_mailbox_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphMailboxUsageMailboxCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_mailbox_count.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageMailboxCounts(period={period})'}  # type: ignore

    def get_mailbox_usage_quota_status_mailbox_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphMailboxUsageQuotaStatusMailboxCounts"]
        """Invoke function getMailboxUsageQuotaStatusMailboxCounts.

        Invoke function getMailboxUsageQuotaStatusMailboxCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphMailboxUsageQuotaStatusMailboxCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphMailboxUsageQuotaStatusMailboxCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphMailboxUsageQuotaStatusMailboxCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_mailbox_usage_quota_status_mailbox_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphMailboxUsageQuotaStatusMailboxCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_quota_status_mailbox_count.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageQuotaStatusMailboxCounts(period={period})'}  # type: ignore

    def get_mailbox_usage_storage(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphMailboxUsageStorage"]
        """Invoke function getMailboxUsageStorage.

        Invoke function getMailboxUsageStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphMailboxUsageStorage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphMailboxUsageStorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphMailboxUsageStorage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_mailbox_usage_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphMailboxUsageStorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_storage.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageStorage(period={period})'}  # type: ignore

    def get_office365_activation_count(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ActivationCounts"]
        """Invoke function getOffice365ActivationCounts.

        Invoke function getOffice365ActivationCounts.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ActivationCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ActivationCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ActivationCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_activation_count.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ActivationCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_activation_count.metadata = {'url': '/reports/microsoft.graph.getOffice365ActivationCounts()'}  # type: ignore

    def get_office365_activation_user_count(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ActivationsUserCounts"]
        """Invoke function getOffice365ActivationsUserCounts.

        Invoke function getOffice365ActivationsUserCounts.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ActivationsUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ActivationsUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ActivationsUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_activation_user_count.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ActivationsUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_activation_user_count.metadata = {'url': '/reports/microsoft.graph.getOffice365ActivationsUserCounts()'}  # type: ignore

    def get_office365_activation_user_detail(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ActivationsUserDetail"]
        """Invoke function getOffice365ActivationsUserDetail.

        Invoke function getOffice365ActivationsUserDetail.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ActivationsUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ActivationsUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ActivationsUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_activation_user_detail.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ActivationsUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_activation_user_detail.metadata = {'url': '/reports/microsoft.graph.getOffice365ActivationsUserDetail()'}  # type: ignore

    def get_office365_active_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ActiveUserCounts"]
        """Invoke function getOffice365ActiveUserCounts.

        Invoke function getOffice365ActiveUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ActiveUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ActiveUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ActiveUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_active_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ActiveUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_active_user_count.metadata = {'url': '/reports/microsoft.graph.getOffice365ActiveUserCounts(period={period})'}  # type: ignore

    def get_office365_active_user_detail_d389(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ActiveUserDetail"]
        """Invoke function getOffice365ActiveUserDetail.

        Invoke function getOffice365ActiveUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ActiveUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ActiveUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ActiveUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_active_user_detail_d389.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ActiveUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_active_user_detail_d389.metadata = {'url': '/reports/microsoft.graph.getOffice365ActiveUserDetail(date={date})'}  # type: ignore

    def get_office365_active_user_detail68_ad(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ActiveUserDetail"]
        """Invoke function getOffice365ActiveUserDetail.

        Invoke function getOffice365ActiveUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ActiveUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ActiveUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ActiveUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_active_user_detail68_ad.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ActiveUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_active_user_detail68_ad.metadata = {'url': '/reports/microsoft.graph.getOffice365ActiveUserDetail(period={period})'}  # type: ignore

    def get_office365_group_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365GroupsActivityCounts"]
        """Invoke function getOffice365GroupsActivityCounts.

        Invoke function getOffice365GroupsActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365GroupsActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365GroupsActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365GroupsActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_group_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365GroupsActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_group_activity_count.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityCounts(period={period})'}  # type: ignore

    def get_office365_group_activity_detail81_cc(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365GroupsActivityDetail"]
        """Invoke function getOffice365GroupsActivityDetail.

        Invoke function getOffice365GroupsActivityDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365GroupsActivityDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365GroupsActivityDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365GroupsActivityDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_group_activity_detail81_cc.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365GroupsActivityDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_group_activity_detail81_cc.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityDetail(date={date})'}  # type: ignore

    def get_office365_group_activity_detail38_f6(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365GroupsActivityDetail"]
        """Invoke function getOffice365GroupsActivityDetail.

        Invoke function getOffice365GroupsActivityDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365GroupsActivityDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365GroupsActivityDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365GroupsActivityDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_group_activity_detail38_f6.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365GroupsActivityDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_group_activity_detail38_f6.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityDetail(period={period})'}  # type: ignore

    def get_office365_group_activity_file_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365GroupsActivityFileCounts"]
        """Invoke function getOffice365GroupsActivityFileCounts.

        Invoke function getOffice365GroupsActivityFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365GroupsActivityFileCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365GroupsActivityFileCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365GroupsActivityFileCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_group_activity_file_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365GroupsActivityFileCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_group_activity_file_count.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityFileCounts(period={period})'}  # type: ignore

    def get_office365_group_activity_group_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365GroupsActivityGroupCounts"]
        """Invoke function getOffice365GroupsActivityGroupCounts.

        Invoke function getOffice365GroupsActivityGroupCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365GroupsActivityGroupCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365GroupsActivityGroupCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365GroupsActivityGroupCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_group_activity_group_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365GroupsActivityGroupCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_group_activity_group_count.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityGroupCounts(period={period})'}  # type: ignore

    def get_office365_group_activity_storage(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365GroupsActivityStorage"]
        """Invoke function getOffice365GroupsActivityStorage.

        Invoke function getOffice365GroupsActivityStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365GroupsActivityStorage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365GroupsActivityStorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365GroupsActivityStorage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_group_activity_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365GroupsActivityStorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_group_activity_storage.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityStorage(period={period})'}  # type: ignore

    def get_office365_service_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOffice365ServicesUserCounts"]
        """Invoke function getOffice365ServicesUserCounts.

        Invoke function getOffice365ServicesUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOffice365ServicesUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOffice365ServicesUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOffice365ServicesUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_office365_service_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOffice365ServicesUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_service_user_count.metadata = {'url': '/reports/microsoft.graph.getOffice365ServicesUserCounts(period={period})'}  # type: ignore

    def get_one_drive_activity_file_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSiteActivitySummary"]
        """Invoke function getOneDriveActivityFileCounts.

        Invoke function getOneDriveActivityFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSiteActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSiteActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSiteActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_activity_file_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSiteActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_file_count.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityFileCounts(period={period})'}  # type: ignore

    def get_one_drive_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSiteActivitySummary"]
        """Invoke function getOneDriveActivityUserCounts.

        Invoke function getOneDriveActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSiteActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSiteActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSiteActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSiteActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityUserCounts(period={period})'}  # type: ignore

    def get_one_drive_activity_user_detail05_f1(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOneDriveActivityUserDetail"]
        """Invoke function getOneDriveActivityUserDetail.

        Invoke function getOneDriveActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOneDriveActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOneDriveActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOneDriveActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_activity_user_detail05_f1.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOneDriveActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_user_detail05_f1.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityUserDetail(date={date})'}  # type: ignore

    def get_one_drive_activity_user_detail_c424(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOneDriveActivityUserDetail"]
        """Invoke function getOneDriveActivityUserDetail.

        Invoke function getOneDriveActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOneDriveActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOneDriveActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOneDriveActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_activity_user_detail_c424.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOneDriveActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_user_detail_c424.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityUserDetail(period={period})'}  # type: ignore

    def get_one_drive_usage_account_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOneDriveUsageAccountCounts"]
        """Invoke function getOneDriveUsageAccountCounts.

        Invoke function getOneDriveUsageAccountCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOneDriveUsageAccountCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOneDriveUsageAccountCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOneDriveUsageAccountCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_usage_account_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOneDriveUsageAccountCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_account_count.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageAccountCounts(period={period})'}  # type: ignore

    def get_one_drive_usage_account_detail_e827(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOneDriveUsageAccountDetail"]
        """Invoke function getOneDriveUsageAccountDetail.

        Invoke function getOneDriveUsageAccountDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOneDriveUsageAccountDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOneDriveUsageAccountDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOneDriveUsageAccountDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_usage_account_detail_e827.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOneDriveUsageAccountDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_account_detail_e827.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageAccountDetail(date={date})'}  # type: ignore

    def get_one_drive_usage_account_detail_dd7_f(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOneDriveUsageAccountDetail"]
        """Invoke function getOneDriveUsageAccountDetail.

        Invoke function getOneDriveUsageAccountDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOneDriveUsageAccountDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOneDriveUsageAccountDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOneDriveUsageAccountDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_usage_account_detail_dd7_f.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOneDriveUsageAccountDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_account_detail_dd7_f.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageAccountDetail(period={period})'}  # type: ignore

    def get_one_drive_usage_file_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphOneDriveUsageFileCounts"]
        """Invoke function getOneDriveUsageFileCounts.

        Invoke function getOneDriveUsageFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphOneDriveUsageFileCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphOneDriveUsageFileCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphOneDriveUsageFileCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_usage_file_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphOneDriveUsageFileCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_file_count.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageFileCounts(period={period})'}  # type: ignore

    def get_one_drive_usage_storage(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSiteUsageStorage"]
        """Invoke function getOneDriveUsageStorage.

        Invoke function getOneDriveUsageStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSiteUsageStorage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSiteUsageStorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSiteUsageStorage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_one_drive_usage_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSiteUsageStorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_storage.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageStorage(period={period})'}  # type: ignore

    def get_relying_party_detailed_summary(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphRelyingPartyDetailedSummary"]
        """Invoke function getRelyingPartyDetailedSummary.

        Invoke function getRelyingPartyDetailedSummary.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphRelyingPartyDetailedSummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphRelyingPartyDetailedSummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphRelyingPartyDetailedSummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_relying_party_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphRelyingPartyDetailedSummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_relying_party_detailed_summary.metadata = {'url': '/reports/microsoft.graph.getRelyingPartyDetailedSummary(period={period})'}  # type: ignore

    def get_share_point_activity_file_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSiteActivitySummary"]
        """Invoke function getSharePointActivityFileCounts.

        Invoke function getSharePointActivityFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSiteActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSiteActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSiteActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_activity_file_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSiteActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_file_count.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityFileCounts(period={period})'}  # type: ignore

    def get_share_point_activity_page(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointActivityPages"]
        """Invoke function getSharePointActivityPages.

        Invoke function getSharePointActivityPages.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointActivityPages, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointActivityPages]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointActivityPages"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_activity_page.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointActivityPages]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_page.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityPages(period={period})'}  # type: ignore

    def get_share_point_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointActivityUserCounts"]
        """Invoke function getSharePointActivityUserCounts.

        Invoke function getSharePointActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointActivityUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointActivityUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointActivityUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointActivityUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityUserCounts(period={period})'}  # type: ignore

    def get_share_point_activity_user_detail_f3_be(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointActivityUserDetail"]
        """Invoke function getSharePointActivityUserDetail.

        Invoke function getSharePointActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_activity_user_detail_f3_be.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_user_detail_f3_be.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityUserDetail(date={date})'}  # type: ignore

    def get_share_point_activity_user_detail_b778(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointActivityUserDetail"]
        """Invoke function getSharePointActivityUserDetail.

        Invoke function getSharePointActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_activity_user_detail_b778.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_user_detail_b778.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityUserDetail(period={period})'}  # type: ignore

    def get_share_point_site_usage_detail_d27_a(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointSiteUsageDetail"]
        """Invoke function getSharePointSiteUsageDetail.

        Invoke function getSharePointSiteUsageDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointSiteUsageDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointSiteUsageDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointSiteUsageDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_site_usage_detail_d27_a.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointSiteUsageDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_detail_d27_a.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageDetail(date={date})'}  # type: ignore

    def get_share_point_site_usage_detail204_b(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointSiteUsageDetail"]
        """Invoke function getSharePointSiteUsageDetail.

        Invoke function getSharePointSiteUsageDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointSiteUsageDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointSiteUsageDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointSiteUsageDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_site_usage_detail204_b.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointSiteUsageDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_detail204_b.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageDetail(period={period})'}  # type: ignore

    def get_share_point_site_usage_file_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointSiteUsageFileCounts"]
        """Invoke function getSharePointSiteUsageFileCounts.

        Invoke function getSharePointSiteUsageFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointSiteUsageFileCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointSiteUsageFileCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointSiteUsageFileCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_site_usage_file_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointSiteUsageFileCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_file_count.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageFileCounts(period={period})'}  # type: ignore

    def get_share_point_site_usage_page(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointSiteUsagePages"]
        """Invoke function getSharePointSiteUsagePages.

        Invoke function getSharePointSiteUsagePages.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointSiteUsagePages, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointSiteUsagePages]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointSiteUsagePages"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_site_usage_page.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointSiteUsagePages]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_page.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsagePages(period={period})'}  # type: ignore

    def get_share_point_site_usage_site_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSharePointSiteUsageSiteCounts"]
        """Invoke function getSharePointSiteUsageSiteCounts.

        Invoke function getSharePointSiteUsageSiteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSharePointSiteUsageSiteCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSharePointSiteUsageSiteCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSharePointSiteUsageSiteCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_site_usage_site_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSharePointSiteUsageSiteCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_site_count.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageSiteCounts(period={period})'}  # type: ignore

    def get_share_point_site_usage_storage(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSiteUsageStorage"]
        """Invoke function getSharePointSiteUsageStorage.

        Invoke function getSharePointSiteUsageStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSiteUsageStorage, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSiteUsageStorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSiteUsageStorage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_share_point_site_usage_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSiteUsageStorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_storage.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageStorage(period={period})'}  # type: ignore

    def get_skype_for_business_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessActivityCounts"]
        """Invoke function getSkypeForBusinessActivityCounts.

        Invoke function getSkypeForBusinessActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityCounts(period={period})'}  # type: ignore

    def get_skype_for_business_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessActivityUserCounts"]
        """Invoke function getSkypeForBusinessActivityUserCounts.

        Invoke function getSkypeForBusinessActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessActivityUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessActivityUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessActivityUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessActivityUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityUserCounts(period={period})'}  # type: ignore

    def get_skype_for_business_activity_user_detail_e4_c9(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessActivityUserDetail"]
        """Invoke function getSkypeForBusinessActivityUserDetail.

        Invoke function getSkypeForBusinessActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_activity_user_detail_e4_c9.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_user_detail_e4_c9.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityUserDetail(date={date})'}  # type: ignore

    def get_skype_for_business_activity_user_detail744_e(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessActivityUserDetail"]
        """Invoke function getSkypeForBusinessActivityUserDetail.

        Invoke function getSkypeForBusinessActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_activity_user_detail744_e.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_user_detail744_e.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityUserDetail(period={period})'}  # type: ignore

    def get_skype_for_business_device_usage_distribution_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessDeviceUsageDistributionUserCounts"]
        """Invoke function getSkypeForBusinessDeviceUsageDistributionUserCounts.

        Invoke function getSkypeForBusinessDeviceUsageDistributionUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessDeviceUsageDistributionUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessDeviceUsageDistributionUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessDeviceUsageDistributionUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_device_usage_distribution_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessDeviceUsageDistributionUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_distribution_user_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageDistributionUserCounts(period={period})'}  # type: ignore

    def get_skype_for_business_device_usage_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessDeviceUsageUserCounts"]
        """Invoke function getSkypeForBusinessDeviceUsageUserCounts.

        Invoke function getSkypeForBusinessDeviceUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessDeviceUsageUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessDeviceUsageUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessDeviceUsageUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_device_usage_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessDeviceUsageUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_user_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageUserCounts(period={period})'}  # type: ignore

    def get_skype_for_business_device_usage_user_detail_a692(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail"]
        """Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_device_usage_user_detail_a692.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_user_detail_a692.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageUserDetail(date={date})'}  # type: ignore

    def get_skype_for_business_device_usage_user_detail_e753(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail"]
        """Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_device_usage_user_detail_e753.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessDeviceUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_user_detail_e753.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageUserDetail(period={period})'}  # type: ignore

    def get_skype_for_business_organizer_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessOrganizerActivityCounts"]
        """Invoke function getSkypeForBusinessOrganizerActivityCounts.

        Invoke function getSkypeForBusinessOrganizerActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessOrganizerActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessOrganizerActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessOrganizerActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_organizer_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessOrganizerActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_organizer_activity_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessOrganizerActivityCounts(period={period})'}  # type: ignore

    def get_skype_for_business_organizer_activity_minute_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessOrganizerActivityMinuteCounts"]
        """Invoke function getSkypeForBusinessOrganizerActivityMinuteCounts.

        Invoke function getSkypeForBusinessOrganizerActivityMinuteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessOrganizerActivityMinuteCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessOrganizerActivityMinuteCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessOrganizerActivityMinuteCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_organizer_activity_minute_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessOrganizerActivityMinuteCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_organizer_activity_minute_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessOrganizerActivityMinuteCounts(period={period})'}  # type: ignore

    def get_skype_for_business_organizer_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessOrganizerActivityUserCounts"]
        """Invoke function getSkypeForBusinessOrganizerActivityUserCounts.

        Invoke function getSkypeForBusinessOrganizerActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessOrganizerActivityUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessOrganizerActivityUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessOrganizerActivityUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_organizer_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessOrganizerActivityUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_organizer_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessOrganizerActivityUserCounts(period={period})'}  # type: ignore

    def get_skype_for_business_participant_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessParticipantActivityCounts"]
        """Invoke function getSkypeForBusinessParticipantActivityCounts.

        Invoke function getSkypeForBusinessParticipantActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessParticipantActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessParticipantActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessParticipantActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_participant_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessParticipantActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_participant_activity_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessParticipantActivityCounts(period={period})'}  # type: ignore

    def get_skype_for_business_participant_activity_minute_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessParticipantActivityMinuteCounts"]
        """Invoke function getSkypeForBusinessParticipantActivityMinuteCounts.

        Invoke function getSkypeForBusinessParticipantActivityMinuteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessParticipantActivityMinuteCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessParticipantActivityMinuteCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessParticipantActivityMinuteCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_participant_activity_minute_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessParticipantActivityMinuteCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_participant_activity_minute_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessParticipantActivityMinuteCounts(period={period})'}  # type: ignore

    def get_skype_for_business_participant_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessParticipantActivityUserCounts"]
        """Invoke function getSkypeForBusinessParticipantActivityUserCounts.

        Invoke function getSkypeForBusinessParticipantActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessParticipantActivityUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessParticipantActivityUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessParticipantActivityUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_participant_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessParticipantActivityUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_participant_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessParticipantActivityUserCounts(period={period})'}  # type: ignore

    def get_skype_for_business_peer_to_peer_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityCounts"]
        """Invoke function getSkypeForBusinessPeerToPeerActivityCounts.

        Invoke function getSkypeForBusinessPeerToPeerActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessPeerToPeerActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_peer_to_peer_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessPeerToPeerActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_peer_to_peer_activity_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessPeerToPeerActivityCounts(period={period})'}  # type: ignore

    def get_skype_for_business_peer_to_peer_activity_minute_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityMinuteCounts"]
        """Invoke function getSkypeForBusinessPeerToPeerActivityMinuteCounts.

        Invoke function getSkypeForBusinessPeerToPeerActivityMinuteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessPeerToPeerActivityMinuteCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityMinuteCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityMinuteCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_peer_to_peer_activity_minute_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessPeerToPeerActivityMinuteCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_peer_to_peer_activity_minute_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessPeerToPeerActivityMinuteCounts(period={period})'}  # type: ignore

    def get_skype_for_business_peer_to_peer_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityUserCounts"]
        """Invoke function getSkypeForBusinessPeerToPeerActivityUserCounts.

        Invoke function getSkypeForBusinessPeerToPeerActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphSkypeForBusinessPeerToPeerActivityUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphSkypeForBusinessPeerToPeerActivityUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_skype_for_business_peer_to_peer_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphSkypeForBusinessPeerToPeerActivityUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_peer_to_peer_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessPeerToPeerActivityUserCounts(period={period})'}  # type: ignore

    def get_team_device_usage_distribution_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsDeviceUsageDistributionUserCounts"]
        """Invoke function getTeamsDeviceUsageDistributionUserCounts.

        Invoke function getTeamsDeviceUsageDistributionUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsDeviceUsageDistributionUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsDeviceUsageDistributionUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsDeviceUsageDistributionUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_device_usage_distribution_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsDeviceUsageDistributionUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_device_usage_distribution_user_count.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageDistributionUserCounts(period={period})'}  # type: ignore

    def get_team_device_usage_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsDeviceUsageUserCounts"]
        """Invoke function getTeamsDeviceUsageUserCounts.

        Invoke function getTeamsDeviceUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsDeviceUsageUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsDeviceUsageUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsDeviceUsageUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_device_usage_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsDeviceUsageUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_device_usage_user_count.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageUserCounts(period={period})'}  # type: ignore

    def get_team_device_usage_user_detail7148(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsDeviceUsageUserDetail"]
        """Invoke function getTeamsDeviceUsageUserDetail.

        Invoke function getTeamsDeviceUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsDeviceUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsDeviceUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsDeviceUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_device_usage_user_detail7148.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsDeviceUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_device_usage_user_detail7148.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageUserDetail(date={date})'}  # type: ignore

    def get_team_device_usage_user_detail7565(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsDeviceUsageUserDetail"]
        """Invoke function getTeamsDeviceUsageUserDetail.

        Invoke function getTeamsDeviceUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsDeviceUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsDeviceUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsDeviceUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_device_usage_user_detail7565.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsDeviceUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_device_usage_user_detail7565.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageUserDetail(period={period})'}  # type: ignore

    def get_team_user_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsUserActivityCounts"]
        """Invoke function getTeamsUserActivityCounts.

        Invoke function getTeamsUserActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsUserActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsUserActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsUserActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_user_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsUserActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_user_activity_count.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityCounts(period={period})'}  # type: ignore

    def get_team_user_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsUserActivityUserCounts"]
        """Invoke function getTeamsUserActivityUserCounts.

        Invoke function getTeamsUserActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsUserActivityUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsUserActivityUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsUserActivityUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_user_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsUserActivityUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_user_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityUserCounts(period={period})'}  # type: ignore

    def get_team_user_activity_user_detail_a3_f1(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsUserActivityUserDetail"]
        """Invoke function getTeamsUserActivityUserDetail.

        Invoke function getTeamsUserActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsUserActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsUserActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsUserActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_user_activity_user_detail_a3_f1.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsUserActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_user_activity_user_detail_a3_f1.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityUserDetail(date={date})'}  # type: ignore

    def get_team_user_activity_user_detail_eb13(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphTeamsUserActivityUserDetail"]
        """Invoke function getTeamsUserActivityUserDetail.

        Invoke function getTeamsUserActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphTeamsUserActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphTeamsUserActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphTeamsUserActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_team_user_activity_user_detail_eb13.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphTeamsUserActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_user_activity_user_detail_eb13.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityUserDetail(period={period})'}  # type: ignore

    def get_tenant_secure_score(
        self,
        period,  # type: int
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function getTenantSecureScores.

        Invoke function getTenantSecureScores.

        :param period:
        :type period: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_tenant_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'int', maximum=2147483647, minimum=-2147483648),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_tenant_secure_score.metadata = {'url': '/reports/microsoft.graph.getTenantSecureScores(period={period})'}  # type: ignore

    def get_yammer_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerActivitySummary"]
        """Invoke function getYammerActivityCounts.

        Invoke function getYammerActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_count.metadata = {'url': '/reports/microsoft.graph.getYammerActivityCounts(period={period})'}  # type: ignore

    def get_yammer_activity_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerActivitySummary"]
        """Invoke function getYammerActivityUserCounts.

        Invoke function getYammerActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerActivitySummary, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerActivitySummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerActivitySummary"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_activity_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerActivitySummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_user_count.metadata = {'url': '/reports/microsoft.graph.getYammerActivityUserCounts(period={period})'}  # type: ignore

    def get_yammer_activity_user_detail_ac30(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerActivityUserDetail"]
        """Invoke function getYammerActivityUserDetail.

        Invoke function getYammerActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_activity_user_detail_ac30.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_user_detail_ac30.metadata = {'url': '/reports/microsoft.graph.getYammerActivityUserDetail(date={date})'}  # type: ignore

    def get_yammer_activity_user_detail15_a5(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerActivityUserDetail"]
        """Invoke function getYammerActivityUserDetail.

        Invoke function getYammerActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerActivityUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerActivityUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerActivityUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_activity_user_detail15_a5.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerActivityUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_user_detail15_a5.metadata = {'url': '/reports/microsoft.graph.getYammerActivityUserDetail(period={period})'}  # type: ignore

    def get_yammer_device_usage_distribution_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerDeviceUsageDistributionUserCounts"]
        """Invoke function getYammerDeviceUsageDistributionUserCounts.

        Invoke function getYammerDeviceUsageDistributionUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerDeviceUsageDistributionUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerDeviceUsageDistributionUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerDeviceUsageDistributionUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_device_usage_distribution_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerDeviceUsageDistributionUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_distribution_user_count.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageDistributionUserCounts(period={period})'}  # type: ignore

    def get_yammer_device_usage_user_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerDeviceUsageUserCounts"]
        """Invoke function getYammerDeviceUsageUserCounts.

        Invoke function getYammerDeviceUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerDeviceUsageUserCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerDeviceUsageUserCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerDeviceUsageUserCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_device_usage_user_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerDeviceUsageUserCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_user_count.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageUserCounts(period={period})'}  # type: ignore

    def get_yammer_device_usage_user_detail_d0_ac(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerDeviceUsageUserDetail"]
        """Invoke function getYammerDeviceUsageUserDetail.

        Invoke function getYammerDeviceUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerDeviceUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerDeviceUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerDeviceUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_device_usage_user_detail_d0_ac.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerDeviceUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_user_detail_d0_ac.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageUserDetail(date={date})'}  # type: ignore

    def get_yammer_device_usage_user_detail_cfad(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerDeviceUsageUserDetail"]
        """Invoke function getYammerDeviceUsageUserDetail.

        Invoke function getYammerDeviceUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerDeviceUsageUserDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerDeviceUsageUserDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerDeviceUsageUserDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_device_usage_user_detail_cfad.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerDeviceUsageUserDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_user_detail_cfad.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageUserDetail(period={period})'}  # type: ignore

    def get_yammer_group_activity_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerGroupsActivityCounts"]
        """Invoke function getYammerGroupsActivityCounts.

        Invoke function getYammerGroupsActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerGroupsActivityCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerGroupsActivityCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerGroupsActivityCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_group_activity_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerGroupsActivityCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_group_activity_count.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityCounts(period={period})'}  # type: ignore

    def get_yammer_group_activity_detail_da9_a(
        self,
        date,  # type: datetime.date
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerGroupsActivityDetail"]
        """Invoke function getYammerGroupsActivityDetail.

        Invoke function getYammerGroupsActivityDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerGroupsActivityDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerGroupsActivityDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerGroupsActivityDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_group_activity_detail_da9_a.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerGroupsActivityDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_group_activity_detail_da9_a.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityDetail(date={date})'}  # type: ignore

    def get_yammer_group_activity_detail0_d7_d(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerGroupsActivityDetail"]
        """Invoke function getYammerGroupsActivityDetail.

        Invoke function getYammerGroupsActivityDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerGroupsActivityDetail, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerGroupsActivityDetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerGroupsActivityDetail"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_group_activity_detail0_d7_d.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerGroupsActivityDetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_group_activity_detail0_d7_d.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityDetail(period={period})'}  # type: ignore

    def get_yammer_group_activity_group_count(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> List["models.MicrosoftGraphYammerGroupsActivityGroupCounts"]
        """Invoke function getYammerGroupsActivityGroupCounts.

        Invoke function getYammerGroupsActivityGroupCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphYammerGroupsActivityGroupCounts, or the result of cls(response)
        :rtype: list[~reports.models.MicrosoftGraphYammerGroupsActivityGroupCounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphYammerGroupsActivityGroupCounts"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_yammer_group_activity_group_count.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphYammerGroupsActivityGroupCounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_group_activity_group_count.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityGroupCounts(period={period})'}  # type: ignore

    def managed_device_enrollment_abandonment_detail(
        self,
        skip,  # type: int
        top,  # type: int
        filter,  # type: str
        skip_token,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentAbandonmentDetails.

        Invoke function managedDeviceEnrollmentAbandonmentDetails.

        :param skip:
        :type skip: int
        :param top:
        :type top: int
        :param filter:
        :type filter: str
        :param skip_token:
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_abandonment_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'skip': self._serialize.url("skip", skip, 'int', maximum=2147483647, minimum=-2147483648),
            'top': self._serialize.url("top", top, 'int', maximum=2147483647, minimum=-2147483648),
            'filter': self._serialize.url("filter", filter, 'str'),
            'skipToken': self._serialize.url("skip_token", skip_token, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_abandonment_detail.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentAbandonmentDetails(skip={skip},top={top},filter={filter},skipToken={skipToken})'}  # type: ignore

    def managed_device_enrollment_abandonment_summary(
        self,
        skip,  # type: int
        top,  # type: int
        filter,  # type: str
        skip_token,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentAbandonmentSummary.

        Invoke function managedDeviceEnrollmentAbandonmentSummary.

        :param skip:
        :type skip: int
        :param top:
        :type top: int
        :param filter:
        :type filter: str
        :param skip_token:
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_abandonment_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'skip': self._serialize.url("skip", skip, 'int', maximum=2147483647, minimum=-2147483648),
            'top': self._serialize.url("top", top, 'int', maximum=2147483647, minimum=-2147483648),
            'filter': self._serialize.url("filter", filter, 'str'),
            'skipToken': self._serialize.url("skip_token", skip_token, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_abandonment_summary.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentAbandonmentSummary(skip={skip},top={top},filter={filter},skipToken={skipToken})'}  # type: ignore

    def managed_device_enrollment_failure_details027_e(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentFailureDetails.

        Invoke function managedDeviceEnrollmentFailureDetails.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_failure_details027_e.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_failure_details027_e.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentFailureDetails()'}  # type: ignore

    def managed_device_enrollment_failure_details2_b3_d(
        self,
        skip,  # type: int
        top,  # type: int
        filter,  # type: str
        skip_token,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentFailureDetails.

        Invoke function managedDeviceEnrollmentFailureDetails.

        :param skip:
        :type skip: int
        :param top:
        :type top: int
        :param filter:
        :type filter: str
        :param skip_token:
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_failure_details2_b3_d.metadata['url']  # type: ignore
        path_format_arguments = {
            'skip': self._serialize.url("skip", skip, 'int', maximum=2147483647, minimum=-2147483648),
            'top': self._serialize.url("top", top, 'int', maximum=2147483647, minimum=-2147483648),
            'filter': self._serialize.url("filter", filter, 'str'),
            'skipToken': self._serialize.url("skip_token", skip_token, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_failure_details2_b3_d.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentFailureDetails(skip={skip},top={top},filter={filter},skipToken={skipToken})'}  # type: ignore

    def managed_device_enrollment_failure_trend(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentFailureTrends.

        Invoke function managedDeviceEnrollmentFailureTrends.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_failure_trend.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_failure_trend.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentFailureTrends()'}  # type: ignore

    def managed_device_enrollment_top_failures4669(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentTopFailures.

        Invoke function managedDeviceEnrollmentTopFailures.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_top_failures4669.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_top_failures4669.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentTopFailures()'}  # type: ignore

    def managed_device_enrollment_top_failure_afd1(
        self,
        period,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphReport"
        """Invoke function managedDeviceEnrollmentTopFailures.

        Invoke function managedDeviceEnrollmentTopFailures.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphReport, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphReport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphReport"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.managed_device_enrollment_top_failure_afd1.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphReport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_top_failure_afd1.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentTopFailures(period={period})'}  # type: ignore

    def list_monthly_print_usage_summary_by_printer(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum20"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum21"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfPrintUsageSummaryByPrinter0"]
        """Get monthlyPrintUsageSummariesByPrinter from reports.

        Get monthlyPrintUsageSummariesByPrinter from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum20]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum21]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPrintUsageSummaryByPrinter0 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfPrintUsageSummaryByPrinter0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPrintUsageSummaryByPrinter0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_monthly_print_usage_summary_by_printer.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPrintUsageSummaryByPrinter0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_monthly_print_usage_summary_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter'}  # type: ignore

    def create_monthly_print_usage_summary_by_printer(
        self,
        id=None,  # type: Optional[str]
        printer_id=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByPrinter"
        """Create new navigation property to monthlyPrintUsageSummariesByPrinter for reports.

        Create new navigation property to monthlyPrintUsageSummariesByPrinter for reports.

        :param id: Read-only.
        :type id: str
        :param printer_id:
        :type printer_id: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByPrinter, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByPrinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByPrinter"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByPrinter(id=id, printer_id=printer_id, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_monthly_print_usage_summary_by_printer.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByPrinter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByPrinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_monthly_print_usage_summary_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter'}  # type: ignore

    def get_monthly_print_usage_summary_by_printer(
        self,
        print_usage_summary_by_printer_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum22"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByPrinter"
        """Get monthlyPrintUsageSummariesByPrinter from reports.

        Get monthlyPrintUsageSummariesByPrinter from reports.

        :param print_usage_summary_by_printer_id: key: PrintUsageSummaryByPrinter-id of
         PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum22]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByPrinter, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByPrinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByPrinter"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_monthly_print_usage_summary_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByPrinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_monthly_print_usage_summary_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    def update_monthly_print_usage_summary_by_printer(
        self,
        print_usage_summary_by_printer_id,  # type: str
        id=None,  # type: Optional[str]
        printer_id=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property monthlyPrintUsageSummariesByPrinter in reports.

        Update the navigation property monthlyPrintUsageSummariesByPrinter in reports.

        :param print_usage_summary_by_printer_id: key: PrintUsageSummaryByPrinter-id of
         PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param id: Read-only.
        :type id: str
        :param printer_id:
        :type printer_id: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByPrinter(id=id, printer_id=printer_id, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_monthly_print_usage_summary_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByPrinter')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_monthly_print_usage_summary_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    def list_monthly_print_usage_summary_by_user(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum23"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum24"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfPrintUsageSummaryByUser0"]
        """Get monthlyPrintUsageSummariesByUser from reports.

        Get monthlyPrintUsageSummariesByUser from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum23]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum24]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPrintUsageSummaryByUser0 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfPrintUsageSummaryByUser0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPrintUsageSummaryByUser0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_monthly_print_usage_summary_by_user.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPrintUsageSummaryByUser0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_monthly_print_usage_summary_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser'}  # type: ignore

    def create_monthly_print_usage_summary_by_user(
        self,
        id=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByUser"
        """Create new navigation property to monthlyPrintUsageSummariesByUser for reports.

        Create new navigation property to monthlyPrintUsageSummariesByUser for reports.

        :param id: Read-only.
        :type id: str
        :param user_principal_name:
        :type user_principal_name: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByUser, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByUser(id=id, user_principal_name=user_principal_name, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_monthly_print_usage_summary_by_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByUser')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_monthly_print_usage_summary_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser'}  # type: ignore

    def get_monthly_print_usage_summary_by_user(
        self,
        print_usage_summary_by_user_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum25"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrintUsageSummaryByUser"
        """Get monthlyPrintUsageSummariesByUser from reports.

        Get monthlyPrintUsageSummariesByUser from reports.

        :param print_usage_summary_by_user_id: key: PrintUsageSummaryByUser-id of
         PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrintUsageSummaryByUser, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphPrintUsageSummaryByUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrintUsageSummaryByUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_monthly_print_usage_summary_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrintUsageSummaryByUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_monthly_print_usage_summary_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    def update_monthly_print_usage_summary_by_user(
        self,
        print_usage_summary_by_user_id,  # type: str
        id=None,  # type: Optional[str]
        user_principal_name=None,  # type: Optional[str]
        usage_date=None,  # type: Optional[datetime.date]
        completed_black_and_white_job_count=None,  # type: Optional[int]
        completed_color_job_count=None,  # type: Optional[int]
        incomplete_job_count=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property monthlyPrintUsageSummariesByUser in reports.

        Update the navigation property monthlyPrintUsageSummariesByUser in reports.

        :param print_usage_summary_by_user_id: key: PrintUsageSummaryByUser-id of
         PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param id: Read-only.
        :type id: str
        :param user_principal_name:
        :type user_principal_name: str
        :param usage_date:
        :type usage_date: ~datetime.date
        :param completed_black_and_white_job_count:
        :type completed_black_and_white_job_count: long
        :param completed_color_job_count:
        :type completed_color_job_count: long
        :param incomplete_job_count:
        :type incomplete_job_count: long
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrintUsageSummaryByUser(id=id, user_principal_name=user_principal_name, usage_date=usage_date, completed_black_and_white_job_count=completed_black_and_white_job_count, completed_color_job_count=completed_color_job_count, incomplete_job_count=incomplete_job_count)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_monthly_print_usage_summary_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrintUsageSummaryByUser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_monthly_print_usage_summary_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    def list_user_credential_usage_detail(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum26"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum27"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfUserCredentialUsageDetails"]
        """Get userCredentialUsageDetails from reports.

        Get userCredentialUsageDetails from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum26]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum27]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfUserCredentialUsageDetails or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~reports.models.CollectionOfUserCredentialUsageDetails]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfUserCredentialUsageDetails"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_user_credential_usage_detail.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfUserCredentialUsageDetails', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_user_credential_usage_detail.metadata = {'url': '/reports/userCredentialUsageDetails'}  # type: ignore

    def create_user_credential_usage_detail(
        self,
        id=None,  # type: Optional[str]
        feature=None,  # type: Optional[Union[str, "models.MicrosoftGraphFeatureType"]]
        user_principal_name=None,  # type: Optional[str]
        user_display_name=None,  # type: Optional[str]
        is_success=None,  # type: Optional[bool]
        auth_method=None,  # type: Optional[Union[str, "models.MicrosoftGraphUsageAuthMethod"]]
        failure_reason=None,  # type: Optional[str]
        event_date_time=None,  # type: Optional[datetime.datetime]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphUserCredentialUsageDetails"
        """Create new navigation property to userCredentialUsageDetails for reports.

        Create new navigation property to userCredentialUsageDetails for reports.

        :param id: Read-only.
        :type id: str
        :param feature:
        :type feature: str or ~reports.models.MicrosoftGraphFeatureType
        :param user_principal_name:
        :type user_principal_name: str
        :param user_display_name:
        :type user_display_name: str
        :param is_success:
        :type is_success: bool
        :param auth_method:
        :type auth_method: str or ~reports.models.MicrosoftGraphUsageAuthMethod
        :param failure_reason:
        :type failure_reason: str
        :param event_date_time:
        :type event_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUserCredentialUsageDetails, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphUserCredentialUsageDetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUserCredentialUsageDetails"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphUserCredentialUsageDetails(id=id, feature=feature, user_principal_name=user_principal_name, user_display_name=user_display_name, is_success=is_success, auth_method=auth_method, failure_reason=failure_reason, event_date_time=event_date_time)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_user_credential_usage_detail.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphUserCredentialUsageDetails')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUserCredentialUsageDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_user_credential_usage_detail.metadata = {'url': '/reports/userCredentialUsageDetails'}  # type: ignore

    def get_user_credential_usage_detail(
        self,
        user_credential_usage_details_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum28"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphUserCredentialUsageDetails"
        """Get userCredentialUsageDetails from reports.

        Get userCredentialUsageDetails from reports.

        :param user_credential_usage_details_id: key: userCredentialUsageDetails-id of
         userCredentialUsageDetails.
        :type user_credential_usage_details_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum28]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUserCredentialUsageDetails, or the result of cls(response)
        :rtype: ~reports.models.MicrosoftGraphUserCredentialUsageDetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUserCredentialUsageDetails"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.get_user_credential_usage_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'userCredentialUsageDetails-id': self._serialize.url("user_credential_usage_details_id", user_credential_usage_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUserCredentialUsageDetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_credential_usage_detail.metadata = {'url': '/reports/userCredentialUsageDetails/{userCredentialUsageDetails-id}'}  # type: ignore

    def update_user_credential_usage_detail(
        self,
        user_credential_usage_details_id,  # type: str
        id=None,  # type: Optional[str]
        feature=None,  # type: Optional[Union[str, "models.MicrosoftGraphFeatureType"]]
        user_principal_name=None,  # type: Optional[str]
        user_display_name=None,  # type: Optional[str]
        is_success=None,  # type: Optional[bool]
        auth_method=None,  # type: Optional[Union[str, "models.MicrosoftGraphUsageAuthMethod"]]
        failure_reason=None,  # type: Optional[str]
        event_date_time=None,  # type: Optional[datetime.datetime]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property userCredentialUsageDetails in reports.

        Update the navigation property userCredentialUsageDetails in reports.

        :param user_credential_usage_details_id: key: userCredentialUsageDetails-id of
         userCredentialUsageDetails.
        :type user_credential_usage_details_id: str
        :param id: Read-only.
        :type id: str
        :param feature:
        :type feature: str or ~reports.models.MicrosoftGraphFeatureType
        :param user_principal_name:
        :type user_principal_name: str
        :param user_display_name:
        :type user_display_name: str
        :param is_success:
        :type is_success: bool
        :param auth_method:
        :type auth_method: str or ~reports.models.MicrosoftGraphUsageAuthMethod
        :param failure_reason:
        :type failure_reason: str
        :param event_date_time:
        :type event_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphUserCredentialUsageDetails(id=id, feature=feature, user_principal_name=user_principal_name, user_display_name=user_display_name, is_success=is_success, auth_method=auth_method, failure_reason=failure_reason, event_date_time=event_date_time)
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.update_user_credential_usage_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'userCredentialUsageDetails-id': self._serialize.url("user_credential_usage_details_id", user_credential_usage_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphUserCredentialUsageDetails')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_user_credential_usage_detail.metadata = {'url': '/reports/userCredentialUsageDetails/{userCredentialUsageDetails-id}'}  # type: ignore
