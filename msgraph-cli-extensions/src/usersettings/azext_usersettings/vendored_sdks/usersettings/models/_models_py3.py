# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
from typing import List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._users_user_settings_enums import *


class MicrosoftGraphEntity(msrest.serialization.Model):
    """entity.

    :param id: Read-only.
    :type id: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        **kwargs
    ):
        super(MicrosoftGraphEntity, self).__init__(**kwargs)
        self.id = id


class MicrosoftGraphChangeTrackedEntity(MicrosoftGraphEntity):
    """changeTrackedEntity.

    :param id: Read-only.
    :type id: str
    :param created_date_time:
    :type created_date_time: ~datetime.datetime
    :param last_modified_date_time:
    :type last_modified_date_time: ~datetime.datetime
    :param application: identity.
    :type application: ~users_user_settings.models.MicrosoftGraphIdentity
    :param device: identity.
    :type device: ~users_user_settings.models.MicrosoftGraphIdentity
    :param user: identity.
    :type user: ~users_user_settings.models.MicrosoftGraphIdentity
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'created_date_time': {'key': 'createdDateTime', 'type': 'iso-8601'},
        'last_modified_date_time': {'key': 'lastModifiedDateTime', 'type': 'iso-8601'},
        'application': {'key': 'lastModifiedBy.application', 'type': 'MicrosoftGraphIdentity'},
        'device': {'key': 'lastModifiedBy.device', 'type': 'MicrosoftGraphIdentity'},
        'user': {'key': 'lastModifiedBy.user', 'type': 'MicrosoftGraphIdentity'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        application: Optional["MicrosoftGraphIdentity"] = None,
        device: Optional["MicrosoftGraphIdentity"] = None,
        user: Optional["MicrosoftGraphIdentity"] = None,
        **kwargs
    ):
        super(MicrosoftGraphChangeTrackedEntity, self).__init__(id=id, **kwargs)
        self.created_date_time = created_date_time
        self.last_modified_date_time = last_modified_date_time
        self.application = application
        self.device = device
        self.user = user


class MicrosoftGraphIdentity(msrest.serialization.Model):
    """identity.

    :param id: Unique identifier for the identity.
    :type id: str
    :param display_name: The identity's display name. Note that this may not always be available or
     up to date. For example, if a user changes their display name, the API may show the new value
     in a future response, but the items associated with the user won't show up as having changed
     when using delta.
    :type display_name: str
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'display_name': {'key': 'displayName', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        **kwargs
    ):
        super(MicrosoftGraphIdentity, self).__init__(**kwargs)
        self.id = id
        self.display_name = display_name


class MicrosoftGraphPatternedRecurrence(msrest.serialization.Model):
    """patternedRecurrence.

    :param pattern: recurrencePattern.
    :type pattern: ~users_user_settings.models.MicrosoftGraphRecurrencePattern
    :param range: recurrenceRange.
    :type range: ~users_user_settings.models.MicrosoftGraphRecurrenceRange
    """

    _attribute_map = {
        'pattern': {'key': 'pattern', 'type': 'MicrosoftGraphRecurrencePattern'},
        'range': {'key': 'range', 'type': 'MicrosoftGraphRecurrenceRange'},
    }

    def __init__(
        self,
        *,
        pattern: Optional["MicrosoftGraphRecurrencePattern"] = None,
        range: Optional["MicrosoftGraphRecurrenceRange"] = None,
        **kwargs
    ):
        super(MicrosoftGraphPatternedRecurrence, self).__init__(**kwargs)
        self.pattern = pattern
        self.range = range


class MicrosoftGraphRecurrencePattern(msrest.serialization.Model):
    """recurrencePattern.

    :param type: recurrencePatternType. Possible values include: "daily", "weekly",
     "absoluteMonthly", "relativeMonthly", "absoluteYearly", "relativeYearly".
    :type type: str or ~users_user_settings.models.MicrosoftGraphRecurrencePatternType
    :param interval: The number of units between occurrences, where units can be in days, weeks,
     months, or years, depending on the type. Required.
    :type interval: int
    :param month: The month in which the event occurs.  This is a number from 1 to 12.
    :type month: int
    :param day_of_month: The day of the month on which the event occurs. Required if type is
     absoluteMonthly or absoluteYearly.
    :type day_of_month: int
    :param days_of_week: A collection of the days of the week on which the event occurs. The
     possible values are: sunday, monday, tuesday, wednesday, thursday, friday, saturday. If type is
     relativeMonthly or relativeYearly, and daysOfWeek specifies more than one day, the event falls
     on the first day that satisfies the pattern.  Required if type is weekly, relativeMonthly, or
     relativeYearly.
    :type days_of_week: list[str or ~users_user_settings.models.MicrosoftGraphDayOfWeek]
    :param first_day_of_week: dayOfWeek. Possible values include: "sunday", "monday", "tuesday",
     "wednesday", "thursday", "friday", "saturday".
    :type first_day_of_week: str or ~users_user_settings.models.MicrosoftGraphDayOfWeek
    :param index: weekIndex. Possible values include: "first", "second", "third", "fourth", "last".
    :type index: str or ~users_user_settings.models.MicrosoftGraphWeekIndex
    """

    _validation = {
        'interval': {'maximum': 2147483647, 'minimum': -2147483648},
        'month': {'maximum': 2147483647, 'minimum': -2147483648},
        'day_of_month': {'maximum': 2147483647, 'minimum': -2147483648},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'interval': {'key': 'interval', 'type': 'int'},
        'month': {'key': 'month', 'type': 'int'},
        'day_of_month': {'key': 'dayOfMonth', 'type': 'int'},
        'days_of_week': {'key': 'daysOfWeek', 'type': '[str]'},
        'first_day_of_week': {'key': 'firstDayOfWeek', 'type': 'str'},
        'index': {'key': 'index', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "MicrosoftGraphRecurrencePatternType"]] = None,
        interval: Optional[int] = None,
        month: Optional[int] = None,
        day_of_month: Optional[int] = None,
        days_of_week: Optional[List[Union[str, "MicrosoftGraphDayOfWeek"]]] = None,
        first_day_of_week: Optional[Union[str, "MicrosoftGraphDayOfWeek"]] = None,
        index: Optional[Union[str, "MicrosoftGraphWeekIndex"]] = None,
        **kwargs
    ):
        super(MicrosoftGraphRecurrencePattern, self).__init__(**kwargs)
        self.type = type
        self.interval = interval
        self.month = month
        self.day_of_month = day_of_month
        self.days_of_week = days_of_week
        self.first_day_of_week = first_day_of_week
        self.index = index


class MicrosoftGraphRecurrenceRange(msrest.serialization.Model):
    """recurrenceRange.

    :param type: recurrenceRangeType. Possible values include: "endDate", "noEnd", "numbered".
    :type type: str or ~users_user_settings.models.MicrosoftGraphRecurrenceRangeType
    :param start_date: The date to start applying the recurrence pattern. The first occurrence of
     the meeting may be this date or later, depending on the recurrence pattern of the event. Must
     be the same value as the start property of the recurring event. Required.
    :type start_date: ~datetime.date
    :param end_date: The date to stop applying the recurrence pattern. Depending on the recurrence
     pattern of the event, the last occurrence of the meeting may not be this date. Required if type
     is endDate.
    :type end_date: ~datetime.date
    :param recurrence_time_zone: Time zone for the startDate and endDate properties. Optional. If
     not specified, the time zone of the event is used.
    :type recurrence_time_zone: str
    :param number_of_occurrences: The number of times to repeat the event. Required and must be
     positive if type is numbered.
    :type number_of_occurrences: int
    """

    _validation = {
        'number_of_occurrences': {'maximum': 2147483647, 'minimum': -2147483648},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'start_date': {'key': 'startDate', 'type': 'date'},
        'end_date': {'key': 'endDate', 'type': 'date'},
        'recurrence_time_zone': {'key': 'recurrenceTimeZone', 'type': 'str'},
        'number_of_occurrences': {'key': 'numberOfOccurrences', 'type': 'int'},
    }

    def __init__(
        self,
        *,
        type: Optional[Union[str, "MicrosoftGraphRecurrenceRangeType"]] = None,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
        recurrence_time_zone: Optional[str] = None,
        number_of_occurrences: Optional[int] = None,
        **kwargs
    ):
        super(MicrosoftGraphRecurrenceRange, self).__init__(**kwargs)
        self.type = type
        self.start_date = start_date
        self.end_date = end_date
        self.recurrence_time_zone = recurrence_time_zone
        self.number_of_occurrences = number_of_occurrences


class MicrosoftGraphShiftAvailability(msrest.serialization.Model):
    """shiftAvailability.

    :param recurrence: patternedRecurrence.
    :type recurrence: ~users_user_settings.models.MicrosoftGraphPatternedRecurrence
    :param time_zone:
    :type time_zone: str
    :param time_slots:
    :type time_slots: list[~users_user_settings.models.MicrosoftGraphTimeRange]
    """

    _attribute_map = {
        'recurrence': {'key': 'recurrence', 'type': 'MicrosoftGraphPatternedRecurrence'},
        'time_zone': {'key': 'timeZone', 'type': 'str'},
        'time_slots': {'key': 'timeSlots', 'type': '[MicrosoftGraphTimeRange]'},
    }

    def __init__(
        self,
        *,
        recurrence: Optional["MicrosoftGraphPatternedRecurrence"] = None,
        time_zone: Optional[str] = None,
        time_slots: Optional[List["MicrosoftGraphTimeRange"]] = None,
        **kwargs
    ):
        super(MicrosoftGraphShiftAvailability, self).__init__(**kwargs)
        self.recurrence = recurrence
        self.time_zone = time_zone
        self.time_slots = time_slots


class MicrosoftGraphShiftPreferences(MicrosoftGraphChangeTrackedEntity):
    """shiftPreferences.

    :param id: Read-only.
    :type id: str
    :param created_date_time:
    :type created_date_time: ~datetime.datetime
    :param last_modified_date_time:
    :type last_modified_date_time: ~datetime.datetime
    :param application: identity.
    :type application: ~users_user_settings.models.MicrosoftGraphIdentity
    :param device: identity.
    :type device: ~users_user_settings.models.MicrosoftGraphIdentity
    :param user: identity.
    :type user: ~users_user_settings.models.MicrosoftGraphIdentity
    :param availability:
    :type availability: list[~users_user_settings.models.MicrosoftGraphShiftAvailability]
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'created_date_time': {'key': 'createdDateTime', 'type': 'iso-8601'},
        'last_modified_date_time': {'key': 'lastModifiedDateTime', 'type': 'iso-8601'},
        'application': {'key': 'lastModifiedBy.application', 'type': 'MicrosoftGraphIdentity'},
        'device': {'key': 'lastModifiedBy.device', 'type': 'MicrosoftGraphIdentity'},
        'user': {'key': 'lastModifiedBy.user', 'type': 'MicrosoftGraphIdentity'},
        'availability': {'key': 'availability', 'type': '[MicrosoftGraphShiftAvailability]'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        application: Optional["MicrosoftGraphIdentity"] = None,
        device: Optional["MicrosoftGraphIdentity"] = None,
        user: Optional["MicrosoftGraphIdentity"] = None,
        availability: Optional[List["MicrosoftGraphShiftAvailability"]] = None,
        **kwargs
    ):
        super(MicrosoftGraphShiftPreferences, self).__init__(id=id, created_date_time=created_date_time, last_modified_date_time=last_modified_date_time, application=application, device=device, user=user, **kwargs)
        self.availability = availability


class MicrosoftGraphTimeRange(msrest.serialization.Model):
    """timeRange.

    :param start_time:
    :type start_time: ~datetime.time
    :param end_time:
    :type end_time: ~datetime.time
    """

    _attribute_map = {
        'start_time': {'key': 'startTime', 'type': 'time'},
        'end_time': {'key': 'endTime', 'type': 'time'},
    }

    def __init__(
        self,
        *,
        start_time: Optional[datetime.time] = None,
        end_time: Optional[datetime.time] = None,
        **kwargs
    ):
        super(MicrosoftGraphTimeRange, self).__init__(**kwargs)
        self.start_time = start_time
        self.end_time = end_time


class MicrosoftGraphUserSettings(MicrosoftGraphEntity):
    """userSettings.

    :param id: Read-only.
    :type id: str
    :param contribution_to_content_discovery_disabled:
    :type contribution_to_content_discovery_disabled: bool
    :param contribution_to_content_discovery_as_organization_disabled:
    :type contribution_to_content_discovery_as_organization_disabled: bool
    :param id_shift_preferences_id: Read-only.
    :type id_shift_preferences_id: str
    :param created_date_time:
    :type created_date_time: ~datetime.datetime
    :param last_modified_date_time:
    :type last_modified_date_time: ~datetime.datetime
    :param application: identity.
    :type application: ~users_user_settings.models.MicrosoftGraphIdentity
    :param device: identity.
    :type device: ~users_user_settings.models.MicrosoftGraphIdentity
    :param user: identity.
    :type user: ~users_user_settings.models.MicrosoftGraphIdentity
    :param availability:
    :type availability: list[~users_user_settings.models.MicrosoftGraphShiftAvailability]
    """

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'contribution_to_content_discovery_disabled': {'key': 'contributionToContentDiscoveryDisabled', 'type': 'bool'},
        'contribution_to_content_discovery_as_organization_disabled': {'key': 'contributionToContentDiscoveryAsOrganizationDisabled', 'type': 'bool'},
        'id_shift_preferences_id': {'key': 'shiftPreferences.id', 'type': 'str'},
        'created_date_time': {'key': 'shiftPreferences.createdDateTime', 'type': 'iso-8601'},
        'last_modified_date_time': {'key': 'shiftPreferences.lastModifiedDateTime', 'type': 'iso-8601'},
        'application': {'key': 'shiftPreferences.lastModifiedBy.application', 'type': 'MicrosoftGraphIdentity'},
        'device': {'key': 'shiftPreferences.lastModifiedBy.device', 'type': 'MicrosoftGraphIdentity'},
        'user': {'key': 'shiftPreferences.lastModifiedBy.user', 'type': 'MicrosoftGraphIdentity'},
        'availability': {'key': 'shiftPreferences.availability', 'type': '[MicrosoftGraphShiftAvailability]'},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,
        contribution_to_content_discovery_disabled: Optional[bool] = None,
        contribution_to_content_discovery_as_organization_disabled: Optional[bool] = None,
        id_shift_preferences_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        application: Optional["MicrosoftGraphIdentity"] = None,
        device: Optional["MicrosoftGraphIdentity"] = None,
        user: Optional["MicrosoftGraphIdentity"] = None,
        availability: Optional[List["MicrosoftGraphShiftAvailability"]] = None,
        **kwargs
    ):
        super(MicrosoftGraphUserSettings, self).__init__(id=id, **kwargs)
        self.contribution_to_content_discovery_disabled = contribution_to_content_discovery_disabled
        self.contribution_to_content_discovery_as_organization_disabled = contribution_to_content_discovery_as_organization_disabled
        self.id_shift_preferences_id = id_shift_preferences_id
        self.created_date_time = created_date_time
        self.last_modified_date_time = last_modified_date_time
        self.application = application
        self.device = device
        self.user = user
        self.availability = availability


class OdataError(msrest.serialization.Model):
    """OdataError.

    All required parameters must be populated in order to send to Azure.

    :param error: Required.
    :type error: ~users_user_settings.models.OdataErrorMain
    """

    _validation = {
        'error': {'required': True},
    }

    _attribute_map = {
        'error': {'key': 'error', 'type': 'OdataErrorMain'},
    }

    def __init__(
        self,
        *,
        error: "OdataErrorMain",
        **kwargs
    ):
        super(OdataError, self).__init__(**kwargs)
        self.error = error


class OdataErrorDetail(msrest.serialization.Model):
    """OdataErrorDetail.

    All required parameters must be populated in order to send to Azure.

    :param code: Required.
    :type code: str
    :param message: Required.
    :type message: str
    :param target:
    :type target: str
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        **kwargs
    ):
        super(OdataErrorDetail, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target


class OdataErrorMain(msrest.serialization.Model):
    """OdataErrorMain.

    All required parameters must be populated in order to send to Azure.

    :param code: Required.
    :type code: str
    :param message: Required.
    :type message: str
    :param target:
    :type target: str
    :param details:
    :type details: list[~users_user_settings.models.OdataErrorDetail]
    :param innererror: The structure of this object is service-specific.
    :type innererror: object
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[OdataErrorDetail]'},
        'innererror': {'key': 'innererror', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        code: str,
        message: str,
        target: Optional[str] = None,
        details: Optional[List["OdataErrorDetail"]] = None,
        innererror: Optional[object] = None,
        **kwargs
    ):
        super(OdataErrorMain, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details
        self.innererror = innererror
