# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class FinancialCompanyOperations:
    """FinancialCompanyOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~financials.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_account(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum6"]]] = None,
        select: Optional[List[Union[str, "models.Enum7"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAccount"]:
        """Get accounts from financials.

        Get accounts from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum6]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum7]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAccount or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfAccount]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAccount"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_account.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAccount', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_account.metadata = {'url': '/financials/companies/{company-id}/accounts'}  # type: ignore

    async def create_account(
        self,
        company_id: str,
        id: Optional[str] = None,
        blocked: Optional[bool] = None,
        category: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        sub_category: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAccount":
        """Create new navigation property to accounts for financials.

        Create new navigation property to accounts for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param blocked:
        :type blocked: bool
        :param category:
        :type category: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param sub_category:
        :type sub_category: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAccount, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphAccount
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAccount"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAccount(id=id, blocked=blocked, category=category, display_name=display_name, last_modified_date_time=last_modified_date_time, number=number, sub_category=sub_category)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAccount')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAccount', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_account.metadata = {'url': '/financials/companies/{company-id}/accounts'}  # type: ignore

    async def get_account(
        self,
        company_id: str,
        account_id: str,
        select: Optional[List[Union[str, "models.Enum8"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAccount":
        """Get accounts from financials.

        Get accounts from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param account_id: key: id of account.
        :type account_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum8]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAccount, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphAccount
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAccount"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'account-id': self._serialize.url("account_id", account_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAccount', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_account.metadata = {'url': '/financials/companies/{company-id}/accounts/{account-id}'}  # type: ignore

    async def update_account(
        self,
        company_id: str,
        account_id: str,
        id: Optional[str] = None,
        blocked: Optional[bool] = None,
        category: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        sub_category: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property accounts in financials.

        Update the navigation property accounts in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param account_id: key: id of account.
        :type account_id: str
        :param id: Read-only.
        :type id: str
        :param blocked:
        :type blocked: bool
        :param category:
        :type category: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param sub_category:
        :type sub_category: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAccount(id=id, blocked=blocked, category=category, display_name=display_name, last_modified_date_time=last_modified_date_time, number=number, sub_category=sub_category)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'account-id': self._serialize.url("account_id", account_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAccount')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_account.metadata = {'url': '/financials/companies/{company-id}/accounts/{account-id}'}  # type: ignore

    async def delete_account(
        self,
        company_id: str,
        account_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property accounts for financials.

        Delete navigation property accounts for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param account_id: key: id of account.
        :type account_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'account-id': self._serialize.url("account_id", account_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_account.metadata = {'url': '/financials/companies/{company-id}/accounts/{account-id}'}  # type: ignore

    def list_aged_account_payable(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum9"]]] = None,
        select: Optional[List[Union[str, "models.Enum10"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAgedAccountsPayable"]:
        """Get agedAccountsPayable from financials.

        Get agedAccountsPayable from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum9]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum10]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAgedAccountsPayable or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfAgedAccountsPayable]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAgedAccountsPayable"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_aged_account_payable.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAgedAccountsPayable', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_aged_account_payable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsPayable'}  # type: ignore

    async def create_aged_account_payable(
        self,
        company_id: str,
        id: Optional[str] = None,
        aged_as_of_date: Optional[datetime.date] = None,
        balance_due: Optional[float] = None,
        currency_code: Optional[str] = None,
        current_amount: Optional[float] = None,
        name: Optional[str] = None,
        period1_amount: Optional[float] = None,
        period2_amount: Optional[float] = None,
        period3_amount: Optional[float] = None,
        period_length_filter: Optional[str] = None,
        vendor_number: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAgedAccountsPayable":
        """Create new navigation property to agedAccountsPayable for financials.

        Create new navigation property to agedAccountsPayable for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param aged_as_of_date:
        :type aged_as_of_date: ~datetime.date
        :param balance_due:
        :type balance_due: float
        :param currency_code:
        :type currency_code: str
        :param current_amount:
        :type current_amount: float
        :param name:
        :type name: str
        :param period1_amount:
        :type period1_amount: float
        :param period2_amount:
        :type period2_amount: float
        :param period3_amount:
        :type period3_amount: float
        :param period_length_filter:
        :type period_length_filter: str
        :param vendor_number:
        :type vendor_number: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAgedAccountsPayable, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphAgedAccountsPayable
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAgedAccountsPayable"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAgedAccountsPayable(id=id, aged_as_of_date=aged_as_of_date, balance_due=balance_due, currency_code=currency_code, current_amount=current_amount, name=name, period1_amount=period1_amount, period2_amount=period2_amount, period3_amount=period3_amount, period_length_filter=period_length_filter, vendor_number=vendor_number)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_aged_account_payable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAgedAccountsPayable')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAgedAccountsPayable', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_aged_account_payable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsPayable'}  # type: ignore

    async def get_aged_account_payable(
        self,
        company_id: str,
        aged_accounts_payable_id: str,
        select: Optional[List[Union[str, "models.Enum11"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAgedAccountsPayable":
        """Get agedAccountsPayable from financials.

        Get agedAccountsPayable from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param aged_accounts_payable_id: key: id of agedAccountsPayable.
        :type aged_accounts_payable_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum11]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAgedAccountsPayable, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphAgedAccountsPayable
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAgedAccountsPayable"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_aged_account_payable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'agedAccountsPayable-id': self._serialize.url("aged_accounts_payable_id", aged_accounts_payable_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAgedAccountsPayable', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_aged_account_payable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsPayable/{agedAccountsPayable-id}'}  # type: ignore

    async def update_aged_account_payable(
        self,
        company_id: str,
        aged_accounts_payable_id: str,
        id: Optional[str] = None,
        aged_as_of_date: Optional[datetime.date] = None,
        balance_due: Optional[float] = None,
        currency_code: Optional[str] = None,
        current_amount: Optional[float] = None,
        name: Optional[str] = None,
        period1_amount: Optional[float] = None,
        period2_amount: Optional[float] = None,
        period3_amount: Optional[float] = None,
        period_length_filter: Optional[str] = None,
        vendor_number: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property agedAccountsPayable in financials.

        Update the navigation property agedAccountsPayable in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param aged_accounts_payable_id: key: id of agedAccountsPayable.
        :type aged_accounts_payable_id: str
        :param id: Read-only.
        :type id: str
        :param aged_as_of_date:
        :type aged_as_of_date: ~datetime.date
        :param balance_due:
        :type balance_due: float
        :param currency_code:
        :type currency_code: str
        :param current_amount:
        :type current_amount: float
        :param name:
        :type name: str
        :param period1_amount:
        :type period1_amount: float
        :param period2_amount:
        :type period2_amount: float
        :param period3_amount:
        :type period3_amount: float
        :param period_length_filter:
        :type period_length_filter: str
        :param vendor_number:
        :type vendor_number: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAgedAccountsPayable(id=id, aged_as_of_date=aged_as_of_date, balance_due=balance_due, currency_code=currency_code, current_amount=current_amount, name=name, period1_amount=period1_amount, period2_amount=period2_amount, period3_amount=period3_amount, period_length_filter=period_length_filter, vendor_number=vendor_number)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_aged_account_payable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'agedAccountsPayable-id': self._serialize.url("aged_accounts_payable_id", aged_accounts_payable_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAgedAccountsPayable')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_aged_account_payable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsPayable/{agedAccountsPayable-id}'}  # type: ignore

    async def delete_aged_account_payable(
        self,
        company_id: str,
        aged_accounts_payable_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property agedAccountsPayable for financials.

        Delete navigation property agedAccountsPayable for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param aged_accounts_payable_id: key: id of agedAccountsPayable.
        :type aged_accounts_payable_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_aged_account_payable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'agedAccountsPayable-id': self._serialize.url("aged_accounts_payable_id", aged_accounts_payable_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_aged_account_payable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsPayable/{agedAccountsPayable-id}'}  # type: ignore

    def list_aged_account_receivable(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum12"]]] = None,
        select: Optional[List[Union[str, "models.Enum13"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAgedAccountsReceivable"]:
        """Get agedAccountsReceivable from financials.

        Get agedAccountsReceivable from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum12]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum13]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAgedAccountsReceivable or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfAgedAccountsReceivable]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAgedAccountsReceivable"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_aged_account_receivable.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAgedAccountsReceivable', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_aged_account_receivable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsReceivable'}  # type: ignore

    async def create_aged_account_receivable(
        self,
        company_id: str,
        id: Optional[str] = None,
        aged_as_of_date: Optional[datetime.date] = None,
        balance_due: Optional[float] = None,
        currency_code: Optional[str] = None,
        current_amount: Optional[float] = None,
        customer_number: Optional[str] = None,
        name: Optional[str] = None,
        period1_amount: Optional[float] = None,
        period2_amount: Optional[float] = None,
        period3_amount: Optional[float] = None,
        period_length_filter: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAgedAccountsReceivable":
        """Create new navigation property to agedAccountsReceivable for financials.

        Create new navigation property to agedAccountsReceivable for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param aged_as_of_date:
        :type aged_as_of_date: ~datetime.date
        :param balance_due:
        :type balance_due: float
        :param currency_code:
        :type currency_code: str
        :param current_amount:
        :type current_amount: float
        :param customer_number:
        :type customer_number: str
        :param name:
        :type name: str
        :param period1_amount:
        :type period1_amount: float
        :param period2_amount:
        :type period2_amount: float
        :param period3_amount:
        :type period3_amount: float
        :param period_length_filter:
        :type period_length_filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAgedAccountsReceivable, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphAgedAccountsReceivable
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAgedAccountsReceivable"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAgedAccountsReceivable(id=id, aged_as_of_date=aged_as_of_date, balance_due=balance_due, currency_code=currency_code, current_amount=current_amount, customer_number=customer_number, name=name, period1_amount=period1_amount, period2_amount=period2_amount, period3_amount=period3_amount, period_length_filter=period_length_filter)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_aged_account_receivable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAgedAccountsReceivable')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAgedAccountsReceivable', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_aged_account_receivable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsReceivable'}  # type: ignore

    async def get_aged_account_receivable(
        self,
        company_id: str,
        aged_accounts_receivable_id: str,
        select: Optional[List[Union[str, "models.Enum14"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAgedAccountsReceivable":
        """Get agedAccountsReceivable from financials.

        Get agedAccountsReceivable from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param aged_accounts_receivable_id: key: id of agedAccountsReceivable.
        :type aged_accounts_receivable_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum14]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAgedAccountsReceivable, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphAgedAccountsReceivable
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAgedAccountsReceivable"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_aged_account_receivable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'agedAccountsReceivable-id': self._serialize.url("aged_accounts_receivable_id", aged_accounts_receivable_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAgedAccountsReceivable', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_aged_account_receivable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsReceivable/{agedAccountsReceivable-id}'}  # type: ignore

    async def update_aged_account_receivable(
        self,
        company_id: str,
        aged_accounts_receivable_id: str,
        id: Optional[str] = None,
        aged_as_of_date: Optional[datetime.date] = None,
        balance_due: Optional[float] = None,
        currency_code: Optional[str] = None,
        current_amount: Optional[float] = None,
        customer_number: Optional[str] = None,
        name: Optional[str] = None,
        period1_amount: Optional[float] = None,
        period2_amount: Optional[float] = None,
        period3_amount: Optional[float] = None,
        period_length_filter: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property agedAccountsReceivable in financials.

        Update the navigation property agedAccountsReceivable in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param aged_accounts_receivable_id: key: id of agedAccountsReceivable.
        :type aged_accounts_receivable_id: str
        :param id: Read-only.
        :type id: str
        :param aged_as_of_date:
        :type aged_as_of_date: ~datetime.date
        :param balance_due:
        :type balance_due: float
        :param currency_code:
        :type currency_code: str
        :param current_amount:
        :type current_amount: float
        :param customer_number:
        :type customer_number: str
        :param name:
        :type name: str
        :param period1_amount:
        :type period1_amount: float
        :param period2_amount:
        :type period2_amount: float
        :param period3_amount:
        :type period3_amount: float
        :param period_length_filter:
        :type period_length_filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAgedAccountsReceivable(id=id, aged_as_of_date=aged_as_of_date, balance_due=balance_due, currency_code=currency_code, current_amount=current_amount, customer_number=customer_number, name=name, period1_amount=period1_amount, period2_amount=period2_amount, period3_amount=period3_amount, period_length_filter=period_length_filter)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_aged_account_receivable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'agedAccountsReceivable-id': self._serialize.url("aged_accounts_receivable_id", aged_accounts_receivable_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAgedAccountsReceivable')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_aged_account_receivable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsReceivable/{agedAccountsReceivable-id}'}  # type: ignore

    async def delete_aged_account_receivable(
        self,
        company_id: str,
        aged_accounts_receivable_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property agedAccountsReceivable for financials.

        Delete navigation property agedAccountsReceivable for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param aged_accounts_receivable_id: key: id of agedAccountsReceivable.
        :type aged_accounts_receivable_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_aged_account_receivable.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'agedAccountsReceivable-id': self._serialize.url("aged_accounts_receivable_id", aged_accounts_receivable_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_aged_account_receivable.metadata = {'url': '/financials/companies/{company-id}/agedAccountsReceivable/{agedAccountsReceivable-id}'}  # type: ignore

    def list_company_information(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum15"]]] = None,
        select: Optional[List[Union[str, "models.Enum16"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCompanyInformation"]:
        """Get companyInformation from financials.

        Get companyInformation from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum15]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum16]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCompanyInformation or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfCompanyInformation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCompanyInformation"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_company_information.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCompanyInformation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_company_information.metadata = {'url': '/financials/companies/{company-id}/companyInformation'}  # type: ignore

    async def create_company_information(
        self,
        company_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        currency_code: Optional[str] = None,
        current_fiscal_year_start_date: Optional[datetime.date] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        fax_number: Optional[str] = None,
        industry: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        phone_number: Optional[str] = None,
        picture: Optional[bytes] = None,
        tax_registration_number: Optional[str] = None,
        website: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCompanyInformation":
        """Create new navigation property to companyInformation for financials.

        Create new navigation property to companyInformation for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param currency_code:
        :type currency_code: str
        :param current_fiscal_year_start_date:
        :type current_fiscal_year_start_date: ~datetime.date
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param fax_number:
        :type fax_number: str
        :param industry:
        :type industry: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param phone_number:
        :type phone_number: str
        :param picture:
        :type picture: bytes
        :param tax_registration_number:
        :type tax_registration_number: str
        :param website:
        :type website: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCompanyInformation, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCompanyInformation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCompanyInformation"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCompanyInformation(id=id, address=address, currency_code=currency_code, current_fiscal_year_start_date=current_fiscal_year_start_date, display_name=display_name, email=email, fax_number=fax_number, industry=industry, last_modified_date_time=last_modified_date_time, phone_number=phone_number, picture=picture, tax_registration_number=tax_registration_number, website=website)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_company_information.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCompanyInformation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCompanyInformation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_company_information.metadata = {'url': '/financials/companies/{company-id}/companyInformation'}  # type: ignore

    async def get_company_information(
        self,
        company_id: str,
        company_information_id: str,
        select: Optional[List[Union[str, "models.Enum17"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCompanyInformation":
        """Get companyInformation from financials.

        Get companyInformation from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param company_information_id: key: id of companyInformation.
        :type company_information_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum17]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCompanyInformation, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCompanyInformation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCompanyInformation"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_company_information.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'companyInformation-id': self._serialize.url("company_information_id", company_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCompanyInformation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_company_information.metadata = {'url': '/financials/companies/{company-id}/companyInformation/{companyInformation-id}'}  # type: ignore

    async def update_company_information(
        self,
        company_id: str,
        company_information_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        currency_code: Optional[str] = None,
        current_fiscal_year_start_date: Optional[datetime.date] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        fax_number: Optional[str] = None,
        industry: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        phone_number: Optional[str] = None,
        picture: Optional[bytes] = None,
        tax_registration_number: Optional[str] = None,
        website: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property companyInformation in financials.

        Update the navigation property companyInformation in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param company_information_id: key: id of companyInformation.
        :type company_information_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param currency_code:
        :type currency_code: str
        :param current_fiscal_year_start_date:
        :type current_fiscal_year_start_date: ~datetime.date
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param fax_number:
        :type fax_number: str
        :param industry:
        :type industry: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param phone_number:
        :type phone_number: str
        :param picture:
        :type picture: bytes
        :param tax_registration_number:
        :type tax_registration_number: str
        :param website:
        :type website: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCompanyInformation(id=id, address=address, currency_code=currency_code, current_fiscal_year_start_date=current_fiscal_year_start_date, display_name=display_name, email=email, fax_number=fax_number, industry=industry, last_modified_date_time=last_modified_date_time, phone_number=phone_number, picture=picture, tax_registration_number=tax_registration_number, website=website)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_company_information.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'companyInformation-id': self._serialize.url("company_information_id", company_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCompanyInformation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_company_information.metadata = {'url': '/financials/companies/{company-id}/companyInformation/{companyInformation-id}'}  # type: ignore

    async def delete_company_information(
        self,
        company_id: str,
        company_information_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property companyInformation for financials.

        Delete navigation property companyInformation for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param company_information_id: key: id of companyInformation.
        :type company_information_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_company_information.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'companyInformation-id': self._serialize.url("company_information_id", company_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_company_information.metadata = {'url': '/financials/companies/{company-id}/companyInformation/{companyInformation-id}'}  # type: ignore

    async def get_company_information_picture(
        self,
        company_id: str,
        company_information_id: str,
        **kwargs
    ) -> IO:
        """Get media content for the navigation property companyInformation from financials.

        Get media content for the navigation property companyInformation from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param company_information_id: key: id of companyInformation.
        :type company_information_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/octet-stream, application/json"

        # Construct URL
        url = self.get_company_information_picture.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'companyInformation-id': self._serialize.url("company_information_id", company_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_company_information_picture.metadata = {'url': '/financials/companies/{company-id}/companyInformation/{companyInformation-id}/picture'}  # type: ignore

    async def set_company_information_picture(
        self,
        company_id: str,
        company_information_id: str,
        data: IO,
        **kwargs
    ) -> None:
        """Update media content for the navigation property companyInformation in financials.

        Update media content for the navigation property companyInformation in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param company_information_id: key: id of companyInformation.
        :type company_information_id: str
        :param data: New media content.
        :type data: IO
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")
        accept = "application/json"

        # Construct URL
        url = self.set_company_information_picture.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'companyInformation-id': self._serialize.url("company_information_id", company_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content_kwargs['stream_content'] = data
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_company_information_picture.metadata = {'url': '/financials/companies/{company-id}/companyInformation/{companyInformation-id}/picture'}  # type: ignore

    def list_country_region(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum18"]]] = None,
        select: Optional[List[Union[str, "models.Enum19"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCountryRegion"]:
        """Get countriesRegions from financials.

        Get countriesRegions from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum18]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum19]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCountryRegion or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfCountryRegion]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCountryRegion"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_country_region.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCountryRegion', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_country_region.metadata = {'url': '/financials/companies/{company-id}/countriesRegions'}  # type: ignore

    async def create_country_region(
        self,
        company_id: str,
        id: Optional[str] = None,
        address_format: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCountryRegion":
        """Create new navigation property to countriesRegions for financials.

        Create new navigation property to countriesRegions for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param address_format:
        :type address_format: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCountryRegion, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCountryRegion
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCountryRegion"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCountryRegion(id=id, address_format=address_format, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_country_region.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCountryRegion')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCountryRegion', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_country_region.metadata = {'url': '/financials/companies/{company-id}/countriesRegions'}  # type: ignore

    async def get_country_region(
        self,
        company_id: str,
        country_region_id: str,
        select: Optional[List[Union[str, "models.Enum20"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCountryRegion":
        """Get countriesRegions from financials.

        Get countriesRegions from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param country_region_id: key: id of countryRegion.
        :type country_region_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum20]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCountryRegion, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCountryRegion
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCountryRegion"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_country_region.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'countryRegion-id': self._serialize.url("country_region_id", country_region_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCountryRegion', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_country_region.metadata = {'url': '/financials/companies/{company-id}/countriesRegions/{countryRegion-id}'}  # type: ignore

    async def update_country_region(
        self,
        company_id: str,
        country_region_id: str,
        id: Optional[str] = None,
        address_format: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property countriesRegions in financials.

        Update the navigation property countriesRegions in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param country_region_id: key: id of countryRegion.
        :type country_region_id: str
        :param id: Read-only.
        :type id: str
        :param address_format:
        :type address_format: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCountryRegion(id=id, address_format=address_format, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_country_region.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'countryRegion-id': self._serialize.url("country_region_id", country_region_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCountryRegion')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_country_region.metadata = {'url': '/financials/companies/{company-id}/countriesRegions/{countryRegion-id}'}  # type: ignore

    async def delete_country_region(
        self,
        company_id: str,
        country_region_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property countriesRegions for financials.

        Delete navigation property countriesRegions for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param country_region_id: key: id of countryRegion.
        :type country_region_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_country_region.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'countryRegion-id': self._serialize.url("country_region_id", country_region_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_country_region.metadata = {'url': '/financials/companies/{company-id}/countriesRegions/{countryRegion-id}'}  # type: ignore

    def list_currency(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum21"]]] = None,
        select: Optional[List[Union[str, "models.Enum22"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCurrency"]:
        """Get currencies from financials.

        Get currencies from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum21]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum22]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCurrency or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfCurrency]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCurrency"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_currency.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCurrency', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_currency.metadata = {'url': '/financials/companies/{company-id}/currencies'}  # type: ignore

    async def create_currency(
        self,
        company_id: str,
        id: Optional[str] = None,
        amount_decimal_places: Optional[str] = None,
        amount_rounding_precision: Optional[float] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        symbol: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCurrency":
        """Create new navigation property to currencies for financials.

        Create new navigation property to currencies for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param amount_decimal_places:
        :type amount_decimal_places: str
        :param amount_rounding_precision:
        :type amount_rounding_precision: float
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param symbol:
        :type symbol: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCurrency, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCurrency
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCurrency"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCurrency(id=id, amount_decimal_places=amount_decimal_places, amount_rounding_precision=amount_rounding_precision, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, symbol=symbol)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_currency.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCurrency')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCurrency', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_currency.metadata = {'url': '/financials/companies/{company-id}/currencies'}  # type: ignore

    async def get_currency(
        self,
        company_id: str,
        currency_id: str,
        select: Optional[List[Union[str, "models.Enum23"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCurrency":
        """Get currencies from financials.

        Get currencies from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param currency_id: key: id of currency.
        :type currency_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum23]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCurrency, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCurrency
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCurrency"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_currency.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'currency-id': self._serialize.url("currency_id", currency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCurrency', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_currency.metadata = {'url': '/financials/companies/{company-id}/currencies/{currency-id}'}  # type: ignore

    async def update_currency(
        self,
        company_id: str,
        currency_id: str,
        id: Optional[str] = None,
        amount_decimal_places: Optional[str] = None,
        amount_rounding_precision: Optional[float] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        symbol: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property currencies in financials.

        Update the navigation property currencies in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param currency_id: key: id of currency.
        :type currency_id: str
        :param id: Read-only.
        :type id: str
        :param amount_decimal_places:
        :type amount_decimal_places: str
        :param amount_rounding_precision:
        :type amount_rounding_precision: float
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param symbol:
        :type symbol: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCurrency(id=id, amount_decimal_places=amount_decimal_places, amount_rounding_precision=amount_rounding_precision, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, symbol=symbol)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_currency.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'currency-id': self._serialize.url("currency_id", currency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCurrency')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_currency.metadata = {'url': '/financials/companies/{company-id}/currencies/{currency-id}'}  # type: ignore

    async def delete_currency(
        self,
        company_id: str,
        currency_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property currencies for financials.

        Delete navigation property currencies for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param currency_id: key: id of currency.
        :type currency_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_currency.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'currency-id': self._serialize.url("currency_id", currency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_currency.metadata = {'url': '/financials/companies/{company-id}/currencies/{currency-id}'}  # type: ignore

    def list_customer_payment_journal(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum24"]]] = None,
        select: Optional[List[Union[str, "models.Enum25"]]] = None,
        expand: Optional[List[Union[str, "models.Enum26"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCustomerPaymentJournal"]:
        """Get customerPaymentJournals from financials.

        Get customerPaymentJournals from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum24]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum26]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCustomerPaymentJournal or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfCustomerPaymentJournal]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCustomerPaymentJournal"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_customer_payment_journal.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCustomerPaymentJournal', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_customer_payment_journal.metadata = {'url': '/financials/companies/{company-id}/customerPaymentJournals'}  # type: ignore

    async def create_customer_payment_journal(
        self,
        company_id: str,
        id: Optional[str] = None,
        balancing_account_id: Optional[str] = None,
        balancing_account_number: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        customer_payments: Optional[List["models.MicrosoftGraphCustomerPayment"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCustomerPaymentJournal":
        """Create new navigation property to customerPaymentJournals for financials.

        Create new navigation property to customerPaymentJournals for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param balancing_account_id:
        :type balancing_account_id: str
        :param balancing_account_number:
        :type balancing_account_number: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param customer_payments:
        :type customer_payments: list[~financials.models.MicrosoftGraphCustomerPayment]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCustomerPaymentJournal, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCustomerPaymentJournal
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCustomerPaymentJournal"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCustomerPaymentJournal(id=id, balancing_account_id=balancing_account_id, balancing_account_number=balancing_account_number, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, account=account, customer_payments=customer_payments)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_customer_payment_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCustomerPaymentJournal')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCustomerPaymentJournal', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_customer_payment_journal.metadata = {'url': '/financials/companies/{company-id}/customerPaymentJournals'}  # type: ignore

    async def get_customer_payment_journal(
        self,
        company_id: str,
        customer_payment_journal_id: str,
        select: Optional[List[Union[str, "models.Enum27"]]] = None,
        expand: Optional[List[Union[str, "models.Enum28"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCustomerPaymentJournal":
        """Get customerPaymentJournals from financials.

        Get customerPaymentJournals from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_payment_journal_id: key: id of customerPaymentJournal.
        :type customer_payment_journal_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum27]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum28]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCustomerPaymentJournal, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCustomerPaymentJournal
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCustomerPaymentJournal"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_customer_payment_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customerPaymentJournal-id': self._serialize.url("customer_payment_journal_id", customer_payment_journal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCustomerPaymentJournal', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_customer_payment_journal.metadata = {'url': '/financials/companies/{company-id}/customerPaymentJournals/{customerPaymentJournal-id}'}  # type: ignore

    async def update_customer_payment_journal(
        self,
        company_id: str,
        customer_payment_journal_id: str,
        id: Optional[str] = None,
        balancing_account_id: Optional[str] = None,
        balancing_account_number: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        customer_payments: Optional[List["models.MicrosoftGraphCustomerPayment"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property customerPaymentJournals in financials.

        Update the navigation property customerPaymentJournals in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_payment_journal_id: key: id of customerPaymentJournal.
        :type customer_payment_journal_id: str
        :param id: Read-only.
        :type id: str
        :param balancing_account_id:
        :type balancing_account_id: str
        :param balancing_account_number:
        :type balancing_account_number: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param customer_payments:
        :type customer_payments: list[~financials.models.MicrosoftGraphCustomerPayment]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCustomerPaymentJournal(id=id, balancing_account_id=balancing_account_id, balancing_account_number=balancing_account_number, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, account=account, customer_payments=customer_payments)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_customer_payment_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customerPaymentJournal-id': self._serialize.url("customer_payment_journal_id", customer_payment_journal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCustomerPaymentJournal')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_customer_payment_journal.metadata = {'url': '/financials/companies/{company-id}/customerPaymentJournals/{customerPaymentJournal-id}'}  # type: ignore

    async def delete_customer_payment_journal(
        self,
        company_id: str,
        customer_payment_journal_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property customerPaymentJournals for financials.

        Delete navigation property customerPaymentJournals for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_payment_journal_id: key: id of customerPaymentJournal.
        :type customer_payment_journal_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_customer_payment_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customerPaymentJournal-id': self._serialize.url("customer_payment_journal_id", customer_payment_journal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_customer_payment_journal.metadata = {'url': '/financials/companies/{company-id}/customerPaymentJournals/{customerPaymentJournal-id}'}  # type: ignore

    def list_customer_payment(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum44"]]] = None,
        select: Optional[List[Union[str, "models.Enum45"]]] = None,
        expand: Optional[List[Union[str, "models.Enum46"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCustomerPayment0"]:
        """Get customerPayments from financials.

        Get customerPayments from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum44]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum45]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum46]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCustomerPayment0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfCustomerPayment0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCustomerPayment0"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_customer_payment.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCustomerPayment0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_customer_payment.metadata = {'url': '/financials/companies/{company-id}/customerPayments'}  # type: ignore

    async def create_customer_payment(
        self,
        company_id: str,
        id: Optional[str] = None,
        amount: Optional[float] = None,
        applies_to_invoice_id: Optional[str] = None,
        applies_to_invoice_number: Optional[str] = None,
        comment: Optional[str] = None,
        contact_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_number: Optional[str] = None,
        description: Optional[str] = None,
        document_number: Optional[str] = None,
        external_document_number: Optional[str] = None,
        journal_display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        line_number: Optional[int] = None,
        posting_date: Optional[datetime.date] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCustomerPayment":
        """Create new navigation property to customerPayments for financials.

        Create new navigation property to customerPayments for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param amount:
        :type amount: float
        :param applies_to_invoice_id:
        :type applies_to_invoice_id: str
        :param applies_to_invoice_number:
        :type applies_to_invoice_number: str
        :param comment:
        :type comment: str
        :param contact_id:
        :type contact_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_number:
        :type customer_number: str
        :param description:
        :type description: str
        :param document_number:
        :type document_number: str
        :param external_document_number:
        :type external_document_number: str
        :param journal_display_name:
        :type journal_display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param line_number:
        :type line_number: int
        :param posting_date:
        :type posting_date: ~datetime.date
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCustomerPayment, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCustomerPayment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCustomerPayment"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCustomerPayment(id=id, amount=amount, applies_to_invoice_id=applies_to_invoice_id, applies_to_invoice_number=applies_to_invoice_number, comment=comment, contact_id=contact_id, customer_id=customer_id, customer_number=customer_number, description=description, document_number=document_number, external_document_number=external_document_number, journal_display_name=journal_display_name, last_modified_date_time=last_modified_date_time, line_number=line_number, posting_date=posting_date, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code=currency_code, currency_id=currency_id, display_name=display_name, email=email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number=number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency=currency, payment_method=payment_method, payment_term=payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_customer_payment.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCustomerPayment')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCustomerPayment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_customer_payment.metadata = {'url': '/financials/companies/{company-id}/customerPayments'}  # type: ignore

    async def get_customer_payment(
        self,
        company_id: str,
        customer_payment_id: str,
        select: Optional[List[Union[str, "models.Enum47"]]] = None,
        expand: Optional[List[Union[str, "models.Enum48"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCustomerPayment":
        """Get customerPayments from financials.

        Get customerPayments from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_payment_id: key: id of customerPayment.
        :type customer_payment_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum47]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum48]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCustomerPayment, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCustomerPayment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCustomerPayment"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_customer_payment.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customerPayment-id': self._serialize.url("customer_payment_id", customer_payment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCustomerPayment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_customer_payment.metadata = {'url': '/financials/companies/{company-id}/customerPayments/{customerPayment-id}'}  # type: ignore

    async def update_customer_payment(
        self,
        company_id: str,
        customer_payment_id: str,
        id: Optional[str] = None,
        amount: Optional[float] = None,
        applies_to_invoice_id: Optional[str] = None,
        applies_to_invoice_number: Optional[str] = None,
        comment: Optional[str] = None,
        contact_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_number: Optional[str] = None,
        description: Optional[str] = None,
        document_number: Optional[str] = None,
        external_document_number: Optional[str] = None,
        journal_display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        line_number: Optional[int] = None,
        posting_date: Optional[datetime.date] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property customerPayments in financials.

        Update the navigation property customerPayments in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_payment_id: key: id of customerPayment.
        :type customer_payment_id: str
        :param id: Read-only.
        :type id: str
        :param amount:
        :type amount: float
        :param applies_to_invoice_id:
        :type applies_to_invoice_id: str
        :param applies_to_invoice_number:
        :type applies_to_invoice_number: str
        :param comment:
        :type comment: str
        :param contact_id:
        :type contact_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_number:
        :type customer_number: str
        :param description:
        :type description: str
        :param document_number:
        :type document_number: str
        :param external_document_number:
        :type external_document_number: str
        :param journal_display_name:
        :type journal_display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param line_number:
        :type line_number: int
        :param posting_date:
        :type posting_date: ~datetime.date
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCustomerPayment(id=id, amount=amount, applies_to_invoice_id=applies_to_invoice_id, applies_to_invoice_number=applies_to_invoice_number, comment=comment, contact_id=contact_id, customer_id=customer_id, customer_number=customer_number, description=description, document_number=document_number, external_document_number=external_document_number, journal_display_name=journal_display_name, last_modified_date_time=last_modified_date_time, line_number=line_number, posting_date=posting_date, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code=currency_code, currency_id=currency_id, display_name=display_name, email=email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number=number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency=currency, payment_method=payment_method, payment_term=payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_customer_payment.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customerPayment-id': self._serialize.url("customer_payment_id", customer_payment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCustomerPayment')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_customer_payment.metadata = {'url': '/financials/companies/{company-id}/customerPayments/{customerPayment-id}'}  # type: ignore

    async def delete_customer_payment(
        self,
        company_id: str,
        customer_payment_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property customerPayments for financials.

        Delete navigation property customerPayments for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_payment_id: key: id of customerPayment.
        :type customer_payment_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_customer_payment.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customerPayment-id': self._serialize.url("customer_payment_id", customer_payment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_customer_payment.metadata = {'url': '/financials/companies/{company-id}/customerPayments/{customerPayment-id}'}  # type: ignore

    def list_customer(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum58"]]] = None,
        select: Optional[List[Union[str, "models.Enum59"]]] = None,
        expand: Optional[List[Union[str, "models.Enum60"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCustomer"]:
        """Get customers from financials.

        Get customers from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum58]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum59]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum60]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCustomer or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfCustomer]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCustomer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_customer.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCustomer', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_customer.metadata = {'url': '/financials/companies/{company-id}/customers'}  # type: ignore

    async def create_customer(
        self,
        company_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCustomer":
        """Create new navigation property to customers for financials.

        Create new navigation property to customers for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCustomer, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCustomer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCustomer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCustomer(id=id, address=address, blocked=blocked, currency_code=currency_code, currency_id=currency_id, display_name=display_name, email=email, last_modified_date_time=last_modified_date_time, number=number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency=currency, payment_method=payment_method, payment_term=payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_customer.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCustomer')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCustomer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_customer.metadata = {'url': '/financials/companies/{company-id}/customers'}  # type: ignore

    async def get_customer(
        self,
        company_id: str,
        customer_id: str,
        select: Optional[List[Union[str, "models.Enum61"]]] = None,
        expand: Optional[List[Union[str, "models.Enum62"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCustomer":
        """Get customers from financials.

        Get customers from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_id: key: id of customer.
        :type customer_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum61]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum62]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCustomer, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphCustomer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCustomer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_customer.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customer-id': self._serialize.url("customer_id", customer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCustomer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_customer.metadata = {'url': '/financials/companies/{company-id}/customers/{customer-id}'}  # type: ignore

    async def update_customer(
        self,
        company_id: str,
        customer_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property customers in financials.

        Update the navigation property customers in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_id: key: id of customer.
        :type customer_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCustomer(id=id, address=address, blocked=blocked, currency_code=currency_code, currency_id=currency_id, display_name=display_name, email=email, last_modified_date_time=last_modified_date_time, number=number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency=currency, payment_method=payment_method, payment_term=payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_customer.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customer-id': self._serialize.url("customer_id", customer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCustomer')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_customer.metadata = {'url': '/financials/companies/{company-id}/customers/{customer-id}'}  # type: ignore

    async def delete_customer(
        self,
        company_id: str,
        customer_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property customers for financials.

        Delete navigation property customers for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param customer_id: key: id of customer.
        :type customer_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_customer.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'customer-id': self._serialize.url("customer_id", customer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_customer.metadata = {'url': '/financials/companies/{company-id}/customers/{customer-id}'}  # type: ignore

    def list_dimension(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum70"]]] = None,
        select: Optional[List[Union[str, "models.Enum71"]]] = None,
        expand: Optional[List[Union[str, "models.Enum72"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDimension"]:
        """Get dimensions from financials.

        Get dimensions from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum70]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum71]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum72]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDimension or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfDimension]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDimension"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_dimension.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDimension', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_dimension.metadata = {'url': '/financials/companies/{company-id}/dimensions'}  # type: ignore

    async def create_dimension(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        dimension_values: Optional[List["models.MicrosoftGraphDimensionValue"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDimension":
        """Create new navigation property to dimensions for financials.

        Create new navigation property to dimensions for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param dimension_values:
        :type dimension_values: list[~financials.models.MicrosoftGraphDimensionValue]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDimension, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphDimension
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDimension"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDimension(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, dimension_values=dimension_values)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_dimension.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDimension')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDimension', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_dimension.metadata = {'url': '/financials/companies/{company-id}/dimensions'}  # type: ignore

    async def get_dimension(
        self,
        company_id: str,
        dimension_id: str,
        select: Optional[List[Union[str, "models.Enum73"]]] = None,
        expand: Optional[List[Union[str, "models.Enum74"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDimension":
        """Get dimensions from financials.

        Get dimensions from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param dimension_id: key: id of dimension.
        :type dimension_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum73]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum74]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDimension, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphDimension
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDimension"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_dimension.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'dimension-id': self._serialize.url("dimension_id", dimension_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDimension', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_dimension.metadata = {'url': '/financials/companies/{company-id}/dimensions/{dimension-id}'}  # type: ignore

    async def update_dimension(
        self,
        company_id: str,
        dimension_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        dimension_values: Optional[List["models.MicrosoftGraphDimensionValue"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property dimensions in financials.

        Update the navigation property dimensions in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param dimension_id: key: id of dimension.
        :type dimension_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param dimension_values:
        :type dimension_values: list[~financials.models.MicrosoftGraphDimensionValue]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDimension(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, dimension_values=dimension_values)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_dimension.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'dimension-id': self._serialize.url("dimension_id", dimension_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDimension')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_dimension.metadata = {'url': '/financials/companies/{company-id}/dimensions/{dimension-id}'}  # type: ignore

    async def delete_dimension(
        self,
        company_id: str,
        dimension_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property dimensions for financials.

        Delete navigation property dimensions for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param dimension_id: key: id of dimension.
        :type dimension_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_dimension.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'dimension-id': self._serialize.url("dimension_id", dimension_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_dimension.metadata = {'url': '/financials/companies/{company-id}/dimensions/{dimension-id}'}  # type: ignore

    def list_dimension_value(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum78"]]] = None,
        select: Optional[List[Union[str, "models.Enum79"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDimensionValue0"]:
        """Get dimensionValues from financials.

        Get dimensionValues from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum78]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum79]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDimensionValue0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfDimensionValue0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDimensionValue0"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_dimension_value.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDimensionValue0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_dimension_value.metadata = {'url': '/financials/companies/{company-id}/dimensionValues'}  # type: ignore

    async def create_dimension_value(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDimensionValue":
        """Create new navigation property to dimensionValues for financials.

        Create new navigation property to dimensionValues for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDimensionValue, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphDimensionValue
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDimensionValue"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDimensionValue(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_dimension_value.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDimensionValue')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDimensionValue', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_dimension_value.metadata = {'url': '/financials/companies/{company-id}/dimensionValues'}  # type: ignore

    async def get_dimension_value(
        self,
        company_id: str,
        dimension_value_id: str,
        select: Optional[List[Union[str, "models.Enum80"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDimensionValue":
        """Get dimensionValues from financials.

        Get dimensionValues from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param dimension_value_id: key: id of dimensionValue.
        :type dimension_value_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum80]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDimensionValue, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphDimensionValue
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDimensionValue"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_dimension_value.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'dimensionValue-id': self._serialize.url("dimension_value_id", dimension_value_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDimensionValue', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_dimension_value.metadata = {'url': '/financials/companies/{company-id}/dimensionValues/{dimensionValue-id}'}  # type: ignore

    async def update_dimension_value(
        self,
        company_id: str,
        dimension_value_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property dimensionValues in financials.

        Update the navigation property dimensionValues in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param dimension_value_id: key: id of dimensionValue.
        :type dimension_value_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDimensionValue(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_dimension_value.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'dimensionValue-id': self._serialize.url("dimension_value_id", dimension_value_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDimensionValue')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_dimension_value.metadata = {'url': '/financials/companies/{company-id}/dimensionValues/{dimensionValue-id}'}  # type: ignore

    async def delete_dimension_value(
        self,
        company_id: str,
        dimension_value_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property dimensionValues for financials.

        Delete navigation property dimensionValues for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param dimension_value_id: key: id of dimensionValue.
        :type dimension_value_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_dimension_value.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'dimensionValue-id': self._serialize.url("dimension_value_id", dimension_value_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_dimension_value.metadata = {'url': '/financials/companies/{company-id}/dimensionValues/{dimensionValue-id}'}  # type: ignore

    def list_employee(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum81"]]] = None,
        select: Optional[List[Union[str, "models.Enum82"]]] = None,
        expand: Optional[List[Union[str, "models.Enum83"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEmployee"]:
        """Get employees from financials.

        Get employees from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum81]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum82]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum83]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEmployee or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfEmployee]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEmployee"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_employee.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEmployee', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_employee.metadata = {'url': '/financials/companies/{company-id}/employees'}  # type: ignore

    async def create_employee(
        self,
        company_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        birth_date: Optional[datetime.date] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        employment_date: Optional[datetime.date] = None,
        given_name: Optional[str] = None,
        job_title: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        middle_name: Optional[str] = None,
        mobile_phone: Optional[str] = None,
        number: Optional[str] = None,
        personal_email: Optional[str] = None,
        phone_number: Optional[str] = None,
        statistics_group_code: Optional[str] = None,
        status: Optional[str] = None,
        surname: Optional[str] = None,
        termination_date: Optional[datetime.date] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEmployee":
        """Create new navigation property to employees for financials.

        Create new navigation property to employees for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param birth_date:
        :type birth_date: ~datetime.date
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param employment_date:
        :type employment_date: ~datetime.date
        :param given_name:
        :type given_name: str
        :param job_title:
        :type job_title: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param middle_name:
        :type middle_name: str
        :param mobile_phone:
        :type mobile_phone: str
        :param number:
        :type number: str
        :param personal_email:
        :type personal_email: str
        :param phone_number:
        :type phone_number: str
        :param statistics_group_code:
        :type statistics_group_code: str
        :param status:
        :type status: str
        :param surname:
        :type surname: str
        :param termination_date:
        :type termination_date: ~datetime.date
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEmployee, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphEmployee
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEmployee"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEmployee(id=id, address=address, birth_date=birth_date, display_name=display_name, email=email, employment_date=employment_date, given_name=given_name, job_title=job_title, last_modified_date_time=last_modified_date_time, middle_name=middle_name, mobile_phone=mobile_phone, number=number, personal_email=personal_email, phone_number=phone_number, statistics_group_code=statistics_group_code, status=status, surname=surname, termination_date=termination_date, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_employee.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEmployee')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEmployee', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_employee.metadata = {'url': '/financials/companies/{company-id}/employees'}  # type: ignore

    async def get_employee(
        self,
        company_id: str,
        employee_id: str,
        select: Optional[List[Union[str, "models.Enum84"]]] = None,
        expand: Optional[List[Union[str, "models.Enum85"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEmployee":
        """Get employees from financials.

        Get employees from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param employee_id: key: id of employee.
        :type employee_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum84]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum85]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEmployee, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphEmployee
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEmployee"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_employee.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'employee-id': self._serialize.url("employee_id", employee_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEmployee', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_employee.metadata = {'url': '/financials/companies/{company-id}/employees/{employee-id}'}  # type: ignore

    async def update_employee(
        self,
        company_id: str,
        employee_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        birth_date: Optional[datetime.date] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        employment_date: Optional[datetime.date] = None,
        given_name: Optional[str] = None,
        job_title: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        middle_name: Optional[str] = None,
        mobile_phone: Optional[str] = None,
        number: Optional[str] = None,
        personal_email: Optional[str] = None,
        phone_number: Optional[str] = None,
        statistics_group_code: Optional[str] = None,
        status: Optional[str] = None,
        surname: Optional[str] = None,
        termination_date: Optional[datetime.date] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property employees in financials.

        Update the navigation property employees in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param employee_id: key: id of employee.
        :type employee_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param birth_date:
        :type birth_date: ~datetime.date
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param employment_date:
        :type employment_date: ~datetime.date
        :param given_name:
        :type given_name: str
        :param job_title:
        :type job_title: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param middle_name:
        :type middle_name: str
        :param mobile_phone:
        :type mobile_phone: str
        :param number:
        :type number: str
        :param personal_email:
        :type personal_email: str
        :param phone_number:
        :type phone_number: str
        :param statistics_group_code:
        :type statistics_group_code: str
        :param status:
        :type status: str
        :param surname:
        :type surname: str
        :param termination_date:
        :type termination_date: ~datetime.date
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEmployee(id=id, address=address, birth_date=birth_date, display_name=display_name, email=email, employment_date=employment_date, given_name=given_name, job_title=job_title, last_modified_date_time=last_modified_date_time, middle_name=middle_name, mobile_phone=mobile_phone, number=number, personal_email=personal_email, phone_number=phone_number, statistics_group_code=statistics_group_code, status=status, surname=surname, termination_date=termination_date, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_employee.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'employee-id': self._serialize.url("employee_id", employee_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEmployee')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_employee.metadata = {'url': '/financials/companies/{company-id}/employees/{employee-id}'}  # type: ignore

    async def delete_employee(
        self,
        company_id: str,
        employee_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property employees for financials.

        Delete navigation property employees for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param employee_id: key: id of employee.
        :type employee_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_employee.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'employee-id': self._serialize.url("employee_id", employee_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_employee.metadata = {'url': '/financials/companies/{company-id}/employees/{employee-id}'}  # type: ignore

    def list_general_ledger_entry(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum89"]]] = None,
        select: Optional[List[Union[str, "models.Enum90"]]] = None,
        expand: Optional[List[Union[str, "models.Enum91"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfGeneralLedgerEntry"]:
        """Get generalLedgerEntries from financials.

        Get generalLedgerEntries from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum89]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum90]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum91]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfGeneralLedgerEntry or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfGeneralLedgerEntry]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfGeneralLedgerEntry"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_general_ledger_entry.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfGeneralLedgerEntry', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_general_ledger_entry.metadata = {'url': '/financials/companies/{company-id}/generalLedgerEntries'}  # type: ignore

    async def create_general_ledger_entry(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        account_number: Optional[str] = None,
        credit_amount: Optional[float] = None,
        debit_amount: Optional[float] = None,
        description: Optional[str] = None,
        document_number: Optional[str] = None,
        document_type: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        posting_date: Optional[datetime.date] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphGeneralLedgerEntry":
        """Create new navigation property to generalLedgerEntries for financials.

        Create new navigation property to generalLedgerEntries for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param account_number:
        :type account_number: str
        :param credit_amount:
        :type credit_amount: float
        :param debit_amount:
        :type debit_amount: float
        :param description:
        :type description: str
        :param document_number:
        :type document_number: str
        :param document_type:
        :type document_type: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param posting_date:
        :type posting_date: ~datetime.date
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphGeneralLedgerEntry, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphGeneralLedgerEntry
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphGeneralLedgerEntry"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphGeneralLedgerEntry(id=id, account_id=account_id, account_number=account_number, credit_amount=credit_amount, debit_amount=debit_amount, description=description, document_number=document_number, document_type=document_type, last_modified_date_time=last_modified_date_time, posting_date=posting_date, account=account)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_general_ledger_entry.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphGeneralLedgerEntry')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphGeneralLedgerEntry', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_general_ledger_entry.metadata = {'url': '/financials/companies/{company-id}/generalLedgerEntries'}  # type: ignore

    async def get_general_ledger_entry(
        self,
        company_id: str,
        general_ledger_entry_id: str,
        select: Optional[List[Union[str, "models.Enum92"]]] = None,
        expand: Optional[List[Union[str, "models.Enum93"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphGeneralLedgerEntry":
        """Get generalLedgerEntries from financials.

        Get generalLedgerEntries from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param general_ledger_entry_id: key: id of generalLedgerEntry.
        :type general_ledger_entry_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum92]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum93]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphGeneralLedgerEntry, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphGeneralLedgerEntry
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphGeneralLedgerEntry"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_general_ledger_entry.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'generalLedgerEntry-id': self._serialize.url("general_ledger_entry_id", general_ledger_entry_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphGeneralLedgerEntry', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_general_ledger_entry.metadata = {'url': '/financials/companies/{company-id}/generalLedgerEntries/{generalLedgerEntry-id}'}  # type: ignore

    async def update_general_ledger_entry(
        self,
        company_id: str,
        general_ledger_entry_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        account_number: Optional[str] = None,
        credit_amount: Optional[float] = None,
        debit_amount: Optional[float] = None,
        description: Optional[str] = None,
        document_number: Optional[str] = None,
        document_type: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        posting_date: Optional[datetime.date] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property generalLedgerEntries in financials.

        Update the navigation property generalLedgerEntries in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param general_ledger_entry_id: key: id of generalLedgerEntry.
        :type general_ledger_entry_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param account_number:
        :type account_number: str
        :param credit_amount:
        :type credit_amount: float
        :param debit_amount:
        :type debit_amount: float
        :param description:
        :type description: str
        :param document_number:
        :type document_number: str
        :param document_type:
        :type document_type: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param posting_date:
        :type posting_date: ~datetime.date
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphGeneralLedgerEntry(id=id, account_id=account_id, account_number=account_number, credit_amount=credit_amount, debit_amount=debit_amount, description=description, document_number=document_number, document_type=document_type, last_modified_date_time=last_modified_date_time, posting_date=posting_date, account=account)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_general_ledger_entry.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'generalLedgerEntry-id': self._serialize.url("general_ledger_entry_id", general_ledger_entry_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphGeneralLedgerEntry')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_general_ledger_entry.metadata = {'url': '/financials/companies/{company-id}/generalLedgerEntries/{generalLedgerEntry-id}'}  # type: ignore

    async def delete_general_ledger_entry(
        self,
        company_id: str,
        general_ledger_entry_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property generalLedgerEntries for financials.

        Delete navigation property generalLedgerEntries for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param general_ledger_entry_id: key: id of generalLedgerEntry.
        :type general_ledger_entry_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_general_ledger_entry.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'generalLedgerEntry-id': self._serialize.url("general_ledger_entry_id", general_ledger_entry_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_general_ledger_entry.metadata = {'url': '/financials/companies/{company-id}/generalLedgerEntries/{generalLedgerEntry-id}'}  # type: ignore

    def list_item_category(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum95"]]] = None,
        select: Optional[List[Union[str, "models.Enum96"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItemCategory"]:
        """Get itemCategories from financials.

        Get itemCategories from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum95]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum96]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItemCategory or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfItemCategory]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItemCategory"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_item_category.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItemCategory', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_item_category.metadata = {'url': '/financials/companies/{company-id}/itemCategories'}  # type: ignore

    async def create_item_category(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemCategory":
        """Create new navigation property to itemCategories for financials.

        Create new navigation property to itemCategories for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemCategory, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphItemCategory
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemCategory"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphItemCategory(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_item_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphItemCategory')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_item_category.metadata = {'url': '/financials/companies/{company-id}/itemCategories'}  # type: ignore

    async def get_item_category(
        self,
        company_id: str,
        item_category_id: str,
        select: Optional[List[Union[str, "models.Enum97"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemCategory":
        """Get itemCategories from financials.

        Get itemCategories from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param item_category_id: key: id of itemCategory.
        :type item_category_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum97]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemCategory, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphItemCategory
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemCategory"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_item_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'itemCategory-id': self._serialize.url("item_category_id", item_category_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemCategory', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_item_category.metadata = {'url': '/financials/companies/{company-id}/itemCategories/{itemCategory-id}'}  # type: ignore

    async def update_item_category(
        self,
        company_id: str,
        item_category_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property itemCategories in financials.

        Update the navigation property itemCategories in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param item_category_id: key: id of itemCategory.
        :type item_category_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphItemCategory(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_item_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'itemCategory-id': self._serialize.url("item_category_id", item_category_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphItemCategory')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_item_category.metadata = {'url': '/financials/companies/{company-id}/itemCategories/{itemCategory-id}'}  # type: ignore

    async def delete_item_category(
        self,
        company_id: str,
        item_category_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property itemCategories for financials.

        Delete navigation property itemCategories for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param item_category_id: key: id of itemCategory.
        :type item_category_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_item_category.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'itemCategory-id': self._serialize.url("item_category_id", item_category_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_item_category.metadata = {'url': '/financials/companies/{company-id}/itemCategories/{itemCategory-id}'}  # type: ignore

    def list_item(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum98"]]] = None,
        select: Optional[List[Union[str, "models.Enum99"]]] = None,
        expand: Optional[List[Union[str, "models.Enum100"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItem"]:
        """Get items from financials.

        Get items from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum98]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum99]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum100]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItem or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfItem]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItem"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_item.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItem', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_item.metadata = {'url': '/financials/companies/{company-id}/items'}  # type: ignore

    async def create_item(
        self,
        company_id: str,
        id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItem":
        """Create new navigation property to items for financials.

        Create new navigation property to items for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param unit_price:
        :type unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItem, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphItem
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItem"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphItem(id=id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price=unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_item.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphItem')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItem', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_item.metadata = {'url': '/financials/companies/{company-id}/items'}  # type: ignore

    async def get_item(
        self,
        company_id: str,
        item_id: str,
        select: Optional[List[Union[str, "models.Enum101"]]] = None,
        expand: Optional[List[Union[str, "models.Enum102"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItem":
        """Get items from financials.

        Get items from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param item_id: key: id of item.
        :type item_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum101]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum102]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItem, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphItem
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItem"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_item.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'item-id': self._serialize.url("item_id", item_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItem', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_item.metadata = {'url': '/financials/companies/{company-id}/items/{item-id}'}  # type: ignore

    async def update_item(
        self,
        company_id: str,
        item_id: str,
        id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property items in financials.

        Update the navigation property items in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param item_id: key: id of item.
        :type item_id: str
        :param id: Read-only.
        :type id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param unit_price:
        :type unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphItem(id=id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price=unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_item.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'item-id': self._serialize.url("item_id", item_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphItem')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_item.metadata = {'url': '/financials/companies/{company-id}/items/{item-id}'}  # type: ignore

    async def delete_item(
        self,
        company_id: str,
        item_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property items for financials.

        Delete navigation property items for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param item_id: key: id of item.
        :type item_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_item.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'item-id': self._serialize.url("item_id", item_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_item.metadata = {'url': '/financials/companies/{company-id}/items/{item-id}'}  # type: ignore

    def list_journal_line(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum107"]]] = None,
        select: Optional[List[Union[str, "models.Enum108"]]] = None,
        expand: Optional[List[Union[str, "models.Enum109"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfJournalLine"]:
        """Get journalLines from financials.

        Get journalLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum107]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum108]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum109]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfJournalLine or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfJournalLine]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfJournalLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_journal_line.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfJournalLine', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_journal_line.metadata = {'url': '/financials/companies/{company-id}/journalLines'}  # type: ignore

    async def create_journal_line(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        account_number: Optional[str] = None,
        amount: Optional[float] = None,
        comment: Optional[str] = None,
        description: Optional[str] = None,
        document_number: Optional[str] = None,
        external_document_number: Optional[str] = None,
        journal_display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        line_number: Optional[int] = None,
        posting_date: Optional[datetime.date] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphJournalLine":
        """Create new navigation property to journalLines for financials.

        Create new navigation property to journalLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param account_number:
        :type account_number: str
        :param amount:
        :type amount: float
        :param comment:
        :type comment: str
        :param description:
        :type description: str
        :param document_number:
        :type document_number: str
        :param external_document_number:
        :type external_document_number: str
        :param journal_display_name:
        :type journal_display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param line_number:
        :type line_number: int
        :param posting_date:
        :type posting_date: ~datetime.date
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphJournalLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphJournalLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphJournalLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphJournalLine(id=id, account_id=account_id, account_number=account_number, amount=amount, comment=comment, description=description, document_number=document_number, external_document_number=external_document_number, journal_display_name=journal_display_name, last_modified_date_time=last_modified_date_time, line_number=line_number, posting_date=posting_date, account=account)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_journal_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphJournalLine')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphJournalLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_journal_line.metadata = {'url': '/financials/companies/{company-id}/journalLines'}  # type: ignore

    async def get_journal_line(
        self,
        company_id: str,
        journal_line_id: str,
        select: Optional[List[Union[str, "models.Enum110"]]] = None,
        expand: Optional[List[Union[str, "models.Enum111"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphJournalLine":
        """Get journalLines from financials.

        Get journalLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param journal_line_id: key: id of journalLine.
        :type journal_line_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum110]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum111]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphJournalLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphJournalLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphJournalLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_journal_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'journalLine-id': self._serialize.url("journal_line_id", journal_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphJournalLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_journal_line.metadata = {'url': '/financials/companies/{company-id}/journalLines/{journalLine-id}'}  # type: ignore

    async def update_journal_line(
        self,
        company_id: str,
        journal_line_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        account_number: Optional[str] = None,
        amount: Optional[float] = None,
        comment: Optional[str] = None,
        description: Optional[str] = None,
        document_number: Optional[str] = None,
        external_document_number: Optional[str] = None,
        journal_display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        line_number: Optional[int] = None,
        posting_date: Optional[datetime.date] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property journalLines in financials.

        Update the navigation property journalLines in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param journal_line_id: key: id of journalLine.
        :type journal_line_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param account_number:
        :type account_number: str
        :param amount:
        :type amount: float
        :param comment:
        :type comment: str
        :param description:
        :type description: str
        :param document_number:
        :type document_number: str
        :param external_document_number:
        :type external_document_number: str
        :param journal_display_name:
        :type journal_display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param line_number:
        :type line_number: int
        :param posting_date:
        :type posting_date: ~datetime.date
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphJournalLine(id=id, account_id=account_id, account_number=account_number, amount=amount, comment=comment, description=description, document_number=document_number, external_document_number=external_document_number, journal_display_name=journal_display_name, last_modified_date_time=last_modified_date_time, line_number=line_number, posting_date=posting_date, account=account)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_journal_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'journalLine-id': self._serialize.url("journal_line_id", journal_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphJournalLine')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_journal_line.metadata = {'url': '/financials/companies/{company-id}/journalLines/{journalLine-id}'}  # type: ignore

    async def delete_journal_line(
        self,
        company_id: str,
        journal_line_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property journalLines for financials.

        Delete navigation property journalLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param journal_line_id: key: id of journalLine.
        :type journal_line_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_journal_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'journalLine-id': self._serialize.url("journal_line_id", journal_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_journal_line.metadata = {'url': '/financials/companies/{company-id}/journalLines/{journalLine-id}'}  # type: ignore

    def list_journal(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum113"]]] = None,
        select: Optional[List[Union[str, "models.Enum114"]]] = None,
        expand: Optional[List[Union[str, "models.Enum115"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfJournal"]:
        """Get journals from financials.

        Get journals from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum113]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum114]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum115]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfJournal or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfJournal]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfJournal"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_journal.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfJournal', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_journal.metadata = {'url': '/financials/companies/{company-id}/journals'}  # type: ignore

    async def create_journal(
        self,
        company_id: str,
        id: Optional[str] = None,
        balancing_account_id: Optional[str] = None,
        balancing_account_number: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        journal_lines: Optional[List["models.MicrosoftGraphJournalLine"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphJournal":
        """Create new navigation property to journals for financials.

        Create new navigation property to journals for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param balancing_account_id:
        :type balancing_account_id: str
        :param balancing_account_number:
        :type balancing_account_number: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param journal_lines:
        :type journal_lines: list[~financials.models.MicrosoftGraphJournalLine]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphJournal, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphJournal
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphJournal"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphJournal(id=id, balancing_account_id=balancing_account_id, balancing_account_number=balancing_account_number, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, account=account, journal_lines=journal_lines)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphJournal')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphJournal', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_journal.metadata = {'url': '/financials/companies/{company-id}/journals'}  # type: ignore

    async def get_journal(
        self,
        company_id: str,
        journal_id: str,
        select: Optional[List[Union[str, "models.Enum116"]]] = None,
        expand: Optional[List[Union[str, "models.Enum117"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphJournal":
        """Get journals from financials.

        Get journals from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param journal_id: key: id of journal.
        :type journal_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum116]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum117]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphJournal, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphJournal
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphJournal"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'journal-id': self._serialize.url("journal_id", journal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphJournal', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_journal.metadata = {'url': '/financials/companies/{company-id}/journals/{journal-id}'}  # type: ignore

    async def update_journal(
        self,
        company_id: str,
        journal_id: str,
        id: Optional[str] = None,
        balancing_account_id: Optional[str] = None,
        balancing_account_number: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        journal_lines: Optional[List["models.MicrosoftGraphJournalLine"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property journals in financials.

        Update the navigation property journals in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param journal_id: key: id of journal.
        :type journal_id: str
        :param id: Read-only.
        :type id: str
        :param balancing_account_id:
        :type balancing_account_id: str
        :param balancing_account_number:
        :type balancing_account_number: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param journal_lines:
        :type journal_lines: list[~financials.models.MicrosoftGraphJournalLine]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphJournal(id=id, balancing_account_id=balancing_account_id, balancing_account_number=balancing_account_number, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, account=account, journal_lines=journal_lines)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'journal-id': self._serialize.url("journal_id", journal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphJournal')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_journal.metadata = {'url': '/financials/companies/{company-id}/journals/{journal-id}'}  # type: ignore

    async def delete_journal(
        self,
        company_id: str,
        journal_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property journals for financials.

        Delete navigation property journals for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param journal_id: key: id of journal.
        :type journal_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_journal.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'journal-id': self._serialize.url("journal_id", journal_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_journal.metadata = {'url': '/financials/companies/{company-id}/journals/{journal-id}'}  # type: ignore

    def list_payment_method(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum125"]]] = None,
        select: Optional[List[Union[str, "models.Enum126"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPaymentMethod"]:
        """Get paymentMethods from financials.

        Get paymentMethods from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum125]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum126]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPaymentMethod or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfPaymentMethod]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPaymentMethod"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_payment_method.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPaymentMethod', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_payment_method.metadata = {'url': '/financials/companies/{company-id}/paymentMethods'}  # type: ignore

    async def create_payment_method(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPaymentMethod":
        """Create new navigation property to paymentMethods for financials.

        Create new navigation property to paymentMethods for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPaymentMethod, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPaymentMethod
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPaymentMethod"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPaymentMethod(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_payment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPaymentMethod')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPaymentMethod', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_payment_method.metadata = {'url': '/financials/companies/{company-id}/paymentMethods'}  # type: ignore

    async def get_payment_method(
        self,
        company_id: str,
        payment_method_id: str,
        select: Optional[List[Union[str, "models.Enum127"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPaymentMethod":
        """Get paymentMethods from financials.

        Get paymentMethods from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param payment_method_id: key: id of paymentMethod.
        :type payment_method_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum127]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPaymentMethod, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPaymentMethod
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPaymentMethod"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_payment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'paymentMethod-id': self._serialize.url("payment_method_id", payment_method_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPaymentMethod', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_payment_method.metadata = {'url': '/financials/companies/{company-id}/paymentMethods/{paymentMethod-id}'}  # type: ignore

    async def update_payment_method(
        self,
        company_id: str,
        payment_method_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property paymentMethods in financials.

        Update the navigation property paymentMethods in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param payment_method_id: key: id of paymentMethod.
        :type payment_method_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPaymentMethod(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_payment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'paymentMethod-id': self._serialize.url("payment_method_id", payment_method_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPaymentMethod')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_payment_method.metadata = {'url': '/financials/companies/{company-id}/paymentMethods/{paymentMethod-id}'}  # type: ignore

    async def delete_payment_method(
        self,
        company_id: str,
        payment_method_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property paymentMethods for financials.

        Delete navigation property paymentMethods for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param payment_method_id: key: id of paymentMethod.
        :type payment_method_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_payment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'paymentMethod-id': self._serialize.url("payment_method_id", payment_method_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_payment_method.metadata = {'url': '/financials/companies/{company-id}/paymentMethods/{paymentMethod-id}'}  # type: ignore

    def list_payment_term(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum128"]]] = None,
        select: Optional[List[Union[str, "models.Enum129"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPaymentTerm"]:
        """Get paymentTerms from financials.

        Get paymentTerms from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum128]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum129]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPaymentTerm or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfPaymentTerm]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPaymentTerm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_payment_term.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPaymentTerm', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_payment_term.metadata = {'url': '/financials/companies/{company-id}/paymentTerms'}  # type: ignore

    async def create_payment_term(
        self,
        company_id: str,
        id: Optional[str] = None,
        calculate_discount_on_credit_memos: Optional[bool] = None,
        code: Optional[str] = None,
        discount_date_calculation: Optional[str] = None,
        discount_percent: Optional[float] = None,
        display_name: Optional[str] = None,
        due_date_calculation: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPaymentTerm":
        """Create new navigation property to paymentTerms for financials.

        Create new navigation property to paymentTerms for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param calculate_discount_on_credit_memos:
        :type calculate_discount_on_credit_memos: bool
        :param code:
        :type code: str
        :param discount_date_calculation:
        :type discount_date_calculation: str
        :param discount_percent:
        :type discount_percent: float
        :param display_name:
        :type display_name: str
        :param due_date_calculation:
        :type due_date_calculation: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPaymentTerm, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPaymentTerm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPaymentTerm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPaymentTerm(id=id, calculate_discount_on_credit_memos=calculate_discount_on_credit_memos, code=code, discount_date_calculation=discount_date_calculation, discount_percent=discount_percent, display_name=display_name, due_date_calculation=due_date_calculation, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_payment_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPaymentTerm')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPaymentTerm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_payment_term.metadata = {'url': '/financials/companies/{company-id}/paymentTerms'}  # type: ignore

    async def get_payment_term(
        self,
        company_id: str,
        payment_term_id: str,
        select: Optional[List[Union[str, "models.Enum130"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPaymentTerm":
        """Get paymentTerms from financials.

        Get paymentTerms from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param payment_term_id: key: id of paymentTerm.
        :type payment_term_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum130]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPaymentTerm, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPaymentTerm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPaymentTerm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_payment_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'paymentTerm-id': self._serialize.url("payment_term_id", payment_term_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPaymentTerm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_payment_term.metadata = {'url': '/financials/companies/{company-id}/paymentTerms/{paymentTerm-id}'}  # type: ignore

    async def update_payment_term(
        self,
        company_id: str,
        payment_term_id: str,
        id: Optional[str] = None,
        calculate_discount_on_credit_memos: Optional[bool] = None,
        code: Optional[str] = None,
        discount_date_calculation: Optional[str] = None,
        discount_percent: Optional[float] = None,
        display_name: Optional[str] = None,
        due_date_calculation: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property paymentTerms in financials.

        Update the navigation property paymentTerms in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param payment_term_id: key: id of paymentTerm.
        :type payment_term_id: str
        :param id: Read-only.
        :type id: str
        :param calculate_discount_on_credit_memos:
        :type calculate_discount_on_credit_memos: bool
        :param code:
        :type code: str
        :param discount_date_calculation:
        :type discount_date_calculation: str
        :param discount_percent:
        :type discount_percent: float
        :param display_name:
        :type display_name: str
        :param due_date_calculation:
        :type due_date_calculation: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPaymentTerm(id=id, calculate_discount_on_credit_memos=calculate_discount_on_credit_memos, code=code, discount_date_calculation=discount_date_calculation, discount_percent=discount_percent, display_name=display_name, due_date_calculation=due_date_calculation, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_payment_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'paymentTerm-id': self._serialize.url("payment_term_id", payment_term_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPaymentTerm')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_payment_term.metadata = {'url': '/financials/companies/{company-id}/paymentTerms/{paymentTerm-id}'}  # type: ignore

    async def delete_payment_term(
        self,
        company_id: str,
        payment_term_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property paymentTerms for financials.

        Delete navigation property paymentTerms for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param payment_term_id: key: id of paymentTerm.
        :type payment_term_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_payment_term.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'paymentTerm-id': self._serialize.url("payment_term_id", payment_term_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_payment_term.metadata = {'url': '/financials/companies/{company-id}/paymentTerms/{paymentTerm-id}'}  # type: ignore

    def list_picture(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum131"]]] = None,
        select: Optional[List[Union[str, "models.Enum132"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPicture4"]:
        """Get picture from financials.

        Get picture from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum131]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum132]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPicture4 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfPicture4]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPicture4"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_picture.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPicture4', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_picture.metadata = {'url': '/financials/companies/{company-id}/picture'}  # type: ignore

    async def create_picture(
        self,
        company_id: str,
        id: Optional[str] = None,
        content: Optional[bytes] = None,
        content_type_parameter: Optional[str] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPicture":
        """Create new navigation property to picture for financials.

        Create new navigation property to picture for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param content:
        :type content: bytes
        :param content_type_parameter:
        :type content_type_parameter: str
        :param height:
        :type height: int
        :param width:
        :type width: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPicture, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPicture
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPicture"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPicture(id=id, content=content, content_type=content_type_parameter, height=height, width=width)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_picture.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPicture')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPicture', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_picture.metadata = {'url': '/financials/companies/{company-id}/picture'}  # type: ignore

    async def get_picture(
        self,
        company_id: str,
        picture_id: str,
        select: Optional[List[Union[str, "models.Enum133"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPicture":
        """Get picture from financials.

        Get picture from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param picture_id: key: id of picture.
        :type picture_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum133]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPicture, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPicture
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPicture"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_picture.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'picture-id': self._serialize.url("picture_id", picture_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPicture', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_picture.metadata = {'url': '/financials/companies/{company-id}/picture/{picture-id}'}  # type: ignore

    async def update_picture(
        self,
        company_id: str,
        picture_id: str,
        id: Optional[str] = None,
        content: Optional[bytes] = None,
        content_type_parameter: Optional[str] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        **kwargs
    ) -> None:
        """Update the navigation property picture in financials.

        Update the navigation property picture in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param picture_id: key: id of picture.
        :type picture_id: str
        :param id: Read-only.
        :type id: str
        :param content:
        :type content: bytes
        :param content_type_parameter:
        :type content_type_parameter: str
        :param height:
        :type height: int
        :param width:
        :type width: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPicture(id=id, content=content, content_type=content_type_parameter, height=height, width=width)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_picture.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'picture-id': self._serialize.url("picture_id", picture_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPicture')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_picture.metadata = {'url': '/financials/companies/{company-id}/picture/{picture-id}'}  # type: ignore

    async def delete_picture(
        self,
        company_id: str,
        picture_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property picture for financials.

        Delete navigation property picture for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param picture_id: key: id of picture.
        :type picture_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_picture.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'picture-id': self._serialize.url("picture_id", picture_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_picture.metadata = {'url': '/financials/companies/{company-id}/picture/{picture-id}'}  # type: ignore

    async def get_picture_content(
        self,
        company_id: str,
        picture_id: str,
        **kwargs
    ) -> IO:
        """Get media content for the navigation property picture from financials.

        Get media content for the navigation property picture from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param picture_id: key: id of picture.
        :type picture_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/octet-stream, application/json"

        # Construct URL
        url = self.get_picture_content.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'picture-id': self._serialize.url("picture_id", picture_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_picture_content.metadata = {'url': '/financials/companies/{company-id}/picture/{picture-id}/content'}  # type: ignore

    async def set_picture_content(
        self,
        company_id: str,
        picture_id: str,
        data: IO,
        **kwargs
    ) -> None:
        """Update media content for the navigation property picture in financials.

        Update media content for the navigation property picture in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param picture_id: key: id of picture.
        :type picture_id: str
        :param data: New media content.
        :type data: IO
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")
        accept = "application/json"

        # Construct URL
        url = self.set_picture_content.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'picture-id': self._serialize.url("picture_id", picture_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content_kwargs['stream_content'] = data
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_picture_content.metadata = {'url': '/financials/companies/{company-id}/picture/{picture-id}/content'}  # type: ignore

    def list_purchase_invoice_line(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum134"]]] = None,
        select: Optional[List[Union[str, "models.Enum135"]]] = None,
        expand: Optional[List[Union[str, "models.Enum136"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPurchaseInvoiceLine"]:
        """Get purchaseInvoiceLines from financials.

        Get purchaseInvoiceLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum134]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum135]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum136]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPurchaseInvoiceLine or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfPurchaseInvoiceLine]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPurchaseInvoiceLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_purchase_invoice_line.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPurchaseInvoiceLine', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_purchase_invoice_line.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoiceLines'}  # type: ignore

    async def create_purchase_invoice_line(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        expected_receipt_date: Optional[datetime.date] = None,
        invoice_discount_allocation: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_cost: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        number_unit_cost: Optional[float] = None,
        unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPurchaseInvoiceLine":
        """Create new navigation property to purchaseInvoiceLines for financials.

        Create new navigation property to purchaseInvoiceLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param expected_receipt_date:
        :type expected_receipt_date: ~datetime.date
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_cost:
        :type unit_cost: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param number_unit_cost:
        :type number_unit_cost: float
        :param unit_price:
        :type unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPurchaseInvoiceLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPurchaseInvoiceLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPurchaseInvoiceLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPurchaseInvoiceLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, expected_receipt_date=expected_receipt_date, invoice_discount_allocation=invoice_discount_allocation, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_cost=unit_cost, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost_item_unit_cost=number_unit_cost, unit_price=unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_purchase_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPurchaseInvoiceLine')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPurchaseInvoiceLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_purchase_invoice_line.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoiceLines'}  # type: ignore

    async def get_purchase_invoice_line(
        self,
        company_id: str,
        purchase_invoice_line_id: str,
        select: Optional[List[Union[str, "models.Enum137"]]] = None,
        expand: Optional[List[Union[str, "models.Enum138"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPurchaseInvoiceLine":
        """Get purchaseInvoiceLines from financials.

        Get purchaseInvoiceLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param purchase_invoice_line_id: key: id of purchaseInvoiceLine.
        :type purchase_invoice_line_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum137]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum138]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPurchaseInvoiceLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPurchaseInvoiceLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPurchaseInvoiceLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_purchase_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'purchaseInvoiceLine-id': self._serialize.url("purchase_invoice_line_id", purchase_invoice_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPurchaseInvoiceLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_purchase_invoice_line.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoiceLines/{purchaseInvoiceLine-id}'}  # type: ignore

    async def update_purchase_invoice_line(
        self,
        company_id: str,
        purchase_invoice_line_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        expected_receipt_date: Optional[datetime.date] = None,
        invoice_discount_allocation: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_cost: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        number_unit_cost: Optional[float] = None,
        unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property purchaseInvoiceLines in financials.

        Update the navigation property purchaseInvoiceLines in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param purchase_invoice_line_id: key: id of purchaseInvoiceLine.
        :type purchase_invoice_line_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param expected_receipt_date:
        :type expected_receipt_date: ~datetime.date
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_cost:
        :type unit_cost: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param number_unit_cost:
        :type number_unit_cost: float
        :param unit_price:
        :type unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPurchaseInvoiceLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, expected_receipt_date=expected_receipt_date, invoice_discount_allocation=invoice_discount_allocation, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_cost=unit_cost, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost_item_unit_cost=number_unit_cost, unit_price=unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_purchase_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'purchaseInvoiceLine-id': self._serialize.url("purchase_invoice_line_id", purchase_invoice_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPurchaseInvoiceLine')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_purchase_invoice_line.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoiceLines/{purchaseInvoiceLine-id}'}  # type: ignore

    async def delete_purchase_invoice_line(
        self,
        company_id: str,
        purchase_invoice_line_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property purchaseInvoiceLines for financials.

        Delete navigation property purchaseInvoiceLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param purchase_invoice_line_id: key: id of purchaseInvoiceLine.
        :type purchase_invoice_line_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_purchase_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'purchaseInvoiceLine-id': self._serialize.url("purchase_invoice_line_id", purchase_invoice_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_purchase_invoice_line.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoiceLines/{purchaseInvoiceLine-id}'}  # type: ignore

    def list_purchase_invoice(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum146"]]] = None,
        select: Optional[List[Union[str, "models.Enum147"]]] = None,
        expand: Optional[List[Union[str, "models.Enum148"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPurchaseInvoice"]:
        """Get purchaseInvoices from financials.

        Get purchaseInvoices from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum146]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum147]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum148]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPurchaseInvoice or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfPurchaseInvoice]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPurchaseInvoice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_purchase_invoice.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPurchaseInvoice', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_purchase_invoice.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoices'}  # type: ignore

    async def create_purchase_invoice(
        self,
        company_id: str,
        id: Optional[str] = None,
        buy_from_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        due_date: Optional[datetime.date] = None,
        invoice_date: Optional[datetime.date] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        pay_to_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        pay_to_contact: Optional[str] = None,
        pay_to_name: Optional[str] = None,
        pay_to_vendor_id: Optional[str] = None,
        pay_to_vendor_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        ship_to_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        vendor_id: Optional[str] = None,
        vendor_invoice_number: Optional[str] = None,
        vendor_name: Optional[str] = None,
        vendor_number: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        purchase_invoice_lines: Optional[List["models.MicrosoftGraphPurchaseInvoiceLine"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        balance: Optional[float] = None,
        blocked: Optional[str] = None,
        microsoft_graph_vendor_currency_code: Optional[str] = None,
        microsoft_graph_vendor_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        microsoft_graph_vendor_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_vendor_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPurchaseInvoice":
        """Create new navigation property to purchaseInvoices for financials.

        Create new navigation property to purchaseInvoices for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param buy_from_address: postalAddressType.
        :type buy_from_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param due_date:
        :type due_date: ~datetime.date
        :param invoice_date:
        :type invoice_date: ~datetime.date
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param pay_to_address: postalAddressType.
        :type pay_to_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param pay_to_contact:
        :type pay_to_contact: str
        :param pay_to_name:
        :type pay_to_name: str
        :param pay_to_vendor_id:
        :type pay_to_vendor_id: str
        :param pay_to_vendor_number:
        :type pay_to_vendor_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param ship_to_address: postalAddressType.
        :type ship_to_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param vendor_id:
        :type vendor_id: str
        :param vendor_invoice_number:
        :type vendor_invoice_number: str
        :param vendor_name:
        :type vendor_name: str
        :param vendor_number:
        :type vendor_number: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param purchase_invoice_lines:
        :type purchase_invoice_lines: list[~financials.models.MicrosoftGraphPurchaseInvoiceLine]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param balance:
        :type balance: float
        :param blocked:
        :type blocked: str
        :param microsoft_graph_vendor_currency_code:
        :type microsoft_graph_vendor_currency_code: str
        :param microsoft_graph_vendor_currency_id:
        :type microsoft_graph_vendor_currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param microsoft_graph_vendor_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_vendor_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_vendor_number:
        :type microsoft_graph_vendor_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPurchaseInvoice, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPurchaseInvoice
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPurchaseInvoice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPurchaseInvoice(id=id, buy_from_address=buy_from_address, currency_code=currency_code, currency_id=currency_id, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, due_date=due_date, invoice_date=invoice_date, last_modified_date_time=last_modified_date_time, number=number, pay_to_address=pay_to_address, pay_to_contact=pay_to_contact, pay_to_name=pay_to_name, pay_to_vendor_id=pay_to_vendor_id, pay_to_vendor_number=pay_to_vendor_number, prices_include_tax=prices_include_tax, ship_to_address=ship_to_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, vendor_id=vendor_id, vendor_invoice_number=vendor_invoice_number, vendor_name=vendor_name, vendor_number=vendor_number, currency=currency, purchase_invoice_lines=purchase_invoice_lines, id_vendor_id=microsoft_graph_entity_id, address=address, balance=balance, blocked=blocked, currency_code_vendor_currency_code=microsoft_graph_vendor_currency_code, currency_id_vendor_currency_id=microsoft_graph_vendor_currency_id, display_name=display_name, email=email, last_modified_date_time_vendor_last_modified_date_time=microsoft_graph_vendor_last_modified_date_time_last_modified_date_time, number_vendor_number=microsoft_graph_vendor_number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, tax_liable=tax_liable, tax_registration_number=tax_registration_number, website=website, currency_vendor_currency=microsoft_graph_currency, payment_method=payment_method, payment_term=payment_term, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_purchase_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPurchaseInvoice')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPurchaseInvoice', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_purchase_invoice.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoices'}  # type: ignore

    async def get_purchase_invoice(
        self,
        company_id: str,
        purchase_invoice_id: str,
        select: Optional[List[Union[str, "models.Enum149"]]] = None,
        expand: Optional[List[Union[str, "models.Enum150"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPurchaseInvoice":
        """Get purchaseInvoices from financials.

        Get purchaseInvoices from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param purchase_invoice_id: key: id of purchaseInvoice.
        :type purchase_invoice_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum149]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum150]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPurchaseInvoice, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphPurchaseInvoice
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPurchaseInvoice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_purchase_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'purchaseInvoice-id': self._serialize.url("purchase_invoice_id", purchase_invoice_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPurchaseInvoice', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_purchase_invoice.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoices/{purchaseInvoice-id}'}  # type: ignore

    async def update_purchase_invoice(
        self,
        company_id: str,
        purchase_invoice_id: str,
        id: Optional[str] = None,
        buy_from_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        due_date: Optional[datetime.date] = None,
        invoice_date: Optional[datetime.date] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        pay_to_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        pay_to_contact: Optional[str] = None,
        pay_to_name: Optional[str] = None,
        pay_to_vendor_id: Optional[str] = None,
        pay_to_vendor_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        ship_to_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        vendor_id: Optional[str] = None,
        vendor_invoice_number: Optional[str] = None,
        vendor_name: Optional[str] = None,
        vendor_number: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        purchase_invoice_lines: Optional[List["models.MicrosoftGraphPurchaseInvoiceLine"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        balance: Optional[float] = None,
        blocked: Optional[str] = None,
        microsoft_graph_vendor_currency_code: Optional[str] = None,
        microsoft_graph_vendor_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        microsoft_graph_vendor_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_vendor_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property purchaseInvoices in financials.

        Update the navigation property purchaseInvoices in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param purchase_invoice_id: key: id of purchaseInvoice.
        :type purchase_invoice_id: str
        :param id: Read-only.
        :type id: str
        :param buy_from_address: postalAddressType.
        :type buy_from_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param due_date:
        :type due_date: ~datetime.date
        :param invoice_date:
        :type invoice_date: ~datetime.date
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param pay_to_address: postalAddressType.
        :type pay_to_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param pay_to_contact:
        :type pay_to_contact: str
        :param pay_to_name:
        :type pay_to_name: str
        :param pay_to_vendor_id:
        :type pay_to_vendor_id: str
        :param pay_to_vendor_number:
        :type pay_to_vendor_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param ship_to_address: postalAddressType.
        :type ship_to_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param vendor_id:
        :type vendor_id: str
        :param vendor_invoice_number:
        :type vendor_invoice_number: str
        :param vendor_name:
        :type vendor_name: str
        :param vendor_number:
        :type vendor_number: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param purchase_invoice_lines:
        :type purchase_invoice_lines: list[~financials.models.MicrosoftGraphPurchaseInvoiceLine]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param balance:
        :type balance: float
        :param blocked:
        :type blocked: str
        :param microsoft_graph_vendor_currency_code:
        :type microsoft_graph_vendor_currency_code: str
        :param microsoft_graph_vendor_currency_id:
        :type microsoft_graph_vendor_currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param microsoft_graph_vendor_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_vendor_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_vendor_number:
        :type microsoft_graph_vendor_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphPurchaseInvoice(id=id, buy_from_address=buy_from_address, currency_code=currency_code, currency_id=currency_id, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, due_date=due_date, invoice_date=invoice_date, last_modified_date_time=last_modified_date_time, number=number, pay_to_address=pay_to_address, pay_to_contact=pay_to_contact, pay_to_name=pay_to_name, pay_to_vendor_id=pay_to_vendor_id, pay_to_vendor_number=pay_to_vendor_number, prices_include_tax=prices_include_tax, ship_to_address=ship_to_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, vendor_id=vendor_id, vendor_invoice_number=vendor_invoice_number, vendor_name=vendor_name, vendor_number=vendor_number, currency=currency, purchase_invoice_lines=purchase_invoice_lines, id_vendor_id=microsoft_graph_entity_id, address=address, balance=balance, blocked=blocked, currency_code_vendor_currency_code=microsoft_graph_vendor_currency_code, currency_id_vendor_currency_id=microsoft_graph_vendor_currency_id, display_name=display_name, email=email, last_modified_date_time_vendor_last_modified_date_time=microsoft_graph_vendor_last_modified_date_time_last_modified_date_time, number_vendor_number=microsoft_graph_vendor_number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, tax_liable=tax_liable, tax_registration_number=tax_registration_number, website=website, currency_vendor_currency=microsoft_graph_currency, payment_method=payment_method, payment_term=payment_term, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_purchase_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'purchaseInvoice-id': self._serialize.url("purchase_invoice_id", purchase_invoice_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphPurchaseInvoice')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_purchase_invoice.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoices/{purchaseInvoice-id}'}  # type: ignore

    async def delete_purchase_invoice(
        self,
        company_id: str,
        purchase_invoice_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property purchaseInvoices for financials.

        Delete navigation property purchaseInvoices for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param purchase_invoice_id: key: id of purchaseInvoice.
        :type purchase_invoice_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_purchase_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'purchaseInvoice-id': self._serialize.url("purchase_invoice_id", purchase_invoice_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_purchase_invoice.metadata = {'url': '/financials/companies/{company-id}/purchaseInvoices/{purchaseInvoice-id}'}  # type: ignore

    def list_sale_credit_memo_line(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum172"]]] = None,
        select: Optional[List[Union[str, "models.Enum173"]]] = None,
        expand: Optional[List[Union[str, "models.Enum174"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesCreditMemoLine"]:
        """Get salesCreditMemoLines from financials.

        Get salesCreditMemoLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum172]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum173]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum174]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesCreditMemoLine or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesCreditMemoLine]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesCreditMemoLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_credit_memo_line.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesCreditMemoLine', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_credit_memo_line.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemoLines'}  # type: ignore

    async def create_sale_credit_memo_line(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        invoice_discount_allocation: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        shipment_date: Optional[datetime.date] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesCreditMemoLine":
        """Create new navigation property to salesCreditMemoLines for financials.

        Create new navigation property to salesCreditMemoLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param shipment_date:
        :type shipment_date: ~datetime.date
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesCreditMemoLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesCreditMemoLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesCreditMemoLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesCreditMemoLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, invoice_discount_allocation=invoice_discount_allocation, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, shipment_date=shipment_date, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_credit_memo_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesCreditMemoLine')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesCreditMemoLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_credit_memo_line.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemoLines'}  # type: ignore

    async def get_sale_credit_memo_line(
        self,
        company_id: str,
        sales_credit_memo_line_id: str,
        select: Optional[List[Union[str, "models.Enum175"]]] = None,
        expand: Optional[List[Union[str, "models.Enum176"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesCreditMemoLine":
        """Get salesCreditMemoLines from financials.

        Get salesCreditMemoLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_credit_memo_line_id: key: id of salesCreditMemoLine.
        :type sales_credit_memo_line_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum175]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum176]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesCreditMemoLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesCreditMemoLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesCreditMemoLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_credit_memo_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesCreditMemoLine-id': self._serialize.url("sales_credit_memo_line_id", sales_credit_memo_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesCreditMemoLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_credit_memo_line.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemoLines/{salesCreditMemoLine-id}'}  # type: ignore

    async def update_sale_credit_memo_line(
        self,
        company_id: str,
        sales_credit_memo_line_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        invoice_discount_allocation: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        shipment_date: Optional[datetime.date] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesCreditMemoLines in financials.

        Update the navigation property salesCreditMemoLines in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_credit_memo_line_id: key: id of salesCreditMemoLine.
        :type sales_credit_memo_line_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param shipment_date:
        :type shipment_date: ~datetime.date
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesCreditMemoLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, invoice_discount_allocation=invoice_discount_allocation, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, shipment_date=shipment_date, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_credit_memo_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesCreditMemoLine-id': self._serialize.url("sales_credit_memo_line_id", sales_credit_memo_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesCreditMemoLine')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_credit_memo_line.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemoLines/{salesCreditMemoLine-id}'}  # type: ignore

    async def delete_sale_credit_memo_line(
        self,
        company_id: str,
        sales_credit_memo_line_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesCreditMemoLines for financials.

        Delete navigation property salesCreditMemoLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_credit_memo_line_id: key: id of salesCreditMemoLine.
        :type sales_credit_memo_line_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_credit_memo_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesCreditMemoLine-id': self._serialize.url("sales_credit_memo_line_id", sales_credit_memo_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_credit_memo_line.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemoLines/{salesCreditMemoLine-id}'}  # type: ignore

    def list_sale_credit_memo(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum184"]]] = None,
        select: Optional[List[Union[str, "models.Enum185"]]] = None,
        expand: Optional[List[Union[str, "models.Enum186"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesCreditMemo"]:
        """Get salesCreditMemos from financials.

        Get salesCreditMemos from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum184]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum185]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum186]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesCreditMemo or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesCreditMemo]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesCreditMemo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_credit_memo.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesCreditMemo', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_credit_memo.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemos'}  # type: ignore

    async def create_sale_credit_memo(
        self,
        company_id: str,
        id: Optional[str] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        credit_memo_date: Optional[datetime.date] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        due_date: Optional[datetime.date] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        invoice_id: Optional[str] = None,
        invoice_number: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_credit_memo_lines: Optional[List["models.MicrosoftGraphSalesCreditMemoLine"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesCreditMemo":
        """Create new navigation property to salesCreditMemos for financials.

        Create new navigation property to salesCreditMemos for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param credit_memo_date:
        :type credit_memo_date: ~datetime.date
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param due_date:
        :type due_date: ~datetime.date
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param invoice_id:
        :type invoice_id: str
        :param invoice_number:
        :type invoice_number: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_credit_memo_lines:
        :type sales_credit_memo_lines: list[~financials.models.MicrosoftGraphSalesCreditMemoLine]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesCreditMemo, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesCreditMemo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesCreditMemo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesCreditMemo(id=id, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, credit_memo_date=credit_memo_date, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, due_date=due_date, email=email, external_document_number=external_document_number, invoice_id=invoice_id, invoice_number=invoice_number, last_modified_date_time=last_modified_date_time, number=number, payment_terms_id=payment_terms_id, phone_number=phone_number, prices_include_tax=prices_include_tax, salesperson=salesperson, selling_postal_address=selling_postal_address, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, currency=currency, payment_term=payment_term, sales_credit_memo_lines=sales_credit_memo_lines, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_credit_memo.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesCreditMemo')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesCreditMemo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_credit_memo.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemos'}  # type: ignore

    async def get_sale_credit_memo(
        self,
        company_id: str,
        sales_credit_memo_id: str,
        select: Optional[List[Union[str, "models.Enum187"]]] = None,
        expand: Optional[List[Union[str, "models.Enum188"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesCreditMemo":
        """Get salesCreditMemos from financials.

        Get salesCreditMemos from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_credit_memo_id: key: id of salesCreditMemo.
        :type sales_credit_memo_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum187]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum188]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesCreditMemo, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesCreditMemo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesCreditMemo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_credit_memo.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesCreditMemo-id': self._serialize.url("sales_credit_memo_id", sales_credit_memo_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesCreditMemo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_credit_memo.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemos/{salesCreditMemo-id}'}  # type: ignore

    async def update_sale_credit_memo(
        self,
        company_id: str,
        sales_credit_memo_id: str,
        id: Optional[str] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        credit_memo_date: Optional[datetime.date] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        due_date: Optional[datetime.date] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        invoice_id: Optional[str] = None,
        invoice_number: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_credit_memo_lines: Optional[List["models.MicrosoftGraphSalesCreditMemoLine"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesCreditMemos in financials.

        Update the navigation property salesCreditMemos in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_credit_memo_id: key: id of salesCreditMemo.
        :type sales_credit_memo_id: str
        :param id: Read-only.
        :type id: str
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param credit_memo_date:
        :type credit_memo_date: ~datetime.date
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param due_date:
        :type due_date: ~datetime.date
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param invoice_id:
        :type invoice_id: str
        :param invoice_number:
        :type invoice_number: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_credit_memo_lines:
        :type sales_credit_memo_lines: list[~financials.models.MicrosoftGraphSalesCreditMemoLine]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesCreditMemo(id=id, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, credit_memo_date=credit_memo_date, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, due_date=due_date, email=email, external_document_number=external_document_number, invoice_id=invoice_id, invoice_number=invoice_number, last_modified_date_time=last_modified_date_time, number=number, payment_terms_id=payment_terms_id, phone_number=phone_number, prices_include_tax=prices_include_tax, salesperson=salesperson, selling_postal_address=selling_postal_address, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, currency=currency, payment_term=payment_term, sales_credit_memo_lines=sales_credit_memo_lines, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_credit_memo.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesCreditMemo-id': self._serialize.url("sales_credit_memo_id", sales_credit_memo_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesCreditMemo')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_credit_memo.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemos/{salesCreditMemo-id}'}  # type: ignore

    async def delete_sale_credit_memo(
        self,
        company_id: str,
        sales_credit_memo_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesCreditMemos for financials.

        Delete navigation property salesCreditMemos for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_credit_memo_id: key: id of salesCreditMemo.
        :type sales_credit_memo_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_credit_memo.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesCreditMemo-id': self._serialize.url("sales_credit_memo_id", sales_credit_memo_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_credit_memo.metadata = {'url': '/financials/companies/{company-id}/salesCreditMemos/{salesCreditMemo-id}'}  # type: ignore

    def list_sale_invoice_line(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum212"]]] = None,
        select: Optional[List[Union[str, "models.Enum213"]]] = None,
        expand: Optional[List[Union[str, "models.Enum214"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesInvoiceLine"]:
        """Get salesInvoiceLines from financials.

        Get salesInvoiceLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum212]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum213]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum214]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesInvoiceLine or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesInvoiceLine]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesInvoiceLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_invoice_line.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesInvoiceLine', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_invoice_line.metadata = {'url': '/financials/companies/{company-id}/salesInvoiceLines'}  # type: ignore

    async def create_sale_invoice_line(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        invoice_discount_allocation: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        shipment_date: Optional[datetime.date] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesInvoiceLine":
        """Create new navigation property to salesInvoiceLines for financials.

        Create new navigation property to salesInvoiceLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param shipment_date:
        :type shipment_date: ~datetime.date
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesInvoiceLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesInvoiceLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesInvoiceLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesInvoiceLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, invoice_discount_allocation=invoice_discount_allocation, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, shipment_date=shipment_date, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesInvoiceLine')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesInvoiceLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_invoice_line.metadata = {'url': '/financials/companies/{company-id}/salesInvoiceLines'}  # type: ignore

    async def get_sale_invoice_line(
        self,
        company_id: str,
        sales_invoice_line_id: str,
        select: Optional[List[Union[str, "models.Enum215"]]] = None,
        expand: Optional[List[Union[str, "models.Enum216"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesInvoiceLine":
        """Get salesInvoiceLines from financials.

        Get salesInvoiceLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_invoice_line_id: key: id of salesInvoiceLine.
        :type sales_invoice_line_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum215]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum216]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesInvoiceLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesInvoiceLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesInvoiceLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesInvoiceLine-id': self._serialize.url("sales_invoice_line_id", sales_invoice_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesInvoiceLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_invoice_line.metadata = {'url': '/financials/companies/{company-id}/salesInvoiceLines/{salesInvoiceLine-id}'}  # type: ignore

    async def update_sale_invoice_line(
        self,
        company_id: str,
        sales_invoice_line_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        invoice_discount_allocation: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        shipment_date: Optional[datetime.date] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesInvoiceLines in financials.

        Update the navigation property salesInvoiceLines in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_invoice_line_id: key: id of salesInvoiceLine.
        :type sales_invoice_line_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param shipment_date:
        :type shipment_date: ~datetime.date
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesInvoiceLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, invoice_discount_allocation=invoice_discount_allocation, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, shipment_date=shipment_date, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesInvoiceLine-id': self._serialize.url("sales_invoice_line_id", sales_invoice_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesInvoiceLine')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_invoice_line.metadata = {'url': '/financials/companies/{company-id}/salesInvoiceLines/{salesInvoiceLine-id}'}  # type: ignore

    async def delete_sale_invoice_line(
        self,
        company_id: str,
        sales_invoice_line_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesInvoiceLines for financials.

        Delete navigation property salesInvoiceLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_invoice_line_id: key: id of salesInvoiceLine.
        :type sales_invoice_line_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_invoice_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesInvoiceLine-id': self._serialize.url("sales_invoice_line_id", sales_invoice_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_invoice_line.metadata = {'url': '/financials/companies/{company-id}/salesInvoiceLines/{salesInvoiceLine-id}'}  # type: ignore

    def list_sale_invoice(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum224"]]] = None,
        select: Optional[List[Union[str, "models.Enum225"]]] = None,
        expand: Optional[List[Union[str, "models.Enum226"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesInvoice"]:
        """Get salesInvoices from financials.

        Get salesInvoices from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum224]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum225]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum226]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesInvoice or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesInvoice]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesInvoice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_invoice.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesInvoice', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_invoice.metadata = {'url': '/financials/companies/{company-id}/salesInvoices'}  # type: ignore

    async def create_sale_invoice(
        self,
        company_id: str,
        id: Optional[str] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        customer_purchase_order_reference: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        due_date: Optional[datetime.date] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        invoice_date: Optional[datetime.date] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        order_id: Optional[str] = None,
        order_number: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        shipment_method_id: Optional[str] = None,
        shipping_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_invoice_lines: Optional[List["models.MicrosoftGraphSalesInvoiceLine"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        microsoft_graph_customer_shipment_method_id_shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        microsoft_graph_shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesInvoice":
        """Create new navigation property to salesInvoices for financials.

        Create new navigation property to salesInvoices for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param customer_purchase_order_reference:
        :type customer_purchase_order_reference: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param due_date:
        :type due_date: ~datetime.date
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param invoice_date:
        :type invoice_date: ~datetime.date
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param order_id:
        :type order_id: str
        :param order_number:
        :type order_number: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param shipment_method_id:
        :type shipment_method_id: str
        :param shipping_postal_address: postalAddressType.
        :type shipping_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_invoice_lines:
        :type sales_invoice_lines: list[~financials.models.MicrosoftGraphSalesInvoiceLine]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param microsoft_graph_customer_shipment_method_id_shipment_method_id:
        :type microsoft_graph_customer_shipment_method_id_shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param microsoft_graph_shipment_method: shipmentMethod.
        :type microsoft_graph_shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesInvoice, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesInvoice
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesInvoice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesInvoice(id=id, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, customer_purchase_order_reference=customer_purchase_order_reference, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, due_date=due_date, email=email, external_document_number=external_document_number, invoice_date=invoice_date, last_modified_date_time=last_modified_date_time, number=number, order_id=order_id, order_number=order_number, payment_terms_id=payment_terms_id, phone_number=phone_number, prices_include_tax=prices_include_tax, salesperson=salesperson, selling_postal_address=selling_postal_address, shipment_method_id=shipment_method_id, shipping_postal_address=shipping_postal_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, currency=currency, payment_term=payment_term, sales_invoice_lines=sales_invoice_lines, shipment_method=shipment_method, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id_customer_shipment_method_id=microsoft_graph_customer_shipment_method_id_shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method_customer_shipment_method=microsoft_graph_shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesInvoice')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesInvoice', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_invoice.metadata = {'url': '/financials/companies/{company-id}/salesInvoices'}  # type: ignore

    async def get_sale_invoice(
        self,
        company_id: str,
        sales_invoice_id: str,
        select: Optional[List[Union[str, "models.Enum227"]]] = None,
        expand: Optional[List[Union[str, "models.Enum228"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesInvoice":
        """Get salesInvoices from financials.

        Get salesInvoices from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_invoice_id: key: id of salesInvoice.
        :type sales_invoice_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum227]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum228]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesInvoice, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesInvoice
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesInvoice"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesInvoice-id': self._serialize.url("sales_invoice_id", sales_invoice_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesInvoice', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_invoice.metadata = {'url': '/financials/companies/{company-id}/salesInvoices/{salesInvoice-id}'}  # type: ignore

    async def update_sale_invoice(
        self,
        company_id: str,
        sales_invoice_id: str,
        id: Optional[str] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        customer_purchase_order_reference: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        due_date: Optional[datetime.date] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        invoice_date: Optional[datetime.date] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        order_id: Optional[str] = None,
        order_number: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        shipment_method_id: Optional[str] = None,
        shipping_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_invoice_lines: Optional[List["models.MicrosoftGraphSalesInvoiceLine"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        microsoft_graph_customer_shipment_method_id_shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        microsoft_graph_shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesInvoices in financials.

        Update the navigation property salesInvoices in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_invoice_id: key: id of salesInvoice.
        :type sales_invoice_id: str
        :param id: Read-only.
        :type id: str
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param customer_purchase_order_reference:
        :type customer_purchase_order_reference: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param due_date:
        :type due_date: ~datetime.date
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param invoice_date:
        :type invoice_date: ~datetime.date
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param order_id:
        :type order_id: str
        :param order_number:
        :type order_number: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param shipment_method_id:
        :type shipment_method_id: str
        :param shipping_postal_address: postalAddressType.
        :type shipping_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_invoice_lines:
        :type sales_invoice_lines: list[~financials.models.MicrosoftGraphSalesInvoiceLine]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param microsoft_graph_customer_shipment_method_id_shipment_method_id:
        :type microsoft_graph_customer_shipment_method_id_shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param microsoft_graph_shipment_method: shipmentMethod.
        :type microsoft_graph_shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesInvoice(id=id, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, customer_purchase_order_reference=customer_purchase_order_reference, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, due_date=due_date, email=email, external_document_number=external_document_number, invoice_date=invoice_date, last_modified_date_time=last_modified_date_time, number=number, order_id=order_id, order_number=order_number, payment_terms_id=payment_terms_id, phone_number=phone_number, prices_include_tax=prices_include_tax, salesperson=salesperson, selling_postal_address=selling_postal_address, shipment_method_id=shipment_method_id, shipping_postal_address=shipping_postal_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, currency=currency, payment_term=payment_term, sales_invoice_lines=sales_invoice_lines, shipment_method=shipment_method, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id_customer_shipment_method_id=microsoft_graph_customer_shipment_method_id_shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method_customer_shipment_method=microsoft_graph_shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesInvoice-id': self._serialize.url("sales_invoice_id", sales_invoice_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesInvoice')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_invoice.metadata = {'url': '/financials/companies/{company-id}/salesInvoices/{salesInvoice-id}'}  # type: ignore

    async def delete_sale_invoice(
        self,
        company_id: str,
        sales_invoice_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesInvoices for financials.

        Delete navigation property salesInvoices for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_invoice_id: key: id of salesInvoice.
        :type sales_invoice_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_invoice.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesInvoice-id': self._serialize.url("sales_invoice_id", sales_invoice_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_invoice.metadata = {'url': '/financials/companies/{company-id}/salesInvoices/{salesInvoice-id}'}  # type: ignore

    def list_sale_order_line(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum253"]]] = None,
        select: Optional[List[Union[str, "models.Enum254"]]] = None,
        expand: Optional[List[Union[str, "models.Enum255"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesOrderLine"]:
        """Get salesOrderLines from financials.

        Get salesOrderLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum253]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum254]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum255]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesOrderLine or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesOrderLine]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesOrderLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_order_line.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesOrderLine', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_order_line.metadata = {'url': '/financials/companies/{company-id}/salesOrderLines'}  # type: ignore

    async def create_sale_order_line(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        invoice_discount_allocation: Optional[float] = None,
        invoiced_quantity: Optional[float] = None,
        invoice_quantity: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        shipment_date: Optional[datetime.date] = None,
        shipped_quantity: Optional[float] = None,
        ship_quantity: Optional[float] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesOrderLine":
        """Create new navigation property to salesOrderLines for financials.

        Create new navigation property to salesOrderLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param invoiced_quantity:
        :type invoiced_quantity: float
        :param invoice_quantity:
        :type invoice_quantity: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param shipment_date:
        :type shipment_date: ~datetime.date
        :param shipped_quantity:
        :type shipped_quantity: float
        :param ship_quantity:
        :type ship_quantity: float
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesOrderLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesOrderLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesOrderLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesOrderLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, invoice_discount_allocation=invoice_discount_allocation, invoiced_quantity=invoiced_quantity, invoice_quantity=invoice_quantity, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, shipment_date=shipment_date, shipped_quantity=shipped_quantity, ship_quantity=ship_quantity, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_order_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesOrderLine')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesOrderLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_order_line.metadata = {'url': '/financials/companies/{company-id}/salesOrderLines'}  # type: ignore

    async def get_sale_order_line(
        self,
        company_id: str,
        sales_order_line_id: str,
        select: Optional[List[Union[str, "models.Enum256"]]] = None,
        expand: Optional[List[Union[str, "models.Enum257"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesOrderLine":
        """Get salesOrderLines from financials.

        Get salesOrderLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_order_line_id: key: id of salesOrderLine.
        :type sales_order_line_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum256]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum257]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesOrderLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesOrderLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesOrderLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_order_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesOrderLine-id': self._serialize.url("sales_order_line_id", sales_order_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesOrderLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_order_line.metadata = {'url': '/financials/companies/{company-id}/salesOrderLines/{salesOrderLine-id}'}  # type: ignore

    async def update_sale_order_line(
        self,
        company_id: str,
        sales_order_line_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        invoice_discount_allocation: Optional[float] = None,
        invoiced_quantity: Optional[float] = None,
        invoice_quantity: Optional[float] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        shipment_date: Optional[datetime.date] = None,
        shipped_quantity: Optional[float] = None,
        ship_quantity: Optional[float] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesOrderLines in financials.

        Update the navigation property salesOrderLines in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_order_line_id: key: id of salesOrderLine.
        :type sales_order_line_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param invoice_discount_allocation:
        :type invoice_discount_allocation: float
        :param invoiced_quantity:
        :type invoiced_quantity: float
        :param invoice_quantity:
        :type invoice_quantity: float
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param shipment_date:
        :type shipment_date: ~datetime.date
        :param shipped_quantity:
        :type shipped_quantity: float
        :param ship_quantity:
        :type ship_quantity: float
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesOrderLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, invoice_discount_allocation=invoice_discount_allocation, invoiced_quantity=invoiced_quantity, invoice_quantity=invoice_quantity, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, shipment_date=shipment_date, shipped_quantity=shipped_quantity, ship_quantity=ship_quantity, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_order_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesOrderLine-id': self._serialize.url("sales_order_line_id", sales_order_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesOrderLine')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_order_line.metadata = {'url': '/financials/companies/{company-id}/salesOrderLines/{salesOrderLine-id}'}  # type: ignore

    async def delete_sale_order_line(
        self,
        company_id: str,
        sales_order_line_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesOrderLines for financials.

        Delete navigation property salesOrderLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_order_line_id: key: id of salesOrderLine.
        :type sales_order_line_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_order_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesOrderLine-id': self._serialize.url("sales_order_line_id", sales_order_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_order_line.metadata = {'url': '/financials/companies/{company-id}/salesOrderLines/{salesOrderLine-id}'}  # type: ignore

    def list_sale_order(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum265"]]] = None,
        select: Optional[List[Union[str, "models.Enum266"]]] = None,
        expand: Optional[List[Union[str, "models.Enum267"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesOrder"]:
        """Get salesOrders from financials.

        Get salesOrders from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum265]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum266]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum267]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesOrder or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesOrder]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesOrder"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_order.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesOrder', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_order.metadata = {'url': '/financials/companies/{company-id}/salesOrders'}  # type: ignore

    async def create_sale_order(
        self,
        company_id: str,
        id: Optional[str] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        fully_shipped: Optional[bool] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        order_date: Optional[datetime.date] = None,
        partial_shipping: Optional[bool] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        requested_delivery_date: Optional[datetime.date] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        shipping_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_order_lines: Optional[List["models.MicrosoftGraphSalesOrderLine"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesOrder":
        """Create new navigation property to salesOrders for financials.

        Create new navigation property to salesOrders for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param fully_shipped:
        :type fully_shipped: bool
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param order_date:
        :type order_date: ~datetime.date
        :param partial_shipping:
        :type partial_shipping: bool
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param requested_delivery_date:
        :type requested_delivery_date: ~datetime.date
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param shipping_postal_address: postalAddressType.
        :type shipping_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_order_lines:
        :type sales_order_lines: list[~financials.models.MicrosoftGraphSalesOrderLine]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesOrder, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesOrder
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesOrder"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesOrder(id=id, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, email=email, external_document_number=external_document_number, fully_shipped=fully_shipped, last_modified_date_time=last_modified_date_time, number=number, order_date=order_date, partial_shipping=partial_shipping, payment_terms_id=payment_terms_id, phone_number=phone_number, prices_include_tax=prices_include_tax, requested_delivery_date=requested_delivery_date, salesperson=salesperson, selling_postal_address=selling_postal_address, shipping_postal_address=shipping_postal_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, currency=currency, payment_term=payment_term, sales_order_lines=sales_order_lines, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_order.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesOrder')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesOrder', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_order.metadata = {'url': '/financials/companies/{company-id}/salesOrders'}  # type: ignore

    async def get_sale_order(
        self,
        company_id: str,
        sales_order_id: str,
        select: Optional[List[Union[str, "models.Enum268"]]] = None,
        expand: Optional[List[Union[str, "models.Enum269"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesOrder":
        """Get salesOrders from financials.

        Get salesOrders from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_order_id: key: id of salesOrder.
        :type sales_order_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum268]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum269]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesOrder, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesOrder
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesOrder"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_order.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesOrder-id': self._serialize.url("sales_order_id", sales_order_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesOrder', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_order.metadata = {'url': '/financials/companies/{company-id}/salesOrders/{salesOrder-id}'}  # type: ignore

    async def update_sale_order(
        self,
        company_id: str,
        sales_order_id: str,
        id: Optional[str] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        fully_shipped: Optional[bool] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        order_date: Optional[datetime.date] = None,
        partial_shipping: Optional[bool] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        prices_include_tax: Optional[bool] = None,
        requested_delivery_date: Optional[datetime.date] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        shipping_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_order_lines: Optional[List["models.MicrosoftGraphSalesOrderLine"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesOrders in financials.

        Update the navigation property salesOrders in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_order_id: key: id of salesOrder.
        :type sales_order_id: str
        :param id: Read-only.
        :type id: str
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param fully_shipped:
        :type fully_shipped: bool
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param order_date:
        :type order_date: ~datetime.date
        :param partial_shipping:
        :type partial_shipping: bool
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param prices_include_tax:
        :type prices_include_tax: bool
        :param requested_delivery_date:
        :type requested_delivery_date: ~datetime.date
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param shipping_postal_address: postalAddressType.
        :type shipping_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_order_lines:
        :type sales_order_lines: list[~financials.models.MicrosoftGraphSalesOrderLine]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param shipment_method_id:
        :type shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesOrder(id=id, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, email=email, external_document_number=external_document_number, fully_shipped=fully_shipped, last_modified_date_time=last_modified_date_time, number=number, order_date=order_date, partial_shipping=partial_shipping, payment_terms_id=payment_terms_id, phone_number=phone_number, prices_include_tax=prices_include_tax, requested_delivery_date=requested_delivery_date, salesperson=salesperson, selling_postal_address=selling_postal_address, shipping_postal_address=shipping_postal_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, currency=currency, payment_term=payment_term, sales_order_lines=sales_order_lines, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id=shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method=shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_order.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesOrder-id': self._serialize.url("sales_order_id", sales_order_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesOrder')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_order.metadata = {'url': '/financials/companies/{company-id}/salesOrders/{salesOrder-id}'}  # type: ignore

    async def delete_sale_order(
        self,
        company_id: str,
        sales_order_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesOrders for financials.

        Delete navigation property salesOrders for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_order_id: key: id of salesOrder.
        :type sales_order_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_order.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesOrder-id': self._serialize.url("sales_order_id", sales_order_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_order.metadata = {'url': '/financials/companies/{company-id}/salesOrders/{salesOrder-id}'}  # type: ignore

    def list_sale_quote_line(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum293"]]] = None,
        select: Optional[List[Union[str, "models.Enum294"]]] = None,
        expand: Optional[List[Union[str, "models.Enum295"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesQuoteLine"]:
        """Get salesQuoteLines from financials.

        Get salesQuoteLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum293]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum294]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum295]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesQuoteLine or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesQuoteLine]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesQuoteLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_quote_line.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesQuoteLine', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_quote_line.metadata = {'url': '/financials/companies/{company-id}/salesQuoteLines'}  # type: ignore

    async def create_sale_quote_line(
        self,
        company_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesQuoteLine":
        """Create new navigation property to salesQuoteLines for financials.

        Create new navigation property to salesQuoteLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesQuoteLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesQuoteLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesQuoteLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesQuoteLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_quote_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesQuoteLine')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesQuoteLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_quote_line.metadata = {'url': '/financials/companies/{company-id}/salesQuoteLines'}  # type: ignore

    async def get_sale_quote_line(
        self,
        company_id: str,
        sales_quote_line_id: str,
        select: Optional[List[Union[str, "models.Enum296"]]] = None,
        expand: Optional[List[Union[str, "models.Enum297"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesQuoteLine":
        """Get salesQuoteLines from financials.

        Get salesQuoteLines from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_quote_line_id: key: id of salesQuoteLine.
        :type sales_quote_line_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum296]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum297]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesQuoteLine, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesQuoteLine
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesQuoteLine"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_quote_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesQuoteLine-id': self._serialize.url("sales_quote_line_id", sales_quote_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesQuoteLine', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_quote_line.metadata = {'url': '/financials/companies/{company-id}/salesQuoteLines/{salesQuoteLine-id}'}  # type: ignore

    async def update_sale_quote_line(
        self,
        company_id: str,
        sales_quote_line_id: str,
        id: Optional[str] = None,
        account_id: Optional[str] = None,
        amount_excluding_tax: Optional[float] = None,
        amount_including_tax: Optional[float] = None,
        description: Optional[str] = None,
        discount_amount: Optional[float] = None,
        discount_applied_before_tax: Optional[bool] = None,
        discount_percent: Optional[float] = None,
        document_id: Optional[str] = None,
        item_id: Optional[str] = None,
        line_type: Optional[str] = None,
        net_amount: Optional[float] = None,
        net_amount_including_tax: Optional[float] = None,
        net_tax_amount: Optional[float] = None,
        quantity: Optional[float] = None,
        sequence: Optional[int] = None,
        tax_code: Optional[str] = None,
        tax_percent: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        unit_of_measure_id: Optional[str] = None,
        unit_price: Optional[float] = None,
        account: Optional["models.MicrosoftGraphAccount"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        base_unit_of_measure_id: Optional[str] = None,
        blocked: Optional[bool] = None,
        display_name: Optional[str] = None,
        gtin: Optional[str] = None,
        inventory: Optional[float] = None,
        item_category_code: Optional[str] = None,
        item_category_id: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        price_includes_tax: Optional[bool] = None,
        tax_group_code: Optional[str] = None,
        tax_group_id: Optional[str] = None,
        type: Optional[str] = None,
        unit_cost: Optional[float] = None,
        number_unit_price: Optional[float] = None,
        item_category: Optional["models.MicrosoftGraphItemCategory"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesQuoteLines in financials.

        Update the navigation property salesQuoteLines in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_quote_line_id: key: id of salesQuoteLine.
        :type sales_quote_line_id: str
        :param id: Read-only.
        :type id: str
        :param account_id:
        :type account_id: str
        :param amount_excluding_tax:
        :type amount_excluding_tax: float
        :param amount_including_tax:
        :type amount_including_tax: float
        :param description:
        :type description: str
        :param discount_amount:
        :type discount_amount: float
        :param discount_applied_before_tax:
        :type discount_applied_before_tax: bool
        :param discount_percent:
        :type discount_percent: float
        :param document_id:
        :type document_id: str
        :param item_id:
        :type item_id: str
        :param line_type:
        :type line_type: str
        :param net_amount:
        :type net_amount: float
        :param net_amount_including_tax:
        :type net_amount_including_tax: float
        :param net_tax_amount:
        :type net_tax_amount: float
        :param quantity:
        :type quantity: float
        :param sequence:
        :type sequence: int
        :param tax_code:
        :type tax_code: str
        :param tax_percent:
        :type tax_percent: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param unit_of_measure_id:
        :type unit_of_measure_id: str
        :param unit_price:
        :type unit_price: float
        :param account: account.
        :type account: ~financials.models.MicrosoftGraphAccount
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param base_unit_of_measure_id:
        :type base_unit_of_measure_id: str
        :param blocked:
        :type blocked: bool
        :param display_name:
        :type display_name: str
        :param gtin:
        :type gtin: str
        :param inventory:
        :type inventory: float
        :param item_category_code:
        :type item_category_code: str
        :param item_category_id:
        :type item_category_id: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param price_includes_tax:
        :type price_includes_tax: bool
        :param tax_group_code:
        :type tax_group_code: str
        :param tax_group_id:
        :type tax_group_id: str
        :param type:
        :type type: str
        :param unit_cost:
        :type unit_cost: float
        :param number_unit_price:
        :type number_unit_price: float
        :param item_category: itemCategory.
        :type item_category: ~financials.models.MicrosoftGraphItemCategory
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesQuoteLine(id=id, account_id=account_id, amount_excluding_tax=amount_excluding_tax, amount_including_tax=amount_including_tax, description=description, discount_amount=discount_amount, discount_applied_before_tax=discount_applied_before_tax, discount_percent=discount_percent, document_id=document_id, item_id=item_id, line_type=line_type, net_amount=net_amount, net_amount_including_tax=net_amount_including_tax, net_tax_amount=net_tax_amount, quantity=quantity, sequence=sequence, tax_code=tax_code, tax_percent=tax_percent, total_tax_amount=total_tax_amount, unit_of_measure_id=unit_of_measure_id, unit_price=unit_price, account=account, id_item_id=microsoft_graph_entity_id, base_unit_of_measure_id=base_unit_of_measure_id, blocked=blocked, display_name=display_name, gtin=gtin, inventory=inventory, item_category_code=item_category_code, item_category_id=item_category_id, last_modified_date_time=last_modified_date_time, number=number, price_includes_tax=price_includes_tax, tax_group_code=tax_group_code, tax_group_id=tax_group_id, type=type, unit_cost=unit_cost, unit_price_item_unit_price=number_unit_price, item_category=item_category, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_quote_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesQuoteLine-id': self._serialize.url("sales_quote_line_id", sales_quote_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesQuoteLine')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_quote_line.metadata = {'url': '/financials/companies/{company-id}/salesQuoteLines/{salesQuoteLine-id}'}  # type: ignore

    async def delete_sale_quote_line(
        self,
        company_id: str,
        sales_quote_line_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesQuoteLines for financials.

        Delete navigation property salesQuoteLines for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_quote_line_id: key: id of salesQuoteLine.
        :type sales_quote_line_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_quote_line.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesQuoteLine-id': self._serialize.url("sales_quote_line_id", sales_quote_line_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_quote_line.metadata = {'url': '/financials/companies/{company-id}/salesQuoteLines/{salesQuoteLine-id}'}  # type: ignore

    def list_sale_quote(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum305"]]] = None,
        select: Optional[List[Union[str, "models.Enum306"]]] = None,
        expand: Optional[List[Union[str, "models.Enum307"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSalesQuote"]:
        """Get salesQuotes from financials.

        Get salesQuotes from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum305]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum306]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum307]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSalesQuote or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfSalesQuote]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSalesQuote"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_sale_quote.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSalesQuote', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_sale_quote.metadata = {'url': '/financials/companies/{company-id}/salesQuotes'}  # type: ignore

    async def create_sale_quote(
        self,
        company_id: str,
        id: Optional[str] = None,
        accepted_date: Optional[datetime.date] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        discount_amount: Optional[float] = None,
        document_date: Optional[datetime.date] = None,
        due_date: Optional[datetime.date] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        sent_date: Optional[datetime.datetime] = None,
        shipment_method_id: Optional[str] = None,
        shipping_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        valid_until_date: Optional[datetime.date] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_quote_lines: Optional[List["models.MicrosoftGraphSalesQuoteLine"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        microsoft_graph_customer_shipment_method_id_shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        microsoft_graph_shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesQuote":
        """Create new navigation property to salesQuotes for financials.

        Create new navigation property to salesQuotes for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param accepted_date:
        :type accepted_date: ~datetime.date
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param discount_amount:
        :type discount_amount: float
        :param document_date:
        :type document_date: ~datetime.date
        :param due_date:
        :type due_date: ~datetime.date
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param sent_date:
        :type sent_date: ~datetime.datetime
        :param shipment_method_id:
        :type shipment_method_id: str
        :param shipping_postal_address: postalAddressType.
        :type shipping_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param valid_until_date:
        :type valid_until_date: ~datetime.date
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_quote_lines:
        :type sales_quote_lines: list[~financials.models.MicrosoftGraphSalesQuoteLine]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param microsoft_graph_customer_shipment_method_id_shipment_method_id:
        :type microsoft_graph_customer_shipment_method_id_shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param microsoft_graph_shipment_method: shipmentMethod.
        :type microsoft_graph_shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesQuote, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesQuote
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesQuote"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesQuote(id=id, accepted_date=accepted_date, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, discount_amount=discount_amount, document_date=document_date, due_date=due_date, email=email, external_document_number=external_document_number, last_modified_date_time=last_modified_date_time, number=number, payment_terms_id=payment_terms_id, phone_number=phone_number, salesperson=salesperson, selling_postal_address=selling_postal_address, sent_date=sent_date, shipment_method_id=shipment_method_id, shipping_postal_address=shipping_postal_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, valid_until_date=valid_until_date, currency=currency, payment_term=payment_term, sales_quote_lines=sales_quote_lines, shipment_method=shipment_method, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id_customer_shipment_method_id=microsoft_graph_customer_shipment_method_id_shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method_customer_shipment_method=microsoft_graph_shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_sale_quote.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesQuote')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesQuote', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_sale_quote.metadata = {'url': '/financials/companies/{company-id}/salesQuotes'}  # type: ignore

    async def get_sale_quote(
        self,
        company_id: str,
        sales_quote_id: str,
        select: Optional[List[Union[str, "models.Enum308"]]] = None,
        expand: Optional[List[Union[str, "models.Enum309"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSalesQuote":
        """Get salesQuotes from financials.

        Get salesQuotes from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_quote_id: key: id of salesQuote.
        :type sales_quote_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum308]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum309]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSalesQuote, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphSalesQuote
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSalesQuote"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_sale_quote.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesQuote-id': self._serialize.url("sales_quote_id", sales_quote_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSalesQuote', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_sale_quote.metadata = {'url': '/financials/companies/{company-id}/salesQuotes/{salesQuote-id}'}  # type: ignore

    async def update_sale_quote(
        self,
        company_id: str,
        sales_quote_id: str,
        id: Optional[str] = None,
        accepted_date: Optional[datetime.date] = None,
        billing_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        bill_to_customer_id: Optional[str] = None,
        bill_to_customer_number: Optional[str] = None,
        bill_to_name: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        customer_id: Optional[str] = None,
        customer_name: Optional[str] = None,
        customer_number: Optional[str] = None,
        discount_amount: Optional[float] = None,
        document_date: Optional[datetime.date] = None,
        due_date: Optional[datetime.date] = None,
        email: Optional[str] = None,
        external_document_number: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        salesperson: Optional[str] = None,
        selling_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        sent_date: Optional[datetime.datetime] = None,
        shipment_method_id: Optional[str] = None,
        shipping_postal_address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        ship_to_contact: Optional[str] = None,
        ship_to_name: Optional[str] = None,
        status: Optional[str] = None,
        total_amount_excluding_tax: Optional[float] = None,
        total_amount_including_tax: Optional[float] = None,
        total_tax_amount: Optional[float] = None,
        valid_until_date: Optional[datetime.date] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        sales_quote_lines: Optional[List["models.MicrosoftGraphSalesQuoteLine"]] = None,
        shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        blocked: Optional[str] = None,
        microsoft_graph_customer_currency_code: Optional[str] = None,
        microsoft_graph_customer_currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        microsoft_graph_customer_email: Optional[str] = None,
        microsoft_graph_customer_last_modified_date_time_last_modified_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_customer_number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        microsoft_graph_customer_payment_terms_id_payment_terms_id: Optional[str] = None,
        microsoft_graph_customer_phone_number: Optional[str] = None,
        microsoft_graph_customer_shipment_method_id_shipment_method_id: Optional[str] = None,
        tax_area_display_name: Optional[str] = None,
        tax_area_id: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        type: Optional[str] = None,
        website: Optional[str] = None,
        microsoft_graph_currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        microsoft_graph_payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        microsoft_graph_shipment_method: Optional["models.MicrosoftGraphShipmentMethod"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property salesQuotes in financials.

        Update the navigation property salesQuotes in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_quote_id: key: id of salesQuote.
        :type sales_quote_id: str
        :param id: Read-only.
        :type id: str
        :param accepted_date:
        :type accepted_date: ~datetime.date
        :param billing_postal_address: postalAddressType.
        :type billing_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param bill_to_customer_id:
        :type bill_to_customer_id: str
        :param bill_to_customer_number:
        :type bill_to_customer_number: str
        :param bill_to_name:
        :type bill_to_name: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param customer_id:
        :type customer_id: str
        :param customer_name:
        :type customer_name: str
        :param customer_number:
        :type customer_number: str
        :param discount_amount:
        :type discount_amount: float
        :param document_date:
        :type document_date: ~datetime.date
        :param due_date:
        :type due_date: ~datetime.date
        :param email:
        :type email: str
        :param external_document_number:
        :type external_document_number: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param salesperson:
        :type salesperson: str
        :param selling_postal_address: postalAddressType.
        :type selling_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param sent_date:
        :type sent_date: ~datetime.datetime
        :param shipment_method_id:
        :type shipment_method_id: str
        :param shipping_postal_address: postalAddressType.
        :type shipping_postal_address: ~financials.models.MicrosoftGraphPostalAddressType
        :param ship_to_contact:
        :type ship_to_contact: str
        :param ship_to_name:
        :type ship_to_name: str
        :param status:
        :type status: str
        :param total_amount_excluding_tax:
        :type total_amount_excluding_tax: float
        :param total_amount_including_tax:
        :type total_amount_including_tax: float
        :param total_tax_amount:
        :type total_tax_amount: float
        :param valid_until_date:
        :type valid_until_date: ~datetime.date
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param sales_quote_lines:
        :type sales_quote_lines: list[~financials.models.MicrosoftGraphSalesQuoteLine]
        :param shipment_method: shipmentMethod.
        :type shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param blocked:
        :type blocked: str
        :param microsoft_graph_customer_currency_code:
        :type microsoft_graph_customer_currency_code: str
        :param microsoft_graph_customer_currency_id:
        :type microsoft_graph_customer_currency_id: str
        :param display_name:
        :type display_name: str
        :param microsoft_graph_customer_email:
        :type microsoft_graph_customer_email: str
        :param microsoft_graph_customer_last_modified_date_time_last_modified_date_time:
        :type microsoft_graph_customer_last_modified_date_time_last_modified_date_time: ~datetime.datetime
        :param microsoft_graph_customer_number:
        :type microsoft_graph_customer_number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param microsoft_graph_customer_payment_terms_id_payment_terms_id:
        :type microsoft_graph_customer_payment_terms_id_payment_terms_id: str
        :param microsoft_graph_customer_phone_number:
        :type microsoft_graph_customer_phone_number: str
        :param microsoft_graph_customer_shipment_method_id_shipment_method_id:
        :type microsoft_graph_customer_shipment_method_id_shipment_method_id: str
        :param tax_area_display_name:
        :type tax_area_display_name: str
        :param tax_area_id:
        :type tax_area_id: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param type:
        :type type: str
        :param website:
        :type website: str
        :param microsoft_graph_currency: currency.
        :type microsoft_graph_currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param microsoft_graph_payment_term: paymentTerm.
        :type microsoft_graph_payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :param microsoft_graph_shipment_method: shipmentMethod.
        :type microsoft_graph_shipment_method: ~financials.models.MicrosoftGraphShipmentMethod
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSalesQuote(id=id, accepted_date=accepted_date, billing_postal_address=billing_postal_address, bill_to_customer_id=bill_to_customer_id, bill_to_customer_number=bill_to_customer_number, bill_to_name=bill_to_name, currency_code=currency_code, currency_id=currency_id, customer_id=customer_id, customer_name=customer_name, customer_number=customer_number, discount_amount=discount_amount, document_date=document_date, due_date=due_date, email=email, external_document_number=external_document_number, last_modified_date_time=last_modified_date_time, number=number, payment_terms_id=payment_terms_id, phone_number=phone_number, salesperson=salesperson, selling_postal_address=selling_postal_address, sent_date=sent_date, shipment_method_id=shipment_method_id, shipping_postal_address=shipping_postal_address, ship_to_contact=ship_to_contact, ship_to_name=ship_to_name, status=status, total_amount_excluding_tax=total_amount_excluding_tax, total_amount_including_tax=total_amount_including_tax, total_tax_amount=total_tax_amount, valid_until_date=valid_until_date, currency=currency, payment_term=payment_term, sales_quote_lines=sales_quote_lines, shipment_method=shipment_method, id_customer_id=microsoft_graph_entity_id, address=address, blocked=blocked, currency_code_customer_currency_code=microsoft_graph_customer_currency_code, currency_id_customer_currency_id=microsoft_graph_customer_currency_id, display_name=display_name, email_customer_email=microsoft_graph_customer_email, last_modified_date_time_customer_last_modified_date_time=microsoft_graph_customer_last_modified_date_time_last_modified_date_time, number_customer_number=microsoft_graph_customer_number, payment_method_id=payment_method_id, payment_terms_id_customer_payment_terms_id=microsoft_graph_customer_payment_terms_id_payment_terms_id, phone_number_customer_phone_number=microsoft_graph_customer_phone_number, shipment_method_id_customer_shipment_method_id=microsoft_graph_customer_shipment_method_id_shipment_method_id, tax_area_display_name=tax_area_display_name, tax_area_id=tax_area_id, tax_liable=tax_liable, tax_registration_number=tax_registration_number, type=type, website=website, currency_customer_currency=microsoft_graph_currency, payment_method=payment_method, payment_term_customer_payment_term=microsoft_graph_payment_term, picture=picture, shipment_method_customer_shipment_method=microsoft_graph_shipment_method)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_sale_quote.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesQuote-id': self._serialize.url("sales_quote_id", sales_quote_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSalesQuote')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_sale_quote.metadata = {'url': '/financials/companies/{company-id}/salesQuotes/{salesQuote-id}'}  # type: ignore

    async def delete_sale_quote(
        self,
        company_id: str,
        sales_quote_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property salesQuotes for financials.

        Delete navigation property salesQuotes for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param sales_quote_id: key: id of salesQuote.
        :type sales_quote_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_sale_quote.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'salesQuote-id': self._serialize.url("sales_quote_id", sales_quote_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_sale_quote.metadata = {'url': '/financials/companies/{company-id}/salesQuotes/{salesQuote-id}'}  # type: ignore

    def list_shipment_method(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum334"]]] = None,
        select: Optional[List[Union[str, "models.Enum335"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfShipmentMethod"]:
        """Get shipmentMethods from financials.

        Get shipmentMethods from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum334]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum335]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfShipmentMethod or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfShipmentMethod]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfShipmentMethod"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_shipment_method.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfShipmentMethod', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_shipment_method.metadata = {'url': '/financials/companies/{company-id}/shipmentMethods'}  # type: ignore

    async def create_shipment_method(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphShipmentMethod":
        """Create new navigation property to shipmentMethods for financials.

        Create new navigation property to shipmentMethods for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphShipmentMethod, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphShipmentMethod
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphShipmentMethod"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphShipmentMethod(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_shipment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphShipmentMethod')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphShipmentMethod', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_shipment_method.metadata = {'url': '/financials/companies/{company-id}/shipmentMethods'}  # type: ignore

    async def get_shipment_method(
        self,
        company_id: str,
        shipment_method_id: str,
        select: Optional[List[Union[str, "models.Enum336"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphShipmentMethod":
        """Get shipmentMethods from financials.

        Get shipmentMethods from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param shipment_method_id: key: id of shipmentMethod.
        :type shipment_method_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum336]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphShipmentMethod, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphShipmentMethod
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphShipmentMethod"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_shipment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'shipmentMethod-id': self._serialize.url("shipment_method_id", shipment_method_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphShipmentMethod', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_shipment_method.metadata = {'url': '/financials/companies/{company-id}/shipmentMethods/{shipmentMethod-id}'}  # type: ignore

    async def update_shipment_method(
        self,
        company_id: str,
        shipment_method_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property shipmentMethods in financials.

        Update the navigation property shipmentMethods in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param shipment_method_id: key: id of shipmentMethod.
        :type shipment_method_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphShipmentMethod(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_shipment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'shipmentMethod-id': self._serialize.url("shipment_method_id", shipment_method_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphShipmentMethod')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_shipment_method.metadata = {'url': '/financials/companies/{company-id}/shipmentMethods/{shipmentMethod-id}'}  # type: ignore

    async def delete_shipment_method(
        self,
        company_id: str,
        shipment_method_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property shipmentMethods for financials.

        Delete navigation property shipmentMethods for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param shipment_method_id: key: id of shipmentMethod.
        :type shipment_method_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_shipment_method.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'shipmentMethod-id': self._serialize.url("shipment_method_id", shipment_method_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_shipment_method.metadata = {'url': '/financials/companies/{company-id}/shipmentMethods/{shipmentMethod-id}'}  # type: ignore

    def list_tax_area(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum337"]]] = None,
        select: Optional[List[Union[str, "models.Enum338"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTaxArea"]:
        """Get taxAreas from financials.

        Get taxAreas from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum337]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum338]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTaxArea or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfTaxArea]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTaxArea"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_tax_area.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTaxArea', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_tax_area.metadata = {'url': '/financials/companies/{company-id}/taxAreas'}  # type: ignore

    async def create_tax_area(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        tax_type: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTaxArea":
        """Create new navigation property to taxAreas for financials.

        Create new navigation property to taxAreas for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param tax_type:
        :type tax_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTaxArea, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphTaxArea
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTaxArea"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTaxArea(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, tax_type=tax_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_tax_area.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTaxArea')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTaxArea', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_tax_area.metadata = {'url': '/financials/companies/{company-id}/taxAreas'}  # type: ignore

    async def get_tax_area(
        self,
        company_id: str,
        tax_area_id: str,
        select: Optional[List[Union[str, "models.Enum339"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTaxArea":
        """Get taxAreas from financials.

        Get taxAreas from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param tax_area_id: key: id of taxArea.
        :type tax_area_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum339]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTaxArea, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphTaxArea
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTaxArea"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_tax_area.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'taxArea-id': self._serialize.url("tax_area_id", tax_area_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTaxArea', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_tax_area.metadata = {'url': '/financials/companies/{company-id}/taxAreas/{taxArea-id}'}  # type: ignore

    async def update_tax_area(
        self,
        company_id: str,
        tax_area_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        tax_type: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property taxAreas in financials.

        Update the navigation property taxAreas in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param tax_area_id: key: id of taxArea.
        :type tax_area_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param tax_type:
        :type tax_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTaxArea(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, tax_type=tax_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_tax_area.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'taxArea-id': self._serialize.url("tax_area_id", tax_area_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTaxArea')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_tax_area.metadata = {'url': '/financials/companies/{company-id}/taxAreas/{taxArea-id}'}  # type: ignore

    async def delete_tax_area(
        self,
        company_id: str,
        tax_area_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property taxAreas for financials.

        Delete navigation property taxAreas for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param tax_area_id: key: id of taxArea.
        :type tax_area_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_tax_area.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'taxArea-id': self._serialize.url("tax_area_id", tax_area_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_tax_area.metadata = {'url': '/financials/companies/{company-id}/taxAreas/{taxArea-id}'}  # type: ignore

    def list_tax_group(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum340"]]] = None,
        select: Optional[List[Union[str, "models.Enum341"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTaxGroup"]:
        """Get taxGroups from financials.

        Get taxGroups from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum340]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum341]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTaxGroup or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfTaxGroup]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTaxGroup"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_tax_group.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTaxGroup', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_tax_group.metadata = {'url': '/financials/companies/{company-id}/taxGroups'}  # type: ignore

    async def create_tax_group(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        tax_type: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTaxGroup":
        """Create new navigation property to taxGroups for financials.

        Create new navigation property to taxGroups for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param tax_type:
        :type tax_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTaxGroup, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphTaxGroup
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTaxGroup"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTaxGroup(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, tax_type=tax_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_tax_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTaxGroup')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTaxGroup', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_tax_group.metadata = {'url': '/financials/companies/{company-id}/taxGroups'}  # type: ignore

    async def get_tax_group(
        self,
        company_id: str,
        tax_group_id: str,
        select: Optional[List[Union[str, "models.Enum342"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTaxGroup":
        """Get taxGroups from financials.

        Get taxGroups from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param tax_group_id: key: id of taxGroup.
        :type tax_group_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum342]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTaxGroup, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphTaxGroup
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTaxGroup"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_tax_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'taxGroup-id': self._serialize.url("tax_group_id", tax_group_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTaxGroup', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_tax_group.metadata = {'url': '/financials/companies/{company-id}/taxGroups/{taxGroup-id}'}  # type: ignore

    async def update_tax_group(
        self,
        company_id: str,
        tax_group_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        tax_type: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property taxGroups in financials.

        Update the navigation property taxGroups in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param tax_group_id: key: id of taxGroup.
        :type tax_group_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param tax_type:
        :type tax_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTaxGroup(id=id, code=code, display_name=display_name, last_modified_date_time=last_modified_date_time, tax_type=tax_type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_tax_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'taxGroup-id': self._serialize.url("tax_group_id", tax_group_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTaxGroup')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_tax_group.metadata = {'url': '/financials/companies/{company-id}/taxGroups/{taxGroup-id}'}  # type: ignore

    async def delete_tax_group(
        self,
        company_id: str,
        tax_group_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property taxGroups for financials.

        Delete navigation property taxGroups for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param tax_group_id: key: id of taxGroup.
        :type tax_group_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_tax_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'taxGroup-id': self._serialize.url("tax_group_id", tax_group_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_tax_group.metadata = {'url': '/financials/companies/{company-id}/taxGroups/{taxGroup-id}'}  # type: ignore

    def list_unit_of_measure(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum343"]]] = None,
        select: Optional[List[Union[str, "models.Enum344"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfUnitOfMeasure"]:
        """Get unitsOfMeasure from financials.

        Get unitsOfMeasure from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum343]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum344]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfUnitOfMeasure or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfUnitOfMeasure]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfUnitOfMeasure"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_unit_of_measure.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfUnitOfMeasure', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_unit_of_measure.metadata = {'url': '/financials/companies/{company-id}/unitsOfMeasure'}  # type: ignore

    async def create_unit_of_measure(
        self,
        company_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        international_standard_code: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> "models.MicrosoftGraphUnitOfMeasure":
        """Create new navigation property to unitsOfMeasure for financials.

        Create new navigation property to unitsOfMeasure for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param international_standard_code:
        :type international_standard_code: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUnitOfMeasure, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphUnitOfMeasure
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUnitOfMeasure"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphUnitOfMeasure(id=id, code=code, display_name=display_name, international_standard_code=international_standard_code, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_unit_of_measure.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphUnitOfMeasure')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUnitOfMeasure', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_unit_of_measure.metadata = {'url': '/financials/companies/{company-id}/unitsOfMeasure'}  # type: ignore

    async def get_unit_of_measure(
        self,
        company_id: str,
        unit_of_measure_id: str,
        select: Optional[List[Union[str, "models.Enum345"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphUnitOfMeasure":
        """Get unitsOfMeasure from financials.

        Get unitsOfMeasure from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param unit_of_measure_id: key: id of unitOfMeasure.
        :type unit_of_measure_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum345]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUnitOfMeasure, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphUnitOfMeasure
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUnitOfMeasure"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_unit_of_measure.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'unitOfMeasure-id': self._serialize.url("unit_of_measure_id", unit_of_measure_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUnitOfMeasure', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_unit_of_measure.metadata = {'url': '/financials/companies/{company-id}/unitsOfMeasure/{unitOfMeasure-id}'}  # type: ignore

    async def update_unit_of_measure(
        self,
        company_id: str,
        unit_of_measure_id: str,
        id: Optional[str] = None,
        code: Optional[str] = None,
        display_name: Optional[str] = None,
        international_standard_code: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        **kwargs
    ) -> None:
        """Update the navigation property unitsOfMeasure in financials.

        Update the navigation property unitsOfMeasure in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param unit_of_measure_id: key: id of unitOfMeasure.
        :type unit_of_measure_id: str
        :param id: Read-only.
        :type id: str
        :param code:
        :type code: str
        :param display_name:
        :type display_name: str
        :param international_standard_code:
        :type international_standard_code: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphUnitOfMeasure(id=id, code=code, display_name=display_name, international_standard_code=international_standard_code, last_modified_date_time=last_modified_date_time)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_unit_of_measure.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'unitOfMeasure-id': self._serialize.url("unit_of_measure_id", unit_of_measure_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphUnitOfMeasure')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_unit_of_measure.metadata = {'url': '/financials/companies/{company-id}/unitsOfMeasure/{unitOfMeasure-id}'}  # type: ignore

    async def delete_unit_of_measure(
        self,
        company_id: str,
        unit_of_measure_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property unitsOfMeasure for financials.

        Delete navigation property unitsOfMeasure for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param unit_of_measure_id: key: id of unitOfMeasure.
        :type unit_of_measure_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_unit_of_measure.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'unitOfMeasure-id': self._serialize.url("unit_of_measure_id", unit_of_measure_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_unit_of_measure.metadata = {'url': '/financials/companies/{company-id}/unitsOfMeasure/{unitOfMeasure-id}'}  # type: ignore

    def list_vendor(
        self,
        company_id: str,
        orderby: Optional[List[Union[str, "models.Enum346"]]] = None,
        select: Optional[List[Union[str, "models.Enum347"]]] = None,
        expand: Optional[List[Union[str, "models.Enum348"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfVendor"]:
        """Get vendors from financials.

        Get vendors from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~financials.models.Enum346]
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum347]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum348]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfVendor or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~financials.models.CollectionOfVendor]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfVendor"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_vendor.metadata['url']  # type: ignore
                path_format_arguments = {
                    'company-id': self._serialize.url("company_id", company_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfVendor', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_vendor.metadata = {'url': '/financials/companies/{company-id}/vendors'}  # type: ignore

    async def create_vendor(
        self,
        company_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        balance: Optional[float] = None,
        blocked: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        website: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphVendor":
        """Create new navigation property to vendors for financials.

        Create new navigation property to vendors for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param balance:
        :type balance: float
        :param blocked:
        :type blocked: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param website:
        :type website: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphVendor, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphVendor
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphVendor"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphVendor(id=id, address=address, balance=balance, blocked=blocked, currency_code=currency_code, currency_id=currency_id, display_name=display_name, email=email, last_modified_date_time=last_modified_date_time, number=number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, tax_liable=tax_liable, tax_registration_number=tax_registration_number, website=website, currency=currency, payment_method=payment_method, payment_term=payment_term, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_vendor.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphVendor')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphVendor', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_vendor.metadata = {'url': '/financials/companies/{company-id}/vendors'}  # type: ignore

    async def get_vendor(
        self,
        company_id: str,
        vendor_id: str,
        select: Optional[List[Union[str, "models.Enum349"]]] = None,
        expand: Optional[List[Union[str, "models.Enum350"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphVendor":
        """Get vendors from financials.

        Get vendors from financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param vendor_id: key: id of vendor.
        :type vendor_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~financials.models.Enum349]
        :param expand: Expand related entities.
        :type expand: list[str or ~financials.models.Enum350]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphVendor, or the result of cls(response)
        :rtype: ~financials.models.MicrosoftGraphVendor
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphVendor"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_vendor.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'vendor-id': self._serialize.url("vendor_id", vendor_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphVendor', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_vendor.metadata = {'url': '/financials/companies/{company-id}/vendors/{vendor-id}'}  # type: ignore

    async def update_vendor(
        self,
        company_id: str,
        vendor_id: str,
        id: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPostalAddressType"] = None,
        balance: Optional[float] = None,
        blocked: Optional[str] = None,
        currency_code: Optional[str] = None,
        currency_id: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        number: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        payment_terms_id: Optional[str] = None,
        phone_number: Optional[str] = None,
        tax_liable: Optional[bool] = None,
        tax_registration_number: Optional[str] = None,
        website: Optional[str] = None,
        currency: Optional["models.MicrosoftGraphCurrency"] = None,
        payment_method: Optional["models.MicrosoftGraphPaymentMethod"] = None,
        payment_term: Optional["models.MicrosoftGraphPaymentTerm"] = None,
        picture: Optional[List["models.MicrosoftGraphPicture"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property vendors in financials.

        Update the navigation property vendors in financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param vendor_id: key: id of vendor.
        :type vendor_id: str
        :param id: Read-only.
        :type id: str
        :param address: postalAddressType.
        :type address: ~financials.models.MicrosoftGraphPostalAddressType
        :param balance:
        :type balance: float
        :param blocked:
        :type blocked: str
        :param currency_code:
        :type currency_code: str
        :param currency_id:
        :type currency_id: str
        :param display_name:
        :type display_name: str
        :param email:
        :type email: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param number:
        :type number: str
        :param payment_method_id:
        :type payment_method_id: str
        :param payment_terms_id:
        :type payment_terms_id: str
        :param phone_number:
        :type phone_number: str
        :param tax_liable:
        :type tax_liable: bool
        :param tax_registration_number:
        :type tax_registration_number: str
        :param website:
        :type website: str
        :param currency: currency.
        :type currency: ~financials.models.MicrosoftGraphCurrency
        :param payment_method: paymentMethod.
        :type payment_method: ~financials.models.MicrosoftGraphPaymentMethod
        :param payment_term: paymentTerm.
        :type payment_term: ~financials.models.MicrosoftGraphPaymentTerm
        :param picture:
        :type picture: list[~financials.models.MicrosoftGraphPicture]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphVendor(id=id, address=address, balance=balance, blocked=blocked, currency_code=currency_code, currency_id=currency_id, display_name=display_name, email=email, last_modified_date_time=last_modified_date_time, number=number, payment_method_id=payment_method_id, payment_terms_id=payment_terms_id, phone_number=phone_number, tax_liable=tax_liable, tax_registration_number=tax_registration_number, website=website, currency=currency, payment_method=payment_method, payment_term=payment_term, picture=picture)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_vendor.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'vendor-id': self._serialize.url("vendor_id", vendor_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphVendor')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_vendor.metadata = {'url': '/financials/companies/{company-id}/vendors/{vendor-id}'}  # type: ignore

    async def delete_vendor(
        self,
        company_id: str,
        vendor_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property vendors for financials.

        Delete navigation property vendors for financials.

        :param company_id: key: id of company.
        :type company_id: str
        :param vendor_id: key: id of vendor.
        :type vendor_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_vendor.metadata['url']  # type: ignore
        path_format_arguments = {
            'company-id': self._serialize.url("company_id", company_id, 'str'),
            'vendor-id': self._serialize.url("vendor_id", vendor_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_vendor.metadata = {'url': '/financials/companies/{company-id}/vendors/{vendor-id}'}  # type: ignore
