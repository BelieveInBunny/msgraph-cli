# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class reportsOperations:
    """reportsOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~reports.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_application_sign_in_detailed_summary(
        self,
        orderby: Optional[List[Union[str, "models.Enum37"]]] = None,
        select: Optional[List[Union[str, "models.Enum38"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofapplicationsignindetailedsummary"]:
        """Get applicationSignInDetailedSummary from reports.

        Get applicationSignInDetailedSummary from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum37]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum38]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofapplicationsignindetailedsummary or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofapplicationsignindetailedsummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofapplicationsignindetailedsummary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_application_sign_in_detailed_summary.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofapplicationsignindetailedsummary', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary'}  # type: ignore

    async def create_application_sign_in_detailed_summary(
        self,
        body: "models.microsoftgraphapplicationsignindetailedsummary",
        **kwargs
    ) -> "models.microsoftgraphapplicationsignindetailedsummary":
        """Create new navigation property to applicationSignInDetailedSummary for reports.

        Create new navigation property to applicationSignInDetailedSummary for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphapplicationsignindetailedsummary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphapplicationsignindetailedsummary, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphapplicationsignindetailedsummary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphapplicationsignindetailedsummary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_application_sign_in_detailed_summary.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphapplicationsignindetailedsummary')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphapplicationsignindetailedsummary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary'}  # type: ignore

    async def get_application_sign_in_detailed_summary(
        self,
        application_sign_in_detailed_summary_id: str,
        select: Optional[List[Union[str, "models.Enum39"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphapplicationsignindetailedsummary":
        """Get applicationSignInDetailedSummary from reports.

        Get applicationSignInDetailedSummary from reports.

        :param application_sign_in_detailed_summary_id: key: id of applicationSignInDetailedSummary.
        :type application_sign_in_detailed_summary_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum39]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphapplicationsignindetailedsummary, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphapplicationsignindetailedsummary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphapplicationsignindetailedsummary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_application_sign_in_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'applicationSignInDetailedSummary-id': self._serialize.url("application_sign_in_detailed_summary_id", application_sign_in_detailed_summary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphapplicationsignindetailedsummary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary/{applicationSignInDetailedSummary-id}'}  # type: ignore

    async def update_application_sign_in_detailed_summary(
        self,
        application_sign_in_detailed_summary_id: str,
        body: "models.microsoftgraphapplicationsignindetailedsummary",
        **kwargs
    ) -> None:
        """Update the navigation property applicationSignInDetailedSummary in reports.

        Update the navigation property applicationSignInDetailedSummary in reports.

        :param application_sign_in_detailed_summary_id: key: id of applicationSignInDetailedSummary.
        :type application_sign_in_detailed_summary_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphapplicationsignindetailedsummary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_application_sign_in_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'applicationSignInDetailedSummary-id': self._serialize.url("application_sign_in_detailed_summary_id", application_sign_in_detailed_summary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphapplicationsignindetailedsummary')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary/{applicationSignInDetailedSummary-id}'}  # type: ignore

    async def delete_application_sign_in_detailed_summary(
        self,
        application_sign_in_detailed_summary_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property applicationSignInDetailedSummary for reports.

        Delete navigation property applicationSignInDetailedSummary for reports.

        :param application_sign_in_detailed_summary_id: key: id of applicationSignInDetailedSummary.
        :type application_sign_in_detailed_summary_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_application_sign_in_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'applicationSignInDetailedSummary-id': self._serialize.url("application_sign_in_detailed_summary_id", application_sign_in_detailed_summary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_application_sign_in_detailed_summary.metadata = {'url': '/reports/applicationSignInDetailedSummary/{applicationSignInDetailedSummary-id}'}  # type: ignore

    def list_credential_user_registration_details(
        self,
        orderby: Optional[List[Union[str, "models.Enum40"]]] = None,
        select: Optional[List[Union[str, "models.Enum41"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofcredentialuserregistrationdetails"]:
        """Get credentialUserRegistrationDetails from reports.

        Get credentialUserRegistrationDetails from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum40]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum41]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofcredentialuserregistrationdetails or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofcredentialuserregistrationdetails]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofcredentialuserregistrationdetails"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_credential_user_registration_details.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofcredentialuserregistrationdetails', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_credential_user_registration_details.metadata = {'url': '/reports/credentialUserRegistrationDetails'}  # type: ignore

    async def create_credential_user_registration_details(
        self,
        body: "models.microsoftgraphcredentialuserregistrationdetails",
        **kwargs
    ) -> "models.microsoftgraphcredentialuserregistrationdetails":
        """Create new navigation property to credentialUserRegistrationDetails for reports.

        Create new navigation property to credentialUserRegistrationDetails for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphcredentialuserregistrationdetails
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphcredentialuserregistrationdetails, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphcredentialuserregistrationdetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphcredentialuserregistrationdetails"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_credential_user_registration_details.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphcredentialuserregistrationdetails')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphcredentialuserregistrationdetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_credential_user_registration_details.metadata = {'url': '/reports/credentialUserRegistrationDetails'}  # type: ignore

    async def get_credential_user_registration_details(
        self,
        credential_user_registration_details_id: str,
        select: Optional[List[Union[str, "models.Enum42"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphcredentialuserregistrationdetails":
        """Get credentialUserRegistrationDetails from reports.

        Get credentialUserRegistrationDetails from reports.

        :param credential_user_registration_details_id: key: id of credentialUserRegistrationDetails.
        :type credential_user_registration_details_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum42]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphcredentialuserregistrationdetails, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphcredentialuserregistrationdetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphcredentialuserregistrationdetails"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_credential_user_registration_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'credentialUserRegistrationDetails-id': self._serialize.url("credential_user_registration_details_id", credential_user_registration_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphcredentialuserregistrationdetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_credential_user_registration_details.metadata = {'url': '/reports/credentialUserRegistrationDetails/{credentialUserRegistrationDetails-id}'}  # type: ignore

    async def update_credential_user_registration_details(
        self,
        credential_user_registration_details_id: str,
        body: "models.microsoftgraphcredentialuserregistrationdetails",
        **kwargs
    ) -> None:
        """Update the navigation property credentialUserRegistrationDetails in reports.

        Update the navigation property credentialUserRegistrationDetails in reports.

        :param credential_user_registration_details_id: key: id of credentialUserRegistrationDetails.
        :type credential_user_registration_details_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphcredentialuserregistrationdetails
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_credential_user_registration_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'credentialUserRegistrationDetails-id': self._serialize.url("credential_user_registration_details_id", credential_user_registration_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphcredentialuserregistrationdetails')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_credential_user_registration_details.metadata = {'url': '/reports/credentialUserRegistrationDetails/{credentialUserRegistrationDetails-id}'}  # type: ignore

    async def delete_credential_user_registration_details(
        self,
        credential_user_registration_details_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property credentialUserRegistrationDetails for reports.

        Delete navigation property credentialUserRegistrationDetails for reports.

        :param credential_user_registration_details_id: key: id of credentialUserRegistrationDetails.
        :type credential_user_registration_details_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_credential_user_registration_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'credentialUserRegistrationDetails-id': self._serialize.url("credential_user_registration_details_id", credential_user_registration_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_credential_user_registration_details.metadata = {'url': '/reports/credentialUserRegistrationDetails/{credentialUserRegistrationDetails-id}'}  # type: ignore

    def list_daily_print_usage_summaries_by_printer(
        self,
        orderby: Optional[List[Union[str, "models.Enum43"]]] = None,
        select: Optional[List[Union[str, "models.Enum44"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofprintusagesummarybyprinter"]:
        """Get dailyPrintUsageSummariesByPrinter from reports.

        Get dailyPrintUsageSummariesByPrinter from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum43]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum44]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofprintusagesummarybyprinter or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofprintusagesummarybyprinter]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofprintusagesummarybyprinter"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_daily_print_usage_summaries_by_printer.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofprintusagesummarybyprinter', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_daily_print_usage_summaries_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter'}  # type: ignore

    async def create_daily_print_usage_summaries_by_printer(
        self,
        body: "models.microsoftgraphprintusagesummarybyprinter",
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyprinter":
        """Create new navigation property to dailyPrintUsageSummariesByPrinter for reports.

        Create new navigation property to dailyPrintUsageSummariesByPrinter for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyprinter, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyprinter"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_daily_print_usage_summaries_by_printer.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyprinter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyprinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_daily_print_usage_summaries_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter'}  # type: ignore

    async def get_daily_print_usage_summaries_by_printer(
        self,
        print_usage_summary_by_printer_id: str,
        select: Optional[List[Union[str, "models.Enum45"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyprinter":
        """Get dailyPrintUsageSummariesByPrinter from reports.

        Get dailyPrintUsageSummariesByPrinter from reports.

        :param print_usage_summary_by_printer_id: key: id of PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum45]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyprinter, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyprinter"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_daily_print_usage_summaries_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyprinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_daily_print_usage_summaries_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    async def update_daily_print_usage_summaries_by_printer(
        self,
        print_usage_summary_by_printer_id: str,
        body: "models.microsoftgraphprintusagesummarybyprinter",
        **kwargs
    ) -> None:
        """Update the navigation property dailyPrintUsageSummariesByPrinter in reports.

        Update the navigation property dailyPrintUsageSummariesByPrinter in reports.

        :param print_usage_summary_by_printer_id: key: id of PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_daily_print_usage_summaries_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyprinter')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_daily_print_usage_summaries_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    async def delete_daily_print_usage_summaries_by_printer(
        self,
        print_usage_summary_by_printer_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property dailyPrintUsageSummariesByPrinter for reports.

        Delete navigation property dailyPrintUsageSummariesByPrinter for reports.

        :param print_usage_summary_by_printer_id: key: id of PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_daily_print_usage_summaries_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_daily_print_usage_summaries_by_printer.metadata = {'url': '/reports/dailyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    def list_daily_print_usage_summaries_by_user(
        self,
        orderby: Optional[List[Union[str, "models.Enum46"]]] = None,
        select: Optional[List[Union[str, "models.Enum47"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofprintusagesummarybyuser"]:
        """Get dailyPrintUsageSummariesByUser from reports.

        Get dailyPrintUsageSummariesByUser from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum46]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum47]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofprintusagesummarybyuser or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofprintusagesummarybyuser]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofprintusagesummarybyuser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_daily_print_usage_summaries_by_user.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofprintusagesummarybyuser', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_daily_print_usage_summaries_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser'}  # type: ignore

    async def create_daily_print_usage_summaries_by_user(
        self,
        body: "models.microsoftgraphprintusagesummarybyuser",
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyuser":
        """Create new navigation property to dailyPrintUsageSummariesByUser for reports.

        Create new navigation property to dailyPrintUsageSummariesByUser for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyuser
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyuser, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyuser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyuser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_daily_print_usage_summaries_by_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyuser')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyuser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_daily_print_usage_summaries_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser'}  # type: ignore

    async def get_daily_print_usage_summaries_by_user(
        self,
        print_usage_summary_by_user_id: str,
        select: Optional[List[Union[str, "models.Enum48"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyuser":
        """Get dailyPrintUsageSummariesByUser from reports.

        Get dailyPrintUsageSummariesByUser from reports.

        :param print_usage_summary_by_user_id: key: id of PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum48]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyuser, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyuser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyuser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_daily_print_usage_summaries_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyuser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_daily_print_usage_summaries_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    async def update_daily_print_usage_summaries_by_user(
        self,
        print_usage_summary_by_user_id: str,
        body: "models.microsoftgraphprintusagesummarybyuser",
        **kwargs
    ) -> None:
        """Update the navigation property dailyPrintUsageSummariesByUser in reports.

        Update the navigation property dailyPrintUsageSummariesByUser in reports.

        :param print_usage_summary_by_user_id: key: id of PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyuser
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_daily_print_usage_summaries_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyuser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_daily_print_usage_summaries_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    async def delete_daily_print_usage_summaries_by_user(
        self,
        print_usage_summary_by_user_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property dailyPrintUsageSummariesByUser for reports.

        Delete navigation property dailyPrintUsageSummariesByUser for reports.

        :param print_usage_summary_by_user_id: key: id of PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_daily_print_usage_summaries_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_daily_print_usage_summaries_by_user.metadata = {'url': '/reports/dailyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    async def device_configuration_device_activity(
        self,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function deviceConfigurationDeviceActivity.

        Invoke function deviceConfigurationDeviceActivity.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.device_configuration_device_activity.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    device_configuration_device_activity.metadata = {'url': '/reports/microsoft.graph.deviceConfigurationDeviceActivity()'}  # type: ignore

    async def device_configuration_user_activity(
        self,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function deviceConfigurationUserActivity.

        Invoke function deviceConfigurationUserActivity.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.device_configuration_user_activity.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    device_configuration_user_activity.metadata = {'url': '/reports/microsoft.graph.deviceConfigurationUserActivity()'}  # type: ignore

    async def get_azure_ad_application_sign_in_summary(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphapplicationsigninsummary"]:
        """Invoke function getAzureADApplicationSignInSummary.

        Invoke function getAzureADApplicationSignInSummary.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphapplicationsigninsummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphapplicationsigninsummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphapplicationsigninsummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_azure_ad_application_sign_in_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphapplicationsigninsummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_application_sign_in_summary.metadata = {'url': '/reports/microsoft.graph.getAzureADApplicationSignInSummary(period=\'{period}\')'}  # type: ignore

    async def get_azure_ad_feature_usage(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphazureadfeatureusage"]:
        """Invoke function getAzureADFeatureUsage.

        Invoke function getAzureADFeatureUsage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphazureadfeatureusage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphazureadfeatureusage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphazureadfeatureusage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_azure_ad_feature_usage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphazureadfeatureusage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_feature_usage.metadata = {'url': '/reports/microsoft.graph.getAzureADFeatureUsage(period=\'{period}\')'}  # type: ignore

    async def get_azure_ad_license_usage(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphazureadlicenseusage"]:
        """Invoke function getAzureADLicenseUsage.

        Invoke function getAzureADLicenseUsage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphazureadlicenseusage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphazureadlicenseusage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphazureadlicenseusage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_azure_ad_license_usage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphazureadlicenseusage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_license_usage.metadata = {'url': '/reports/microsoft.graph.getAzureADLicenseUsage(period=\'{period}\')'}  # type: ignore

    async def get_azure_ad_user_feature_usage(
        self,
        **kwargs
    ) -> List["models.microsoftgraphazureaduserfeatureusage"]:
        """Invoke function getAzureADUserFeatureUsage.

        Invoke function getAzureADUserFeatureUsage.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphazureaduserfeatureusage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphazureaduserfeatureusage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphazureaduserfeatureusage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_azure_ad_user_feature_usage.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphazureaduserfeatureusage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_azure_ad_user_feature_usage.metadata = {'url': '/reports/microsoft.graph.getAzureADUserFeatureUsage()'}  # type: ignore

    async def get_credential_usage_summary(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphcredentialusagesummary"]:
        """Invoke function getCredentialUsageSummary.

        Invoke function getCredentialUsageSummary.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphcredentialusagesummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphcredentialusagesummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphcredentialusagesummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_credential_usage_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphcredentialusagesummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_credential_usage_summary.metadata = {'url': '/reports/microsoft.graph.getCredentialUsageSummary(period=\'{period}\')'}  # type: ignore

    async def get_credential_user_registration_count(
        self,
        **kwargs
    ) -> List["models.microsoftgraphcredentialuserregistrationcount"]:
        """Invoke function getCredentialUserRegistrationCount.

        Invoke function getCredentialUserRegistrationCount.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphcredentialuserregistrationcount, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphcredentialuserregistrationcount]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphcredentialuserregistrationcount"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_credential_user_registration_count.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphcredentialuserregistrationcount]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_credential_user_registration_count.metadata = {'url': '/reports/microsoft.graph.getCredentialUserRegistrationCount()'}  # type: ignore

    async def get_email_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailactivitysummary"]:
        """Invoke function getEmailActivityCounts.

        Invoke function getEmailActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailactivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailactivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailactivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailactivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_counts.metadata = {'url': '/reports/microsoft.graph.getEmailActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_email_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailactivitysummary"]:
        """Invoke function getEmailActivityUserCounts.

        Invoke function getEmailActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailactivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailactivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailactivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailactivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getEmailActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_email_activity_user_detail_fe32(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphemailactivityuserdetail"]:
        """Invoke function getEmailActivityUserDetail.

        Invoke function getEmailActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_activity_user_detail_fe32.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_user_detail_fe32.metadata = {'url': '/reports/microsoft.graph.getEmailActivityUserDetail(date={date})'}  # type: ignore

    async def get_email_activity_user_detail_ddb2(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailactivityuserdetail"]:
        """Invoke function getEmailActivityUserDetail.

        Invoke function getEmailActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_activity_user_detail_ddb2.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_activity_user_detail_ddb2.metadata = {'url': '/reports/microsoft.graph.getEmailActivityUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_email_app_usage_apps_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailappusageappsusercounts"]:
        """Invoke function getEmailAppUsageAppsUserCounts.

        Invoke function getEmailAppUsageAppsUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailappusageappsusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailappusageappsusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailappusageappsusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_app_usage_apps_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailappusageappsusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_apps_user_counts.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageAppsUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_email_app_usage_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailappusageusercounts"]:
        """Invoke function getEmailAppUsageUserCounts.

        Invoke function getEmailAppUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailappusageusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailappusageusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailappusageusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_app_usage_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailappusageusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_user_counts.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_email_app_usage_user_detail62_ec(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphemailappusageuserdetail"]:
        """Invoke function getEmailAppUsageUserDetail.

        Invoke function getEmailAppUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailappusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailappusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailappusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_app_usage_user_detail62_ec.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailappusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_user_detail62_ec.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageUserDetail(date={date})'}  # type: ignore

    async def get_email_app_usage_user_detail546_b(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailappusageuserdetail"]:
        """Invoke function getEmailAppUsageUserDetail.

        Invoke function getEmailAppUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailappusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailappusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailappusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_app_usage_user_detail546_b.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailappusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_user_detail546_b.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_email_app_usage_versions_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphemailappusageversionsusercounts"]:
        """Invoke function getEmailAppUsageVersionsUserCounts.

        Invoke function getEmailAppUsageVersionsUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphemailappusageversionsusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphemailappusageversionsusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphemailappusageversionsusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email_app_usage_versions_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphemailappusageversionsusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email_app_usage_versions_user_counts.metadata = {'url': '/reports/microsoft.graph.getEmailAppUsageVersionsUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_m365_app_platform_user_counts(
        self,
        period: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function getM365AppPlatformUserCounts.

        Invoke function getM365AppPlatformUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_m365_app_platform_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_m365_app_platform_user_counts.metadata = {'url': '/reports/microsoft.graph.getM365AppPlatformUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_m365_app_user_counts(
        self,
        period: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function getM365AppUserCounts.

        Invoke function getM365AppUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_m365_app_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_m365_app_user_counts.metadata = {'url': '/reports/microsoft.graph.getM365AppUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_m365_app_user_detail2_b20(
        self,
        date: datetime.date,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function getM365AppUserDetail.

        Invoke function getM365AppUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_m365_app_user_detail2_b20.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_m365_app_user_detail2_b20.metadata = {'url': '/reports/microsoft.graph.getM365AppUserDetail(date={date})'}  # type: ignore

    async def get_m365_app_user_detail_c8_df(
        self,
        period: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function getM365AppUserDetail.

        Invoke function getM365AppUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_m365_app_user_detail_c8_df.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_m365_app_user_detail_c8_df.metadata = {'url': '/reports/microsoft.graph.getM365AppUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_mailbox_usage_detail(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphmailboxusagedetail"]:
        """Invoke function getMailboxUsageDetail.

        Invoke function getMailboxUsageDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphmailboxusagedetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphmailboxusagedetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphmailboxusagedetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mailbox_usage_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphmailboxusagedetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_detail.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageDetail(period=\'{period}\')'}  # type: ignore

    async def get_mailbox_usage_mailbox_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphmailboxusagemailboxcounts"]:
        """Invoke function getMailboxUsageMailboxCounts.

        Invoke function getMailboxUsageMailboxCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphmailboxusagemailboxcounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphmailboxusagemailboxcounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphmailboxusagemailboxcounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mailbox_usage_mailbox_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphmailboxusagemailboxcounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_mailbox_counts.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageMailboxCounts(period=\'{period}\')'}  # type: ignore

    async def get_mailbox_usage_quota_status_mailbox_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphmailboxusagequotastatusmailboxcounts"]:
        """Invoke function getMailboxUsageQuotaStatusMailboxCounts.

        Invoke function getMailboxUsageQuotaStatusMailboxCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphmailboxusagequotastatusmailboxcounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphmailboxusagequotastatusmailboxcounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphmailboxusagequotastatusmailboxcounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mailbox_usage_quota_status_mailbox_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphmailboxusagequotastatusmailboxcounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_quota_status_mailbox_counts.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageQuotaStatusMailboxCounts(period=\'{period}\')'}  # type: ignore

    async def get_mailbox_usage_storage(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphmailboxusagestorage"]:
        """Invoke function getMailboxUsageStorage.

        Invoke function getMailboxUsageStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphmailboxusagestorage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphmailboxusagestorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphmailboxusagestorage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_mailbox_usage_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphmailboxusagestorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_mailbox_usage_storage.metadata = {'url': '/reports/microsoft.graph.getMailboxUsageStorage(period=\'{period}\')'}  # type: ignore

    async def get_office365_activation_counts(
        self,
        **kwargs
    ) -> List["models.microsoftgraphoffice365activationcounts"]:
        """Invoke function getOffice365ActivationCounts.

        Invoke function getOffice365ActivationCounts.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365activationcounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365activationcounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365activationcounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_activation_counts.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365activationcounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_activation_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365ActivationCounts()'}  # type: ignore

    async def get_office365_activations_user_counts(
        self,
        **kwargs
    ) -> List["models.microsoftgraphoffice365activationsusercounts"]:
        """Invoke function getOffice365ActivationsUserCounts.

        Invoke function getOffice365ActivationsUserCounts.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365activationsusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365activationsusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365activationsusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_activations_user_counts.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365activationsusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_activations_user_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365ActivationsUserCounts()'}  # type: ignore

    async def get_office365_activations_user_detail(
        self,
        **kwargs
    ) -> List["models.microsoftgraphoffice365activationsuserdetail"]:
        """Invoke function getOffice365ActivationsUserDetail.

        Invoke function getOffice365ActivationsUserDetail.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365activationsuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365activationsuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365activationsuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_activations_user_detail.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365activationsuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_activations_user_detail.metadata = {'url': '/reports/microsoft.graph.getOffice365ActivationsUserDetail()'}  # type: ignore

    async def get_office365_active_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365activeusercounts"]:
        """Invoke function getOffice365ActiveUserCounts.

        Invoke function getOffice365ActiveUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365activeusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365activeusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365activeusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_active_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365activeusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_active_user_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365ActiveUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_office365_active_user_detail_d389(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphoffice365activeuserdetail"]:
        """Invoke function getOffice365ActiveUserDetail.

        Invoke function getOffice365ActiveUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365activeuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365activeuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365activeuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_active_user_detail_d389.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365activeuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_active_user_detail_d389.metadata = {'url': '/reports/microsoft.graph.getOffice365ActiveUserDetail(date={date})'}  # type: ignore

    async def get_office365_active_user_detail68_ad(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365activeuserdetail"]:
        """Invoke function getOffice365ActiveUserDetail.

        Invoke function getOffice365ActiveUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365activeuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365activeuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365activeuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_active_user_detail68_ad.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365activeuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_active_user_detail68_ad.metadata = {'url': '/reports/microsoft.graph.getOffice365ActiveUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_office365_groups_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365groupsactivitycounts"]:
        """Invoke function getOffice365GroupsActivityCounts.

        Invoke function getOffice365GroupsActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365groupsactivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365groupsactivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365groupsactivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_groups_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365groupsactivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_groups_activity_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_office365_groups_activity_detail81_cc(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphoffice365groupsactivitydetail"]:
        """Invoke function getOffice365GroupsActivityDetail.

        Invoke function getOffice365GroupsActivityDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365groupsactivitydetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365groupsactivitydetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365groupsactivitydetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_groups_activity_detail81_cc.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365groupsactivitydetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_groups_activity_detail81_cc.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityDetail(date={date})'}  # type: ignore

    async def get_office365_groups_activity_detail38_f6(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365groupsactivitydetail"]:
        """Invoke function getOffice365GroupsActivityDetail.

        Invoke function getOffice365GroupsActivityDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365groupsactivitydetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365groupsactivitydetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365groupsactivitydetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_groups_activity_detail38_f6.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365groupsactivitydetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_groups_activity_detail38_f6.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityDetail(period=\'{period}\')'}  # type: ignore

    async def get_office365_groups_activity_file_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365groupsactivityfilecounts"]:
        """Invoke function getOffice365GroupsActivityFileCounts.

        Invoke function getOffice365GroupsActivityFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365groupsactivityfilecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365groupsactivityfilecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365groupsactivityfilecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_groups_activity_file_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365groupsactivityfilecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_groups_activity_file_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityFileCounts(period=\'{period}\')'}  # type: ignore

    async def get_office365_groups_activity_group_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365groupsactivitygroupcounts"]:
        """Invoke function getOffice365GroupsActivityGroupCounts.

        Invoke function getOffice365GroupsActivityGroupCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365groupsactivitygroupcounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365groupsactivitygroupcounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365groupsactivitygroupcounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_groups_activity_group_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365groupsactivitygroupcounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_groups_activity_group_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityGroupCounts(period=\'{period}\')'}  # type: ignore

    async def get_office365_groups_activity_storage(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365groupsactivitystorage"]:
        """Invoke function getOffice365GroupsActivityStorage.

        Invoke function getOffice365GroupsActivityStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365groupsactivitystorage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365groupsactivitystorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365groupsactivitystorage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_groups_activity_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365groupsactivitystorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_groups_activity_storage.metadata = {'url': '/reports/microsoft.graph.getOffice365GroupsActivityStorage(period=\'{period}\')'}  # type: ignore

    async def get_office365_services_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphoffice365servicesusercounts"]:
        """Invoke function getOffice365ServicesUserCounts.

        Invoke function getOffice365ServicesUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphoffice365servicesusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphoffice365servicesusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphoffice365servicesusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_office365_services_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphoffice365servicesusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_office365_services_user_counts.metadata = {'url': '/reports/microsoft.graph.getOffice365ServicesUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_activity_file_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsiteactivitysummary"]:
        """Invoke function getOneDriveActivityFileCounts.

        Invoke function getOneDriveActivityFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsiteactivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsiteactivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsiteactivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_activity_file_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsiteactivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_file_counts.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityFileCounts(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsiteactivitysummary"]:
        """Invoke function getOneDriveActivityUserCounts.

        Invoke function getOneDriveActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsiteactivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsiteactivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsiteactivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsiteactivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_activity_user_detail05_f1(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphonedriveactivityuserdetail"]:
        """Invoke function getOneDriveActivityUserDetail.

        Invoke function getOneDriveActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphonedriveactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphonedriveactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphonedriveactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_activity_user_detail05_f1.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphonedriveactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_user_detail05_f1.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityUserDetail(date={date})'}  # type: ignore

    async def get_one_drive_activity_user_detail_c424(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphonedriveactivityuserdetail"]:
        """Invoke function getOneDriveActivityUserDetail.

        Invoke function getOneDriveActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphonedriveactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphonedriveactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphonedriveactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_activity_user_detail_c424.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphonedriveactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_activity_user_detail_c424.metadata = {'url': '/reports/microsoft.graph.getOneDriveActivityUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_usage_account_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphonedriveusageaccountcounts"]:
        """Invoke function getOneDriveUsageAccountCounts.

        Invoke function getOneDriveUsageAccountCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphonedriveusageaccountcounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphonedriveusageaccountcounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphonedriveusageaccountcounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_usage_account_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphonedriveusageaccountcounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_account_counts.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageAccountCounts(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_usage_account_detail_e827(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphonedriveusageaccountdetail"]:
        """Invoke function getOneDriveUsageAccountDetail.

        Invoke function getOneDriveUsageAccountDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphonedriveusageaccountdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphonedriveusageaccountdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphonedriveusageaccountdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_usage_account_detail_e827.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphonedriveusageaccountdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_account_detail_e827.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageAccountDetail(date={date})'}  # type: ignore

    async def get_one_drive_usage_account_detail_dd7_f(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphonedriveusageaccountdetail"]:
        """Invoke function getOneDriveUsageAccountDetail.

        Invoke function getOneDriveUsageAccountDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphonedriveusageaccountdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphonedriveusageaccountdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphonedriveusageaccountdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_usage_account_detail_dd7_f.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphonedriveusageaccountdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_account_detail_dd7_f.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageAccountDetail(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_usage_file_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphonedriveusagefilecounts"]:
        """Invoke function getOneDriveUsageFileCounts.

        Invoke function getOneDriveUsageFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphonedriveusagefilecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphonedriveusagefilecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphonedriveusagefilecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_usage_file_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphonedriveusagefilecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_file_counts.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageFileCounts(period=\'{period}\')'}  # type: ignore

    async def get_one_drive_usage_storage(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsiteusagestorage"]:
        """Invoke function getOneDriveUsageStorage.

        Invoke function getOneDriveUsageStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsiteusagestorage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsiteusagestorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsiteusagestorage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_one_drive_usage_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsiteusagestorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_one_drive_usage_storage.metadata = {'url': '/reports/microsoft.graph.getOneDriveUsageStorage(period=\'{period}\')'}  # type: ignore

    async def get_relying_party_detailed_summary(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphrelyingpartydetailedsummary"]:
        """Invoke function getRelyingPartyDetailedSummary.

        Invoke function getRelyingPartyDetailedSummary.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphrelyingpartydetailedsummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphrelyingpartydetailedsummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphrelyingpartydetailedsummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_relying_party_detailed_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphrelyingpartydetailedsummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_relying_party_detailed_summary.metadata = {'url': '/reports/microsoft.graph.getRelyingPartyDetailedSummary(period=\'{period}\')'}  # type: ignore

    async def get_share_point_activity_file_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsiteactivitysummary"]:
        """Invoke function getSharePointActivityFileCounts.

        Invoke function getSharePointActivityFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsiteactivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsiteactivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsiteactivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_activity_file_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsiteactivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_file_counts.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityFileCounts(period=\'{period}\')'}  # type: ignore

    async def get_share_point_activity_pages(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointactivitypages"]:
        """Invoke function getSharePointActivityPages.

        Invoke function getSharePointActivityPages.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointactivitypages, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointactivitypages]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointactivitypages"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_activity_pages.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointactivitypages]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_pages.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityPages(period=\'{period}\')'}  # type: ignore

    async def get_share_point_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointactivityusercounts"]:
        """Invoke function getSharePointActivityUserCounts.

        Invoke function getSharePointActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointactivityusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointactivityusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointactivityusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointactivityusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_share_point_activity_user_detail_f3_be(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphsharepointactivityuserdetail"]:
        """Invoke function getSharePointActivityUserDetail.

        Invoke function getSharePointActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_activity_user_detail_f3_be.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_user_detail_f3_be.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityUserDetail(date={date})'}  # type: ignore

    async def get_share_point_activity_user_detail_b778(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointactivityuserdetail"]:
        """Invoke function getSharePointActivityUserDetail.

        Invoke function getSharePointActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_activity_user_detail_b778.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_activity_user_detail_b778.metadata = {'url': '/reports/microsoft.graph.getSharePointActivityUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_share_point_site_usage_detail_d27_a(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphsharepointsiteusagedetail"]:
        """Invoke function getSharePointSiteUsageDetail.

        Invoke function getSharePointSiteUsageDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointsiteusagedetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointsiteusagedetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointsiteusagedetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_site_usage_detail_d27_a.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointsiteusagedetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_detail_d27_a.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageDetail(date={date})'}  # type: ignore

    async def get_share_point_site_usage_detail204_b(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointsiteusagedetail"]:
        """Invoke function getSharePointSiteUsageDetail.

        Invoke function getSharePointSiteUsageDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointsiteusagedetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointsiteusagedetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointsiteusagedetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_site_usage_detail204_b.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointsiteusagedetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_detail204_b.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageDetail(period=\'{period}\')'}  # type: ignore

    async def get_share_point_site_usage_file_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointsiteusagefilecounts"]:
        """Invoke function getSharePointSiteUsageFileCounts.

        Invoke function getSharePointSiteUsageFileCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointsiteusagefilecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointsiteusagefilecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointsiteusagefilecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_site_usage_file_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointsiteusagefilecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_file_counts.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageFileCounts(period=\'{period}\')'}  # type: ignore

    async def get_share_point_site_usage_pages(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointsiteusagepages"]:
        """Invoke function getSharePointSiteUsagePages.

        Invoke function getSharePointSiteUsagePages.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointsiteusagepages, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointsiteusagepages]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointsiteusagepages"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_site_usage_pages.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointsiteusagepages]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_pages.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsagePages(period=\'{period}\')'}  # type: ignore

    async def get_share_point_site_usage_site_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsharepointsiteusagesitecounts"]:
        """Invoke function getSharePointSiteUsageSiteCounts.

        Invoke function getSharePointSiteUsageSiteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsharepointsiteusagesitecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsharepointsiteusagesitecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsharepointsiteusagesitecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_site_usage_site_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsharepointsiteusagesitecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_site_counts.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageSiteCounts(period=\'{period}\')'}  # type: ignore

    async def get_share_point_site_usage_storage(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphsiteusagestorage"]:
        """Invoke function getSharePointSiteUsageStorage.

        Invoke function getSharePointSiteUsageStorage.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphsiteusagestorage, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphsiteusagestorage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphsiteusagestorage"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_share_point_site_usage_storage.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphsiteusagestorage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_share_point_site_usage_storage.metadata = {'url': '/reports/microsoft.graph.getSharePointSiteUsageStorage(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessactivitycounts"]:
        """Invoke function getSkypeForBusinessActivityCounts.

        Invoke function getSkypeForBusinessActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessactivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessactivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessactivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessactivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessactivityusercounts"]:
        """Invoke function getSkypeForBusinessActivityUserCounts.

        Invoke function getSkypeForBusinessActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessactivityusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessactivityusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessactivityusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessactivityusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_activity_user_detail_e4_c9(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessactivityuserdetail"]:
        """Invoke function getSkypeForBusinessActivityUserDetail.

        Invoke function getSkypeForBusinessActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_activity_user_detail_e4_c9.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_user_detail_e4_c9.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityUserDetail(date={date})'}  # type: ignore

    async def get_skype_for_business_activity_user_detail744_e(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessactivityuserdetail"]:
        """Invoke function getSkypeForBusinessActivityUserDetail.

        Invoke function getSkypeForBusinessActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessactivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessactivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessactivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_activity_user_detail744_e.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessactivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_activity_user_detail744_e.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessActivityUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_device_usage_distribution_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessdeviceusagedistributionusercounts"]:
        """Invoke function getSkypeForBusinessDeviceUsageDistributionUserCounts.

        Invoke function getSkypeForBusinessDeviceUsageDistributionUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessdeviceusagedistributionusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessdeviceusagedistributionusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessdeviceusagedistributionusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_device_usage_distribution_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessdeviceusagedistributionusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_distribution_user_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageDistributionUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_device_usage_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessdeviceusageusercounts"]:
        """Invoke function getSkypeForBusinessDeviceUsageUserCounts.

        Invoke function getSkypeForBusinessDeviceUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessdeviceusageusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessdeviceusageusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessdeviceusageusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_device_usage_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessdeviceusageusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_user_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_device_usage_user_detail_a692(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessdeviceusageuserdetail"]:
        """Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessdeviceusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessdeviceusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessdeviceusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_device_usage_user_detail_a692.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessdeviceusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_user_detail_a692.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageUserDetail(date={date})'}  # type: ignore

    async def get_skype_for_business_device_usage_user_detail_e753(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessdeviceusageuserdetail"]:
        """Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        Invoke function getSkypeForBusinessDeviceUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessdeviceusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessdeviceusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessdeviceusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_device_usage_user_detail_e753.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessdeviceusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_device_usage_user_detail_e753.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessDeviceUsageUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_organizer_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessorganizeractivitycounts"]:
        """Invoke function getSkypeForBusinessOrganizerActivityCounts.

        Invoke function getSkypeForBusinessOrganizerActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessorganizeractivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessorganizeractivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessorganizeractivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_organizer_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessorganizeractivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_organizer_activity_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessOrganizerActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_organizer_activity_minute_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessorganizeractivityminutecounts"]:
        """Invoke function getSkypeForBusinessOrganizerActivityMinuteCounts.

        Invoke function getSkypeForBusinessOrganizerActivityMinuteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessorganizeractivityminutecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessorganizeractivityminutecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessorganizeractivityminutecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_organizer_activity_minute_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessorganizeractivityminutecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_organizer_activity_minute_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessOrganizerActivityMinuteCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_organizer_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessorganizeractivityusercounts"]:
        """Invoke function getSkypeForBusinessOrganizerActivityUserCounts.

        Invoke function getSkypeForBusinessOrganizerActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessorganizeractivityusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessorganizeractivityusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessorganizeractivityusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_organizer_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessorganizeractivityusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_organizer_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessOrganizerActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_participant_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessparticipantactivitycounts"]:
        """Invoke function getSkypeForBusinessParticipantActivityCounts.

        Invoke function getSkypeForBusinessParticipantActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessparticipantactivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessparticipantactivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessparticipantactivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_participant_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessparticipantactivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_participant_activity_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessParticipantActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_participant_activity_minute_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessparticipantactivityminutecounts"]:
        """Invoke function getSkypeForBusinessParticipantActivityMinuteCounts.

        Invoke function getSkypeForBusinessParticipantActivityMinuteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessparticipantactivityminutecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessparticipantactivityminutecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessparticipantactivityminutecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_participant_activity_minute_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessparticipantactivityminutecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_participant_activity_minute_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessParticipantActivityMinuteCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_participant_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinessparticipantactivityusercounts"]:
        """Invoke function getSkypeForBusinessParticipantActivityUserCounts.

        Invoke function getSkypeForBusinessParticipantActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinessparticipantactivityusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinessparticipantactivityusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinessparticipantactivityusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_participant_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinessparticipantactivityusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_participant_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessParticipantActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_peer_to_peer_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinesspeertopeeractivitycounts"]:
        """Invoke function getSkypeForBusinessPeerToPeerActivityCounts.

        Invoke function getSkypeForBusinessPeerToPeerActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinesspeertopeeractivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinesspeertopeeractivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinesspeertopeeractivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_peer_to_peer_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinesspeertopeeractivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_peer_to_peer_activity_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessPeerToPeerActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_peer_to_peer_activity_minute_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinesspeertopeeractivityminutecounts"]:
        """Invoke function getSkypeForBusinessPeerToPeerActivityMinuteCounts.

        Invoke function getSkypeForBusinessPeerToPeerActivityMinuteCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinesspeertopeeractivityminutecounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinesspeertopeeractivityminutecounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinesspeertopeeractivityminutecounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_peer_to_peer_activity_minute_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinesspeertopeeractivityminutecounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_peer_to_peer_activity_minute_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessPeerToPeerActivityMinuteCounts(period=\'{period}\')'}  # type: ignore

    async def get_skype_for_business_peer_to_peer_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphskypeforbusinesspeertopeeractivityusercounts"]:
        """Invoke function getSkypeForBusinessPeerToPeerActivityUserCounts.

        Invoke function getSkypeForBusinessPeerToPeerActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphskypeforbusinesspeertopeeractivityusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphskypeforbusinesspeertopeeractivityusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphskypeforbusinesspeertopeeractivityusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skype_for_business_peer_to_peer_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphskypeforbusinesspeertopeeractivityusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skype_for_business_peer_to_peer_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getSkypeForBusinessPeerToPeerActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_teams_device_usage_distribution_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphteamsdeviceusagedistributionusercounts"]:
        """Invoke function getTeamsDeviceUsageDistributionUserCounts.

        Invoke function getTeamsDeviceUsageDistributionUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsdeviceusagedistributionusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsdeviceusagedistributionusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsdeviceusagedistributionusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_device_usage_distribution_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsdeviceusagedistributionusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_device_usage_distribution_user_counts.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageDistributionUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_teams_device_usage_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphteamsdeviceusageusercounts"]:
        """Invoke function getTeamsDeviceUsageUserCounts.

        Invoke function getTeamsDeviceUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsdeviceusageusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsdeviceusageusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsdeviceusageusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_device_usage_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsdeviceusageusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_device_usage_user_counts.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_teams_device_usage_user_detail7148(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphteamsdeviceusageuserdetail"]:
        """Invoke function getTeamsDeviceUsageUserDetail.

        Invoke function getTeamsDeviceUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsdeviceusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsdeviceusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsdeviceusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_device_usage_user_detail7148.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsdeviceusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_device_usage_user_detail7148.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageUserDetail(date={date})'}  # type: ignore

    async def get_teams_device_usage_user_detail7565(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphteamsdeviceusageuserdetail"]:
        """Invoke function getTeamsDeviceUsageUserDetail.

        Invoke function getTeamsDeviceUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsdeviceusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsdeviceusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsdeviceusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_device_usage_user_detail7565.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsdeviceusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_device_usage_user_detail7565.metadata = {'url': '/reports/microsoft.graph.getTeamsDeviceUsageUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_teams_user_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphteamsuseractivitycounts"]:
        """Invoke function getTeamsUserActivityCounts.

        Invoke function getTeamsUserActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsuseractivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsuseractivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsuseractivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_user_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsuseractivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_user_activity_counts.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_teams_user_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphteamsuseractivityusercounts"]:
        """Invoke function getTeamsUserActivityUserCounts.

        Invoke function getTeamsUserActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsuseractivityusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsuseractivityusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsuseractivityusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_user_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsuseractivityusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_user_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_teams_user_activity_user_detail_a3_f1(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphteamsuseractivityuserdetail"]:
        """Invoke function getTeamsUserActivityUserDetail.

        Invoke function getTeamsUserActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsuseractivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsuseractivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsuseractivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_user_activity_user_detail_a3_f1.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsuseractivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_user_activity_user_detail_a3_f1.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityUserDetail(date={date})'}  # type: ignore

    async def get_teams_user_activity_user_detail_eb13(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphteamsuseractivityuserdetail"]:
        """Invoke function getTeamsUserActivityUserDetail.

        Invoke function getTeamsUserActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphteamsuseractivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphteamsuseractivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphteamsuseractivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_teams_user_activity_user_detail_eb13.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphteamsuseractivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_teams_user_activity_user_detail_eb13.metadata = {'url': '/reports/microsoft.graph.getTeamsUserActivityUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_tenant_secure_scores(
        self,
        period: int,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function getTenantSecureScores.

        Invoke function getTenantSecureScores.

        :param period:
        :type period: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_tenant_secure_scores.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'int', maximum=2147483647, minimum=-2147483648),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_tenant_secure_scores.metadata = {'url': '/reports/microsoft.graph.getTenantSecureScores(period={period})'}  # type: ignore

    async def get_yammer_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammeractivitysummary"]:
        """Invoke function getYammerActivityCounts.

        Invoke function getYammerActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammeractivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammeractivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammeractivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammeractivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_counts.metadata = {'url': '/reports/microsoft.graph.getYammerActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_yammer_activity_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammeractivitysummary"]:
        """Invoke function getYammerActivityUserCounts.

        Invoke function getYammerActivityUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammeractivitysummary, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammeractivitysummary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammeractivitysummary"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_activity_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammeractivitysummary]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_user_counts.metadata = {'url': '/reports/microsoft.graph.getYammerActivityUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_yammer_activity_user_detail_ac30(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphyammeractivityuserdetail"]:
        """Invoke function getYammerActivityUserDetail.

        Invoke function getYammerActivityUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammeractivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammeractivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammeractivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_activity_user_detail_ac30.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammeractivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_user_detail_ac30.metadata = {'url': '/reports/microsoft.graph.getYammerActivityUserDetail(date={date})'}  # type: ignore

    async def get_yammer_activity_user_detail15_a5(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammeractivityuserdetail"]:
        """Invoke function getYammerActivityUserDetail.

        Invoke function getYammerActivityUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammeractivityuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammeractivityuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammeractivityuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_activity_user_detail15_a5.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammeractivityuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_activity_user_detail15_a5.metadata = {'url': '/reports/microsoft.graph.getYammerActivityUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_yammer_device_usage_distribution_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammerdeviceusagedistributionusercounts"]:
        """Invoke function getYammerDeviceUsageDistributionUserCounts.

        Invoke function getYammerDeviceUsageDistributionUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammerdeviceusagedistributionusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammerdeviceusagedistributionusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammerdeviceusagedistributionusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_device_usage_distribution_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammerdeviceusagedistributionusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_distribution_user_counts.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageDistributionUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_yammer_device_usage_user_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammerdeviceusageusercounts"]:
        """Invoke function getYammerDeviceUsageUserCounts.

        Invoke function getYammerDeviceUsageUserCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammerdeviceusageusercounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammerdeviceusageusercounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammerdeviceusageusercounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_device_usage_user_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammerdeviceusageusercounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_user_counts.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageUserCounts(period=\'{period}\')'}  # type: ignore

    async def get_yammer_device_usage_user_detail_d0_ac(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphyammerdeviceusageuserdetail"]:
        """Invoke function getYammerDeviceUsageUserDetail.

        Invoke function getYammerDeviceUsageUserDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammerdeviceusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammerdeviceusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammerdeviceusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_device_usage_user_detail_d0_ac.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammerdeviceusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_user_detail_d0_ac.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageUserDetail(date={date})'}  # type: ignore

    async def get_yammer_device_usage_user_detail_cfad(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammerdeviceusageuserdetail"]:
        """Invoke function getYammerDeviceUsageUserDetail.

        Invoke function getYammerDeviceUsageUserDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammerdeviceusageuserdetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammerdeviceusageuserdetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammerdeviceusageuserdetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_device_usage_user_detail_cfad.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammerdeviceusageuserdetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_device_usage_user_detail_cfad.metadata = {'url': '/reports/microsoft.graph.getYammerDeviceUsageUserDetail(period=\'{period}\')'}  # type: ignore

    async def get_yammer_groups_activity_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammergroupsactivitycounts"]:
        """Invoke function getYammerGroupsActivityCounts.

        Invoke function getYammerGroupsActivityCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammergroupsactivitycounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammergroupsactivitycounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammergroupsactivitycounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_groups_activity_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammergroupsactivitycounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_groups_activity_counts.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityCounts(period=\'{period}\')'}  # type: ignore

    async def get_yammer_groups_activity_detail_da9_a(
        self,
        date: datetime.date,
        **kwargs
    ) -> List["models.microsoftgraphyammergroupsactivitydetail"]:
        """Invoke function getYammerGroupsActivityDetail.

        Invoke function getYammerGroupsActivityDetail.

        :param date:
        :type date: ~datetime.date
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammergroupsactivitydetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammergroupsactivitydetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammergroupsactivitydetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_groups_activity_detail_da9_a.metadata['url']  # type: ignore
        path_format_arguments = {
            'date': self._serialize.url("date", date, 'date'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammergroupsactivitydetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_groups_activity_detail_da9_a.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityDetail(date={date})'}  # type: ignore

    async def get_yammer_groups_activity_detail0_d7_d(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammergroupsactivitydetail"]:
        """Invoke function getYammerGroupsActivityDetail.

        Invoke function getYammerGroupsActivityDetail.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammergroupsactivitydetail, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammergroupsactivitydetail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammergroupsactivitydetail"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_groups_activity_detail0_d7_d.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammergroupsactivitydetail]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_groups_activity_detail0_d7_d.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityDetail(period=\'{period}\')'}  # type: ignore

    async def get_yammer_groups_activity_group_counts(
        self,
        period: str,
        **kwargs
    ) -> List["models.microsoftgraphyammergroupsactivitygroupcounts"]:
        """Invoke function getYammerGroupsActivityGroupCounts.

        Invoke function getYammerGroupsActivityGroupCounts.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of microsoftgraphyammergroupsactivitygroupcounts, or the result of cls(response)
        :rtype: list[~reports.models.microsoftgraphyammergroupsactivitygroupcounts]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.microsoftgraphyammergroupsactivitygroupcounts"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_yammer_groups_activity_group_counts.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[microsoftgraphyammergroupsactivitygroupcounts]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_yammer_groups_activity_group_counts.metadata = {'url': '/reports/microsoft.graph.getYammerGroupsActivityGroupCounts(period=\'{period}\')'}  # type: ignore

    async def managed_device_enrollment_abandonment_details(
        self,
        skip: int,
        top: int,
        filter: str,
        skip_token: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentAbandonmentDetails.

        Invoke function managedDeviceEnrollmentAbandonmentDetails.

        :param skip:
        :type skip: int
        :param top:
        :type top: int
        :param filter:
        :type filter: str
        :param skip_token:
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_abandonment_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'skip': self._serialize.url("skip", skip, 'int', maximum=2147483647, minimum=-2147483648),
            'top': self._serialize.url("top", top, 'int', maximum=2147483647, minimum=-2147483648),
            'filter': self._serialize.url("filter", filter, 'str'),
            'skipToken': self._serialize.url("skip_token", skip_token, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_abandonment_details.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentAbandonmentDetails(skip={skip},top={top},filter=\'{filter}\',skipToken=\'{skipToken}\')'}  # type: ignore

    async def managed_device_enrollment_abandonment_summary(
        self,
        skip: int,
        top: int,
        filter: str,
        skip_token: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentAbandonmentSummary.

        Invoke function managedDeviceEnrollmentAbandonmentSummary.

        :param skip:
        :type skip: int
        :param top:
        :type top: int
        :param filter:
        :type filter: str
        :param skip_token:
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_abandonment_summary.metadata['url']  # type: ignore
        path_format_arguments = {
            'skip': self._serialize.url("skip", skip, 'int', maximum=2147483647, minimum=-2147483648),
            'top': self._serialize.url("top", top, 'int', maximum=2147483647, minimum=-2147483648),
            'filter': self._serialize.url("filter", filter, 'str'),
            'skipToken': self._serialize.url("skip_token", skip_token, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_abandonment_summary.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentAbandonmentSummary(skip={skip},top={top},filter=\'{filter}\',skipToken=\'{skipToken}\')'}  # type: ignore

    async def managed_device_enrollment_failure_details027_e(
        self,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentFailureDetails.

        Invoke function managedDeviceEnrollmentFailureDetails.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_failure_details027_e.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_failure_details027_e.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentFailureDetails()'}  # type: ignore

    async def managed_device_enrollment_failure_details2_b3_d(
        self,
        skip: int,
        top: int,
        filter: str,
        skip_token: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentFailureDetails.

        Invoke function managedDeviceEnrollmentFailureDetails.

        :param skip:
        :type skip: int
        :param top:
        :type top: int
        :param filter:
        :type filter: str
        :param skip_token:
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_failure_details2_b3_d.metadata['url']  # type: ignore
        path_format_arguments = {
            'skip': self._serialize.url("skip", skip, 'int', maximum=2147483647, minimum=-2147483648),
            'top': self._serialize.url("top", top, 'int', maximum=2147483647, minimum=-2147483648),
            'filter': self._serialize.url("filter", filter, 'str'),
            'skipToken': self._serialize.url("skip_token", skip_token, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_failure_details2_b3_d.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentFailureDetails(skip={skip},top={top},filter=\'{filter}\',skipToken=\'{skipToken}\')'}  # type: ignore

    async def managed_device_enrollment_failure_trends(
        self,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentFailureTrends.

        Invoke function managedDeviceEnrollmentFailureTrends.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_failure_trends.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_failure_trends.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentFailureTrends()'}  # type: ignore

    async def managed_device_enrollment_top_failures4669(
        self,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentTopFailures.

        Invoke function managedDeviceEnrollmentTopFailures.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_top_failures4669.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_top_failures4669.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentTopFailures()'}  # type: ignore

    async def managed_device_enrollment_top_failures_afd1(
        self,
        period: str,
        **kwargs
    ) -> "models.microsoftgraphreport":
        """Invoke function managedDeviceEnrollmentTopFailures.

        Invoke function managedDeviceEnrollmentTopFailures.

        :param period:
        :type period: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphreport, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphreport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphreport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.managed_device_enrollment_top_failures_afd1.metadata['url']  # type: ignore
        path_format_arguments = {
            'period': self._serialize.url("period", period, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphreport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    managed_device_enrollment_top_failures_afd1.metadata = {'url': '/reports/microsoft.graph.managedDeviceEnrollmentTopFailures(period=\'{period}\')'}  # type: ignore

    def list_monthly_print_usage_summaries_by_printer(
        self,
        orderby: Optional[List[Union[str, "models.Enum52"]]] = None,
        select: Optional[List[Union[str, "models.Enum53"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofprintusagesummarybyprinter0"]:
        """Get monthlyPrintUsageSummariesByPrinter from reports.

        Get monthlyPrintUsageSummariesByPrinter from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum52]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum53]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofprintusagesummarybyprinter0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofprintusagesummarybyprinter0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofprintusagesummarybyprinter0"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_monthly_print_usage_summaries_by_printer.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofprintusagesummarybyprinter0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_monthly_print_usage_summaries_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter'}  # type: ignore

    async def create_monthly_print_usage_summaries_by_printer(
        self,
        body: "models.microsoftgraphprintusagesummarybyprinter",
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyprinter":
        """Create new navigation property to monthlyPrintUsageSummariesByPrinter for reports.

        Create new navigation property to monthlyPrintUsageSummariesByPrinter for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyprinter, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyprinter"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_monthly_print_usage_summaries_by_printer.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyprinter')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyprinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_monthly_print_usage_summaries_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter'}  # type: ignore

    async def get_monthly_print_usage_summaries_by_printer(
        self,
        print_usage_summary_by_printer_id: str,
        select: Optional[List[Union[str, "models.Enum54"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyprinter":
        """Get monthlyPrintUsageSummariesByPrinter from reports.

        Get monthlyPrintUsageSummariesByPrinter from reports.

        :param print_usage_summary_by_printer_id: key: id of PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum54]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyprinter, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyprinter"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_monthly_print_usage_summaries_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyprinter', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_monthly_print_usage_summaries_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    async def update_monthly_print_usage_summaries_by_printer(
        self,
        print_usage_summary_by_printer_id: str,
        body: "models.microsoftgraphprintusagesummarybyprinter",
        **kwargs
    ) -> None:
        """Update the navigation property monthlyPrintUsageSummariesByPrinter in reports.

        Update the navigation property monthlyPrintUsageSummariesByPrinter in reports.

        :param print_usage_summary_by_printer_id: key: id of PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyprinter
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_monthly_print_usage_summaries_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyprinter')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_monthly_print_usage_summaries_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    async def delete_monthly_print_usage_summaries_by_printer(
        self,
        print_usage_summary_by_printer_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property monthlyPrintUsageSummariesByPrinter for reports.

        Delete navigation property monthlyPrintUsageSummariesByPrinter for reports.

        :param print_usage_summary_by_printer_id: key: id of PrintUsageSummaryByPrinter.
        :type print_usage_summary_by_printer_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_monthly_print_usage_summaries_by_printer.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByPrinter-id': self._serialize.url("print_usage_summary_by_printer_id", print_usage_summary_by_printer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_monthly_print_usage_summaries_by_printer.metadata = {'url': '/reports/monthlyPrintUsageSummariesByPrinter/{PrintUsageSummaryByPrinter-id}'}  # type: ignore

    def list_monthly_print_usage_summaries_by_user(
        self,
        orderby: Optional[List[Union[str, "models.Enum55"]]] = None,
        select: Optional[List[Union[str, "models.Enum56"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofprintusagesummarybyuser0"]:
        """Get monthlyPrintUsageSummariesByUser from reports.

        Get monthlyPrintUsageSummariesByUser from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum55]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum56]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofprintusagesummarybyuser0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofprintusagesummarybyuser0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofprintusagesummarybyuser0"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_monthly_print_usage_summaries_by_user.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofprintusagesummarybyuser0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_monthly_print_usage_summaries_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser'}  # type: ignore

    async def create_monthly_print_usage_summaries_by_user(
        self,
        body: "models.microsoftgraphprintusagesummarybyuser",
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyuser":
        """Create new navigation property to monthlyPrintUsageSummariesByUser for reports.

        Create new navigation property to monthlyPrintUsageSummariesByUser for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyuser
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyuser, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyuser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyuser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_monthly_print_usage_summaries_by_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyuser')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyuser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_monthly_print_usage_summaries_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser'}  # type: ignore

    async def get_monthly_print_usage_summaries_by_user(
        self,
        print_usage_summary_by_user_id: str,
        select: Optional[List[Union[str, "models.Enum57"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphprintusagesummarybyuser":
        """Get monthlyPrintUsageSummariesByUser from reports.

        Get monthlyPrintUsageSummariesByUser from reports.

        :param print_usage_summary_by_user_id: key: id of PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum57]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphprintusagesummarybyuser, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphprintusagesummarybyuser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphprintusagesummarybyuser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_monthly_print_usage_summaries_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphprintusagesummarybyuser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_monthly_print_usage_summaries_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    async def update_monthly_print_usage_summaries_by_user(
        self,
        print_usage_summary_by_user_id: str,
        body: "models.microsoftgraphprintusagesummarybyuser",
        **kwargs
    ) -> None:
        """Update the navigation property monthlyPrintUsageSummariesByUser in reports.

        Update the navigation property monthlyPrintUsageSummariesByUser in reports.

        :param print_usage_summary_by_user_id: key: id of PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphprintusagesummarybyuser
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_monthly_print_usage_summaries_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphprintusagesummarybyuser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_monthly_print_usage_summaries_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    async def delete_monthly_print_usage_summaries_by_user(
        self,
        print_usage_summary_by_user_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property monthlyPrintUsageSummariesByUser for reports.

        Delete navigation property monthlyPrintUsageSummariesByUser for reports.

        :param print_usage_summary_by_user_id: key: id of PrintUsageSummaryByUser.
        :type print_usage_summary_by_user_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_monthly_print_usage_summaries_by_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'PrintUsageSummaryByUser-id': self._serialize.url("print_usage_summary_by_user_id", print_usage_summary_by_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_monthly_print_usage_summaries_by_user.metadata = {'url': '/reports/monthlyPrintUsageSummariesByUser/{PrintUsageSummaryByUser-id}'}  # type: ignore

    def list_user_credential_usage_details(
        self,
        orderby: Optional[List[Union[str, "models.Enum58"]]] = None,
        select: Optional[List[Union[str, "models.Enum59"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.collectionofusercredentialusagedetails"]:
        """Get userCredentialUsageDetails from reports.

        Get userCredentialUsageDetails from reports.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~reports.models.Enum58]
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum59]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either collectionofusercredentialusagedetails or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~reports.models.collectionofusercredentialusagedetails]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.collectionofusercredentialusagedetails"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_user_credential_usage_details.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('collectionofusercredentialusagedetails', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.odataerror, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_user_credential_usage_details.metadata = {'url': '/reports/userCredentialUsageDetails'}  # type: ignore

    async def create_user_credential_usage_details(
        self,
        body: "models.microsoftgraphusercredentialusagedetails",
        **kwargs
    ) -> "models.microsoftgraphusercredentialusagedetails":
        """Create new navigation property to userCredentialUsageDetails for reports.

        Create new navigation property to userCredentialUsageDetails for reports.

        :param body: New navigation property.
        :type body: ~reports.models.microsoftgraphusercredentialusagedetails
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphusercredentialusagedetails, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphusercredentialusagedetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphusercredentialusagedetails"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_user_credential_usage_details.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphusercredentialusagedetails')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphusercredentialusagedetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_user_credential_usage_details.metadata = {'url': '/reports/userCredentialUsageDetails'}  # type: ignore

    async def get_user_credential_usage_details(
        self,
        user_credential_usage_details_id: str,
        select: Optional[List[Union[str, "models.Enum60"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.microsoftgraphusercredentialusagedetails":
        """Get userCredentialUsageDetails from reports.

        Get userCredentialUsageDetails from reports.

        :param user_credential_usage_details_id: key: id of userCredentialUsageDetails.
        :type user_credential_usage_details_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~reports.models.Enum60]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: microsoftgraphusercredentialusagedetails, or the result of cls(response)
        :rtype: ~reports.models.microsoftgraphusercredentialusagedetails
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.microsoftgraphusercredentialusagedetails"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user_credential_usage_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'userCredentialUsageDetails-id': self._serialize.url("user_credential_usage_details_id", user_credential_usage_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('microsoftgraphusercredentialusagedetails', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_credential_usage_details.metadata = {'url': '/reports/userCredentialUsageDetails/{userCredentialUsageDetails-id}'}  # type: ignore

    async def update_user_credential_usage_details(
        self,
        user_credential_usage_details_id: str,
        body: "models.microsoftgraphusercredentialusagedetails",
        **kwargs
    ) -> None:
        """Update the navigation property userCredentialUsageDetails in reports.

        Update the navigation property userCredentialUsageDetails in reports.

        :param user_credential_usage_details_id: key: id of userCredentialUsageDetails.
        :type user_credential_usage_details_id: str
        :param body: New navigation property values.
        :type body: ~reports.models.microsoftgraphusercredentialusagedetails
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_user_credential_usage_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'userCredentialUsageDetails-id': self._serialize.url("user_credential_usage_details_id", user_credential_usage_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'microsoftgraphusercredentialusagedetails')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_user_credential_usage_details.metadata = {'url': '/reports/userCredentialUsageDetails/{userCredentialUsageDetails-id}'}  # type: ignore

    async def delete_user_credential_usage_details(
        self,
        user_credential_usage_details_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property userCredentialUsageDetails for reports.

        Delete navigation property userCredentialUsageDetails for reports.

        :param user_credential_usage_details_id: key: id of userCredentialUsageDetails.
        :type user_credential_usage_details_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_user_credential_usage_details.metadata['url']  # type: ignore
        path_format_arguments = {
            'userCredentialUsageDetails-id': self._serialize.url("user_credential_usage_details_id", user_credential_usage_details_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.odataerror, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_user_credential_usage_details.metadata = {'url': '/reports/userCredentialUsageDetails/{userCredentialUsageDetails-id}'}  # type: ignore
