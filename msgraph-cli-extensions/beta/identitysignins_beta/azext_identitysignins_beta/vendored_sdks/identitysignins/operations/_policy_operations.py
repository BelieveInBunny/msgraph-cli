# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class PolicyOperations(object):
    """PolicyOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~identity_sign_ins.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_activity_based_timeout_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum202"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum203"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum204"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfActivityBasedTimeoutPolicy"]
        """Get activityBasedTimeoutPolicies from policies.

        Get activityBasedTimeoutPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum202]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum203]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum204]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfActivityBasedTimeoutPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfActivityBasedTimeoutPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_activity_based_timeout_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfActivityBasedTimeoutPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies'}  # type: ignore

    def create_activity_based_timeout_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphActivityBasedTimeoutPolicy"
        """Create new navigation property to activityBasedTimeoutPolicies for policies.

        Create new navigation property to activityBasedTimeoutPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphActivityBasedTimeoutPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphActivityBasedTimeoutPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphActivityBasedTimeoutPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_activity_based_timeout_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphActivityBasedTimeoutPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphActivityBasedTimeoutPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies'}  # type: ignore

    def get_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum205"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum206"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphActivityBasedTimeoutPolicy"
        """Get activityBasedTimeoutPolicies from policies.

        Get activityBasedTimeoutPolicies from policies.

        :param activity_based_timeout_policy_id: key: id of activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum205]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum206]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphActivityBasedTimeoutPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphActivityBasedTimeoutPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphActivityBasedTimeoutPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphActivityBasedTimeoutPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    def update_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property activityBasedTimeoutPolicies in policies.

        Update the navigation property activityBasedTimeoutPolicies in policies.

        :param activity_based_timeout_policy_id: key: id of activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphActivityBasedTimeoutPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphActivityBasedTimeoutPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    def delete_activity_based_timeout_policy(
        self,
        activity_based_timeout_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property activityBasedTimeoutPolicies for policies.

        Delete navigation property activityBasedTimeoutPolicies for policies.

        :param activity_based_timeout_policy_id: key: id of activityBasedTimeoutPolicy.
        :type activity_based_timeout_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_activity_based_timeout_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'activityBasedTimeoutPolicy-id': self._serialize.url("activity_based_timeout_policy_id", activity_based_timeout_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_activity_based_timeout_policy.metadata = {'url': '/policies/activityBasedTimeoutPolicies/{activityBasedTimeoutPolicy-id}'}  # type: ignore

    def get_admin_consent_request_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum207"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAdminConsentRequestPolicy"
        """Get adminConsentRequestPolicy from policies.

        Get adminConsentRequestPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum207]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAdminConsentRequestPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphAdminConsentRequestPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAdminConsentRequestPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_admin_consent_request_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAdminConsentRequestPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_admin_consent_request_policy.metadata = {'url': '/policies/adminConsentRequestPolicy'}  # type: ignore

    def update_admin_consent_request_policy(
        self,
        id=None,  # type: Optional[str]
        is_enabled=None,  # type: Optional[bool]
        notify_reviewers=None,  # type: Optional[bool]
        reminders_enabled=None,  # type: Optional[bool]
        request_duration_in_days=None,  # type: Optional[int]
        reviewers=None,  # type: Optional[List["models.MicrosoftGraphAccessReviewScope"]]
        version=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property adminConsentRequestPolicy in policies.

        Update the navigation property adminConsentRequestPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param is_enabled:
        :type is_enabled: bool
        :param notify_reviewers:
        :type notify_reviewers: bool
        :param reminders_enabled:
        :type reminders_enabled: bool
        :param request_duration_in_days:
        :type request_duration_in_days: int
        :param reviewers:
        :type reviewers: list[~identity_sign_ins.models.MicrosoftGraphAccessReviewScope]
        :param version:
        :type version: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAdminConsentRequestPolicy(id=id, is_enabled=is_enabled, notify_reviewers=notify_reviewers, reminders_enabled=reminders_enabled, request_duration_in_days=request_duration_in_days, reviewers=reviewers, version=version)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_admin_consent_request_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAdminConsentRequestPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_admin_consent_request_policy.metadata = {'url': '/policies/adminConsentRequestPolicy'}  # type: ignore

    def delete_admin_consent_request_policy(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property adminConsentRequestPolicy for policies.

        Delete navigation property adminConsentRequestPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_admin_consent_request_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_admin_consent_request_policy.metadata = {'url': '/policies/adminConsentRequestPolicy'}  # type: ignore

    def get_authentication_flow_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum208"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAuthenticationFlowsPolicy"
        """Get authenticationFlowsPolicy from policies.

        Get authenticationFlowsPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum208]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAuthenticationFlowsPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphAuthenticationFlowsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAuthenticationFlowsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_authentication_flow_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAuthenticationFlowsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_authentication_flow_policy.metadata = {'url': '/policies/authenticationFlowsPolicy'}  # type: ignore

    def update_authentication_flow_policy(
        self,
        id=None,  # type: Optional[str]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        is_enabled=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property authenticationFlowsPolicy in policies.

        Update the navigation property authenticationFlowsPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param is_enabled:
        :type is_enabled: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAuthenticationFlowsPolicy(id=id, description=description, display_name=display_name, is_enabled=is_enabled)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_authentication_flow_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAuthenticationFlowsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_authentication_flow_policy.metadata = {'url': '/policies/authenticationFlowsPolicy'}  # type: ignore

    def delete_authentication_flow_policy(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property authenticationFlowsPolicy for policies.

        Delete navigation property authenticationFlowsPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_authentication_flow_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_authentication_flow_policy.metadata = {'url': '/policies/authenticationFlowsPolicy'}  # type: ignore

    def list_authorization_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum209"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum210"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfAuthorizationPolicy"]
        """Get authorizationPolicy from policies.

        Get authorizationPolicy from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum209]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum210]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAuthorizationPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfAuthorizationPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAuthorizationPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_authorization_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAuthorizationPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_authorization_policy.metadata = {'url': '/policies/authorizationPolicy'}  # type: ignore

    def create_authorization_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        allowed_to_sign_up_email_based_subscriptions=None,  # type: Optional[bool]
        allowed_to_use_sspr=None,  # type: Optional[bool]
        allow_email_verified_users_to_join_organization=None,  # type: Optional[bool]
        allow_invites_from=None,  # type: Optional[Union[str, "models.MicrosoftGraphAllowInvitesFrom"]]
        block_msol_power_shell=None,  # type: Optional[bool]
        default_user_role_permissions=None,  # type: Optional["models.MicrosoftGraphDefaultUserRolePermissions"]
        enabled_preview_features=None,  # type: Optional[List[str]]
        guest_user_role_id=None,  # type: Optional[str]
        permission_grant_policy_ids_assigned_to_default_user_role=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAuthorizationPolicy"
        """Create new navigation property to authorizationPolicy for policies.

        Create new navigation property to authorizationPolicy for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param allowed_to_sign_up_email_based_subscriptions:
        :type allowed_to_sign_up_email_based_subscriptions: bool
        :param allowed_to_use_sspr:
        :type allowed_to_use_sspr: bool
        :param allow_email_verified_users_to_join_organization:
        :type allow_email_verified_users_to_join_organization: bool
        :param allow_invites_from:
        :type allow_invites_from: str or ~identity_sign_ins.models.MicrosoftGraphAllowInvitesFrom
        :param block_msol_power_shell:
        :type block_msol_power_shell: bool
        :param default_user_role_permissions: defaultUserRolePermissions.
        :type default_user_role_permissions: ~identity_sign_ins.models.MicrosoftGraphDefaultUserRolePermissions
        :param enabled_preview_features:
        :type enabled_preview_features: list[str]
        :param guest_user_role_id:
        :type guest_user_role_id: str
        :param permission_grant_policy_ids_assigned_to_default_user_role:
        :type permission_grant_policy_ids_assigned_to_default_user_role: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAuthorizationPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphAuthorizationPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAuthorizationPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAuthorizationPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, allowed_to_sign_up_email_based_subscriptions=allowed_to_sign_up_email_based_subscriptions, allowed_to_use_sspr=allowed_to_use_sspr, allow_email_verified_users_to_join_organization=allow_email_verified_users_to_join_organization, allow_invites_from=allow_invites_from, block_msol_power_shell=block_msol_power_shell, default_user_role_permissions=default_user_role_permissions, enabled_preview_features=enabled_preview_features, guest_user_role_id=guest_user_role_id, permission_grant_policy_ids_assigned_to_default_user_role=permission_grant_policy_ids_assigned_to_default_user_role)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_authorization_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAuthorizationPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAuthorizationPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_authorization_policy.metadata = {'url': '/policies/authorizationPolicy'}  # type: ignore

    def get_authorization_policy(
        self,
        authorization_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum211"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphAuthorizationPolicy"
        """Get authorizationPolicy from policies.

        Get authorizationPolicy from policies.

        :param authorization_policy_id: key: id of authorizationPolicy.
        :type authorization_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum211]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAuthorizationPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphAuthorizationPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAuthorizationPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_authorization_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'authorizationPolicy-id': self._serialize.url("authorization_policy_id", authorization_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAuthorizationPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_authorization_policy.metadata = {'url': '/policies/authorizationPolicy/{authorizationPolicy-id}'}  # type: ignore

    def update_authorization_policy(
        self,
        authorization_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        allowed_to_sign_up_email_based_subscriptions=None,  # type: Optional[bool]
        allowed_to_use_sspr=None,  # type: Optional[bool]
        allow_email_verified_users_to_join_organization=None,  # type: Optional[bool]
        allow_invites_from=None,  # type: Optional[Union[str, "models.MicrosoftGraphAllowInvitesFrom"]]
        block_msol_power_shell=None,  # type: Optional[bool]
        default_user_role_permissions=None,  # type: Optional["models.MicrosoftGraphDefaultUserRolePermissions"]
        enabled_preview_features=None,  # type: Optional[List[str]]
        guest_user_role_id=None,  # type: Optional[str]
        permission_grant_policy_ids_assigned_to_default_user_role=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property authorizationPolicy in policies.

        Update the navigation property authorizationPolicy in policies.

        :param authorization_policy_id: key: id of authorizationPolicy.
        :type authorization_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param allowed_to_sign_up_email_based_subscriptions:
        :type allowed_to_sign_up_email_based_subscriptions: bool
        :param allowed_to_use_sspr:
        :type allowed_to_use_sspr: bool
        :param allow_email_verified_users_to_join_organization:
        :type allow_email_verified_users_to_join_organization: bool
        :param allow_invites_from:
        :type allow_invites_from: str or ~identity_sign_ins.models.MicrosoftGraphAllowInvitesFrom
        :param block_msol_power_shell:
        :type block_msol_power_shell: bool
        :param default_user_role_permissions: defaultUserRolePermissions.
        :type default_user_role_permissions: ~identity_sign_ins.models.MicrosoftGraphDefaultUserRolePermissions
        :param enabled_preview_features:
        :type enabled_preview_features: list[str]
        :param guest_user_role_id:
        :type guest_user_role_id: str
        :param permission_grant_policy_ids_assigned_to_default_user_role:
        :type permission_grant_policy_ids_assigned_to_default_user_role: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphAuthorizationPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, allowed_to_sign_up_email_based_subscriptions=allowed_to_sign_up_email_based_subscriptions, allowed_to_use_sspr=allowed_to_use_sspr, allow_email_verified_users_to_join_organization=allow_email_verified_users_to_join_organization, allow_invites_from=allow_invites_from, block_msol_power_shell=block_msol_power_shell, default_user_role_permissions=default_user_role_permissions, enabled_preview_features=enabled_preview_features, guest_user_role_id=guest_user_role_id, permission_grant_policy_ids_assigned_to_default_user_role=permission_grant_policy_ids_assigned_to_default_user_role)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_authorization_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'authorizationPolicy-id': self._serialize.url("authorization_policy_id", authorization_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphAuthorizationPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_authorization_policy.metadata = {'url': '/policies/authorizationPolicy/{authorizationPolicy-id}'}  # type: ignore

    def delete_authorization_policy(
        self,
        authorization_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property authorizationPolicy for policies.

        Delete navigation property authorizationPolicy for policies.

        :param authorization_policy_id: key: id of authorizationPolicy.
        :type authorization_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_authorization_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'authorizationPolicy-id': self._serialize.url("authorization_policy_id", authorization_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_authorization_policy.metadata = {'url': '/policies/authorizationPolicy/{authorizationPolicy-id}'}  # type: ignore

    def get_b2_c_authentication_method_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum212"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphB2CAuthenticationMethodsPolicy"
        """Get b2cAuthenticationMethodsPolicy from policies.

        Get b2cAuthenticationMethodsPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum212]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphB2CAuthenticationMethodsPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphB2CAuthenticationMethodsPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphB2CAuthenticationMethodsPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_b2_c_authentication_method_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphB2CAuthenticationMethodsPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_b2_c_authentication_method_policy.metadata = {'url': '/policies/b2cAuthenticationMethodsPolicy'}  # type: ignore

    def update_b2_c_authentication_method_policy(
        self,
        id=None,  # type: Optional[str]
        is_email_password_authentication_enabled=None,  # type: Optional[bool]
        is_phone_one_time_password_authentication_enabled=None,  # type: Optional[bool]
        is_user_name_authentication_enabled=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property b2cAuthenticationMethodsPolicy in policies.

        Update the navigation property b2cAuthenticationMethodsPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param is_email_password_authentication_enabled:
        :type is_email_password_authentication_enabled: bool
        :param is_phone_one_time_password_authentication_enabled:
        :type is_phone_one_time_password_authentication_enabled: bool
        :param is_user_name_authentication_enabled:
        :type is_user_name_authentication_enabled: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphB2CAuthenticationMethodsPolicy(id=id, is_email_password_authentication_enabled=is_email_password_authentication_enabled, is_phone_one_time_password_authentication_enabled=is_phone_one_time_password_authentication_enabled, is_user_name_authentication_enabled=is_user_name_authentication_enabled)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_b2_c_authentication_method_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphB2CAuthenticationMethodsPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_b2_c_authentication_method_policy.metadata = {'url': '/policies/b2cAuthenticationMethodsPolicy'}  # type: ignore

    def delete_b2_c_authentication_method_policy(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property b2cAuthenticationMethodsPolicy for policies.

        Delete navigation property b2cAuthenticationMethodsPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_b2_c_authentication_method_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_b2_c_authentication_method_policy.metadata = {'url': '/policies/b2cAuthenticationMethodsPolicy'}  # type: ignore

    def list_claim_mapping_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum213"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum214"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum215"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfClaimsMappingPolicy"]
        """Get claimsMappingPolicies from policies.

        Get claimsMappingPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum213]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum214]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum215]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfClaimsMappingPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfClaimsMappingPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_claim_mapping_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfClaimsMappingPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies'}  # type: ignore

    def create_claim_mapping_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphClaimsMappingPolicy"
        """Create new navigation property to claimsMappingPolicies for policies.

        Create new navigation property to claimsMappingPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphClaimsMappingPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphClaimsMappingPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphClaimsMappingPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_claim_mapping_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphClaimsMappingPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphClaimsMappingPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies'}  # type: ignore

    def get_claim_mapping_policy(
        self,
        claims_mapping_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum216"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum217"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphClaimsMappingPolicy"
        """Get claimsMappingPolicies from policies.

        Get claimsMappingPolicies from policies.

        :param claims_mapping_policy_id: key: id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum216]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum217]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphClaimsMappingPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphClaimsMappingPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphClaimsMappingPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphClaimsMappingPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    def update_claim_mapping_policy(
        self,
        claims_mapping_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property claimsMappingPolicies in policies.

        Update the navigation property claimsMappingPolicies in policies.

        :param claims_mapping_policy_id: key: id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphClaimsMappingPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphClaimsMappingPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    def delete_claim_mapping_policy(
        self,
        claims_mapping_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property claimsMappingPolicies for policies.

        Delete navigation property claimsMappingPolicies for policies.

        :param claims_mapping_policy_id: key: id of claimsMappingPolicy.
        :type claims_mapping_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_claim_mapping_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'claimsMappingPolicy-id': self._serialize.url("claims_mapping_policy_id", claims_mapping_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_claim_mapping_policy.metadata = {'url': '/policies/claimsMappingPolicies/{claimsMappingPolicy-id}'}  # type: ignore

    def list_conditional_access_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum218"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum219"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfConditionalAccessPolicy0"]
        """Get conditionalAccessPolicies from policies.

        Get conditionalAccessPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum218]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum219]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfConditionalAccessPolicy0 or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfConditionalAccessPolicy0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfConditionalAccessPolicy0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_conditional_access_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfConditionalAccessPolicy0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies'}  # type: ignore

    def create_conditional_access_policy(
        self,
        id=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        grant_controls=None,  # type: Optional["models.MicrosoftGraphConditionalAccessGrantControls"]
        modified_date_time=None,  # type: Optional[datetime.datetime]
        state=None,  # type: Optional[Union[str, "models.MicrosoftGraphConditionalAccessPolicyState"]]
        application_enforced_restrictions=None,  # type: Optional["models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl"]
        cloud_app_security=None,  # type: Optional["models.MicrosoftGraphCloudAppSecuritySessionControl"]
        persistent_browser=None,  # type: Optional["models.MicrosoftGraphPersistentBrowserSessionControl"]
        sign_in_frequency=None,  # type: Optional["models.MicrosoftGraphSignInFrequencySessionControl"]
        applications=None,  # type: Optional["models.MicrosoftGraphConditionalAccessApplications"]
        client_applications=None,  # type: Optional["models.MicrosoftGraphConditionalAccessClientApplications"]
        client_app_types=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphConditionalAccessClientApp"]]]
        devices=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDevices"]
        device_states=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDeviceStates"]
        locations=None,  # type: Optional["models.MicrosoftGraphConditionalAccessLocations"]
        platforms=None,  # type: Optional["models.MicrosoftGraphConditionalAccessPlatforms"]
        sign_in_risk_levels=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]]
        user_risk_levels=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]]
        users=None,  # type: Optional["models.MicrosoftGraphConditionalAccessUsers"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphConditionalAccessPolicy"
        """Create new navigation property to conditionalAccessPolicies for policies.

        Create new navigation property to conditionalAccessPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type created_date_time: ~datetime.datetime
        :param description:
        :type description: str
        :param display_name: Specifies a display name for the conditionalAccessPolicy object.
        :type display_name: str
        :param grant_controls: conditionalAccessGrantControls.
        :type grant_controls: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessGrantControls
        :param modified_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type modified_date_time: ~datetime.datetime
        :param state:
        :type state: str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicyState
        :param application_enforced_restrictions: applicationEnforcedRestrictionsSessionControl.
        :type application_enforced_restrictions: ~identity_sign_ins.models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl
        :param cloud_app_security: cloudAppSecuritySessionControl.
        :type cloud_app_security: ~identity_sign_ins.models.MicrosoftGraphCloudAppSecuritySessionControl
        :param persistent_browser: persistentBrowserSessionControl.
        :type persistent_browser: ~identity_sign_ins.models.MicrosoftGraphPersistentBrowserSessionControl
        :param sign_in_frequency: signInFrequencySessionControl.
        :type sign_in_frequency: ~identity_sign_ins.models.MicrosoftGraphSignInFrequencySessionControl
        :param applications: conditionalAccessApplications.
        :type applications: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessApplications
        :param client_applications: conditionalAccessClientApplications.
        :type client_applications: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessClientApplications
        :param client_app_types: Client application types included in the policy. Possible values are:
         all, browser, mobileAppsAndDesktopClients, exchangeActiveSync, easSupported, other.
        :type client_app_types: list[str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessClientApp]
        :param devices: conditionalAccessDevices.
        :type devices: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessDevices
        :param device_states: conditionalAccessDeviceStates.
        :type device_states: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessDeviceStates
        :param locations: conditionalAccessLocations.
        :type locations: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessLocations
        :param platforms: conditionalAccessPlatforms.
        :type platforms: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPlatforms
        :param sign_in_risk_levels: Risk levels included in the policy. Possible values are: low,
         medium, high, none.
        :type sign_in_risk_levels: list[str or ~identity_sign_ins.models.MicrosoftGraphRiskLevel]
        :param user_risk_levels:
        :type user_risk_levels: list[str or ~identity_sign_ins.models.MicrosoftGraphRiskLevel]
        :param users: conditionalAccessUsers.
        :type users: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessUsers
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConditionalAccessPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConditionalAccessPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, grant_controls=grant_controls, modified_date_time=modified_date_time, state=state, application_enforced_restrictions=application_enforced_restrictions, cloud_app_security=cloud_app_security, persistent_browser=persistent_browser, sign_in_frequency=sign_in_frequency, applications=applications, client_applications=client_applications, client_app_types=client_app_types, devices=devices, device_states=device_states, locations=locations, platforms=platforms, sign_in_risk_levels=sign_in_risk_levels, user_risk_levels=user_risk_levels, users=users)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_conditional_access_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConditionalAccessPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConditionalAccessPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies'}  # type: ignore

    def get_conditional_access_policy(
        self,
        conditional_access_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum220"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphConditionalAccessPolicy"
        """Get conditionalAccessPolicies from policies.

        Get conditionalAccessPolicies from policies.

        :param conditional_access_policy_id: key: id of conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum220]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConditionalAccessPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConditionalAccessPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConditionalAccessPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    def update_conditional_access_policy(
        self,
        conditional_access_policy_id,  # type: str
        id=None,  # type: Optional[str]
        created_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        grant_controls=None,  # type: Optional["models.MicrosoftGraphConditionalAccessGrantControls"]
        modified_date_time=None,  # type: Optional[datetime.datetime]
        state=None,  # type: Optional[Union[str, "models.MicrosoftGraphConditionalAccessPolicyState"]]
        application_enforced_restrictions=None,  # type: Optional["models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl"]
        cloud_app_security=None,  # type: Optional["models.MicrosoftGraphCloudAppSecuritySessionControl"]
        persistent_browser=None,  # type: Optional["models.MicrosoftGraphPersistentBrowserSessionControl"]
        sign_in_frequency=None,  # type: Optional["models.MicrosoftGraphSignInFrequencySessionControl"]
        applications=None,  # type: Optional["models.MicrosoftGraphConditionalAccessApplications"]
        client_applications=None,  # type: Optional["models.MicrosoftGraphConditionalAccessClientApplications"]
        client_app_types=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphConditionalAccessClientApp"]]]
        devices=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDevices"]
        device_states=None,  # type: Optional["models.MicrosoftGraphConditionalAccessDeviceStates"]
        locations=None,  # type: Optional["models.MicrosoftGraphConditionalAccessLocations"]
        platforms=None,  # type: Optional["models.MicrosoftGraphConditionalAccessPlatforms"]
        sign_in_risk_levels=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]]
        user_risk_levels=None,  # type: Optional[List[Union[str, "models.MicrosoftGraphRiskLevel"]]]
        users=None,  # type: Optional["models.MicrosoftGraphConditionalAccessUsers"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property conditionalAccessPolicies in policies.

        Update the navigation property conditionalAccessPolicies in policies.

        :param conditional_access_policy_id: key: id of conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type created_date_time: ~datetime.datetime
        :param description:
        :type description: str
        :param display_name: Specifies a display name for the conditionalAccessPolicy object.
        :type display_name: str
        :param grant_controls: conditionalAccessGrantControls.
        :type grant_controls: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessGrantControls
        :param modified_date_time: The Timestamp type represents date and time information using ISO
         8601 format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Readonly.
        :type modified_date_time: ~datetime.datetime
        :param state:
        :type state: str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPolicyState
        :param application_enforced_restrictions: applicationEnforcedRestrictionsSessionControl.
        :type application_enforced_restrictions: ~identity_sign_ins.models.MicrosoftGraphApplicationEnforcedRestrictionsSessionControl
        :param cloud_app_security: cloudAppSecuritySessionControl.
        :type cloud_app_security: ~identity_sign_ins.models.MicrosoftGraphCloudAppSecuritySessionControl
        :param persistent_browser: persistentBrowserSessionControl.
        :type persistent_browser: ~identity_sign_ins.models.MicrosoftGraphPersistentBrowserSessionControl
        :param sign_in_frequency: signInFrequencySessionControl.
        :type sign_in_frequency: ~identity_sign_ins.models.MicrosoftGraphSignInFrequencySessionControl
        :param applications: conditionalAccessApplications.
        :type applications: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessApplications
        :param client_applications: conditionalAccessClientApplications.
        :type client_applications: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessClientApplications
        :param client_app_types: Client application types included in the policy. Possible values are:
         all, browser, mobileAppsAndDesktopClients, exchangeActiveSync, easSupported, other.
        :type client_app_types: list[str or ~identity_sign_ins.models.MicrosoftGraphConditionalAccessClientApp]
        :param devices: conditionalAccessDevices.
        :type devices: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessDevices
        :param device_states: conditionalAccessDeviceStates.
        :type device_states: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessDeviceStates
        :param locations: conditionalAccessLocations.
        :type locations: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessLocations
        :param platforms: conditionalAccessPlatforms.
        :type platforms: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessPlatforms
        :param sign_in_risk_levels: Risk levels included in the policy. Possible values are: low,
         medium, high, none.
        :type sign_in_risk_levels: list[str or ~identity_sign_ins.models.MicrosoftGraphRiskLevel]
        :param user_risk_levels:
        :type user_risk_levels: list[str or ~identity_sign_ins.models.MicrosoftGraphRiskLevel]
        :param users: conditionalAccessUsers.
        :type users: ~identity_sign_ins.models.MicrosoftGraphConditionalAccessUsers
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConditionalAccessPolicy(id=id, created_date_time=created_date_time, description=description, display_name=display_name, grant_controls=grant_controls, modified_date_time=modified_date_time, state=state, application_enforced_restrictions=application_enforced_restrictions, cloud_app_security=cloud_app_security, persistent_browser=persistent_browser, sign_in_frequency=sign_in_frequency, applications=applications, client_applications=client_applications, client_app_types=client_app_types, devices=devices, device_states=device_states, locations=locations, platforms=platforms, sign_in_risk_levels=sign_in_risk_levels, user_risk_levels=user_risk_levels, users=users)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConditionalAccessPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    def delete_conditional_access_policy(
        self,
        conditional_access_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property conditionalAccessPolicies for policies.

        Delete navigation property conditionalAccessPolicies for policies.

        :param conditional_access_policy_id: key: id of conditionalAccessPolicy.
        :type conditional_access_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_conditional_access_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'conditionalAccessPolicy-id': self._serialize.url("conditional_access_policy_id", conditional_access_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_conditional_access_policy.metadata = {'url': '/policies/conditionalAccessPolicies/{conditionalAccessPolicy-id}'}  # type: ignore

    def get_device_registration_policy(
        self,
        select=None,  # type: Optional[List[str]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphDeviceRegistrationPolicy"
        """Get deviceRegistrationPolicy from policies.

        Get deviceRegistrationPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDeviceRegistrationPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphDeviceRegistrationPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDeviceRegistrationPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_device_registration_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDeviceRegistrationPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_device_registration_policy.metadata = {'url': '/policies/deviceRegistrationPolicy'}  # type: ignore

    def update_device_registration_policy(
        self,
        id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property deviceRegistrationPolicy in policies.

        Update the navigation property deviceRegistrationPolicy in policies.

        :param id: Read-only.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphDeviceRegistrationPolicy(id=id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_device_registration_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphDeviceRegistrationPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_device_registration_policy.metadata = {'url': '/policies/deviceRegistrationPolicy'}  # type: ignore

    def delete_device_registration_policy(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property deviceRegistrationPolicy for policies.

        Delete navigation property deviceRegistrationPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_device_registration_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_device_registration_policy.metadata = {'url': '/policies/deviceRegistrationPolicy'}  # type: ignore

    def get_directory_role_access_review_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum221"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphDirectoryRoleAccessReviewPolicy"
        """Get directoryRoleAccessReviewPolicy from policies.

        Get directoryRoleAccessReviewPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum221]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDirectoryRoleAccessReviewPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphDirectoryRoleAccessReviewPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDirectoryRoleAccessReviewPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_directory_role_access_review_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDirectoryRoleAccessReviewPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_directory_role_access_review_policy.metadata = {'url': '/policies/directoryRoleAccessReviewPolicy'}  # type: ignore

    def update_directory_role_access_review_policy(
        self,
        id=None,  # type: Optional[str]
        apply_actions=None,  # type: Optional[List[Dict[str, object]]]
        auto_apply_decisions_enabled=None,  # type: Optional[bool]
        default_decision=None,  # type: Optional[str]
        default_decision_enabled=None,  # type: Optional[bool]
        instance_duration_in_days=None,  # type: Optional[int]
        justification_required_on_approval=None,  # type: Optional[bool]
        mail_notifications_enabled=None,  # type: Optional[bool]
        recommendations_enabled=None,  # type: Optional[bool]
        recurrence=None,  # type: Optional["models.MicrosoftGraphPatternedRecurrence"]
        reminder_notifications_enabled=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property directoryRoleAccessReviewPolicy in policies.

        Update the navigation property directoryRoleAccessReviewPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param apply_actions:
        :type apply_actions: list[dict[str, object]]
        :param auto_apply_decisions_enabled:
        :type auto_apply_decisions_enabled: bool
        :param default_decision:
        :type default_decision: str
        :param default_decision_enabled:
        :type default_decision_enabled: bool
        :param instance_duration_in_days:
        :type instance_duration_in_days: int
        :param justification_required_on_approval:
        :type justification_required_on_approval: bool
        :param mail_notifications_enabled:
        :type mail_notifications_enabled: bool
        :param recommendations_enabled:
        :type recommendations_enabled: bool
        :param recurrence: patternedRecurrence.
        :type recurrence: ~identity_sign_ins.models.MicrosoftGraphPatternedRecurrence
        :param reminder_notifications_enabled:
        :type reminder_notifications_enabled: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphDirectoryRoleAccessReviewPolicy(id=id, apply_actions=apply_actions, auto_apply_decisions_enabled=auto_apply_decisions_enabled, default_decision=default_decision, default_decision_enabled=default_decision_enabled, instance_duration_in_days=instance_duration_in_days, justification_required_on_approval=justification_required_on_approval, mail_notifications_enabled=mail_notifications_enabled, recommendations_enabled=recommendations_enabled, recurrence=recurrence, reminder_notifications_enabled=reminder_notifications_enabled)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_directory_role_access_review_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphDirectoryRoleAccessReviewPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_directory_role_access_review_policy.metadata = {'url': '/policies/directoryRoleAccessReviewPolicy'}  # type: ignore

    def delete_directory_role_access_review_policy(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property directoryRoleAccessReviewPolicy for policies.

        Delete navigation property directoryRoleAccessReviewPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_directory_role_access_review_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_directory_role_access_review_policy.metadata = {'url': '/policies/directoryRoleAccessReviewPolicy'}  # type: ignore

    def list_home_realm_discovery_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum222"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum223"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum224"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfHomeRealmDiscoveryPolicy"]
        """Get homeRealmDiscoveryPolicies from policies.

        Get homeRealmDiscoveryPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum222]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum223]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum224]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfHomeRealmDiscoveryPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfHomeRealmDiscoveryPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_home_realm_discovery_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfHomeRealmDiscoveryPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies'}  # type: ignore

    def create_home_realm_discovery_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphHomeRealmDiscoveryPolicy"
        """Create new navigation property to homeRealmDiscoveryPolicies for policies.

        Create new navigation property to homeRealmDiscoveryPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphHomeRealmDiscoveryPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphHomeRealmDiscoveryPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphHomeRealmDiscoveryPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_home_realm_discovery_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphHomeRealmDiscoveryPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphHomeRealmDiscoveryPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies'}  # type: ignore

    def get_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum225"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum226"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphHomeRealmDiscoveryPolicy"
        """Get homeRealmDiscoveryPolicies from policies.

        Get homeRealmDiscoveryPolicies from policies.

        :param home_realm_discovery_policy_id: key: id of homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum225]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum226]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphHomeRealmDiscoveryPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphHomeRealmDiscoveryPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphHomeRealmDiscoveryPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphHomeRealmDiscoveryPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    def update_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property homeRealmDiscoveryPolicies in policies.

        Update the navigation property homeRealmDiscoveryPolicies in policies.

        :param home_realm_discovery_policy_id: key: id of homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphHomeRealmDiscoveryPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphHomeRealmDiscoveryPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    def delete_home_realm_discovery_policy(
        self,
        home_realm_discovery_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property homeRealmDiscoveryPolicies for policies.

        Delete navigation property homeRealmDiscoveryPolicies for policies.

        :param home_realm_discovery_policy_id: key: id of homeRealmDiscoveryPolicy.
        :type home_realm_discovery_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_home_realm_discovery_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'homeRealmDiscoveryPolicy-id': self._serialize.url("home_realm_discovery_policy_id", home_realm_discovery_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_home_realm_discovery_policy.metadata = {'url': '/policies/homeRealmDiscoveryPolicies/{homeRealmDiscoveryPolicy-id}'}  # type: ignore

    def get_identity_security_default_enforcement_policy(
        self,
        select=None,  # type: Optional[List[Union[str, "models.Enum227"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy"
        """Get identitySecurityDefaultsEnforcementPolicy from policies.

        Get identitySecurityDefaultsEnforcementPolicy from policies.

        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum227]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    def update_identity_security_default_enforcement_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        is_enabled=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property identitySecurityDefaultsEnforcementPolicy in policies.

        Update the navigation property identitySecurityDefaultsEnforcementPolicy in policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param is_enabled: If set to true, Azure Active Directory security defaults is enabled for the
         tenant.
        :type is_enabled: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, is_enabled=is_enabled)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphIdentitySecurityDefaultsEnforcementPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    def delete_identity_security_default_enforcement_policy(
        self,
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property identitySecurityDefaultsEnforcementPolicy for policies.

        Delete navigation property identitySecurityDefaultsEnforcementPolicy for policies.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_identity_security_default_enforcement_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_identity_security_default_enforcement_policy.metadata = {'url': '/policies/identitySecurityDefaultsEnforcementPolicy'}  # type: ignore

    def list_permission_grant_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum228"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum229"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum230"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfPermissionGrantPolicy"]
        """Get permissionGrantPolicies from policies.

        Get permissionGrantPolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum228]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum229]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum230]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPermissionGrantPolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfPermissionGrantPolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPermissionGrantPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_permission_grant_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPermissionGrantPolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies'}  # type: ignore

    def create_permission_grant_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        excludes=None,  # type: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]]
        includes=None,  # type: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPermissionGrantPolicy"
        """Create new navigation property to permissionGrantPolicies for policies.

        Create new navigation property to permissionGrantPolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param excludes:
        :type excludes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :param includes:
        :type includes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPermissionGrantPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphPermissionGrantPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPermissionGrantPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPermissionGrantPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, excludes=excludes, includes=includes)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_permission_grant_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPermissionGrantPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPermissionGrantPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies'}  # type: ignore

    def get_permission_grant_policy(
        self,
        permission_grant_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum231"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum232"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPermissionGrantPolicy"
        """Get permissionGrantPolicies from policies.

        Get permissionGrantPolicies from policies.

        :param permission_grant_policy_id: key: id of permissionGrantPolicy.
        :type permission_grant_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum231]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum232]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPermissionGrantPolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphPermissionGrantPolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPermissionGrantPolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_permission_grant_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'permissionGrantPolicy-id': self._serialize.url("permission_grant_policy_id", permission_grant_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPermissionGrantPolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies/{permissionGrantPolicy-id}'}  # type: ignore

    def update_permission_grant_policy(
        self,
        permission_grant_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        excludes=None,  # type: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]]
        includes=None,  # type: Optional[List["models.MicrosoftGraphPermissionGrantConditionSet"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property permissionGrantPolicies in policies.

        Update the navigation property permissionGrantPolicies in policies.

        :param permission_grant_policy_id: key: id of permissionGrantPolicy.
        :type permission_grant_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param excludes:
        :type excludes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :param includes:
        :type includes: list[~identity_sign_ins.models.MicrosoftGraphPermissionGrantConditionSet]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPermissionGrantPolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, excludes=excludes, includes=includes)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_permission_grant_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'permissionGrantPolicy-id': self._serialize.url("permission_grant_policy_id", permission_grant_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPermissionGrantPolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies/{permissionGrantPolicy-id}'}  # type: ignore

    def delete_permission_grant_policy(
        self,
        permission_grant_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property permissionGrantPolicies for policies.

        Delete navigation property permissionGrantPolicies for policies.

        :param permission_grant_policy_id: key: id of permissionGrantPolicy.
        :type permission_grant_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_permission_grant_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'permissionGrantPolicy-id': self._serialize.url("permission_grant_policy_id", permission_grant_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_permission_grant_policy.metadata = {'url': '/policies/permissionGrantPolicies/{permissionGrantPolicy-id}'}  # type: ignore

    def list_private_link_resource_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum239"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum240"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfPrivateLinkResource"]
        """Get privateLinkResourcePolicies from policies.

        Get privateLinkResourcePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum239]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum240]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPrivateLinkResource or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfPrivateLinkResource]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPrivateLinkResource"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_private_link_resource_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPrivateLinkResource', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_private_link_resource_policy.metadata = {'url': '/policies/privateLinkResourcePolicies'}  # type: ignore

    def create_private_link_resource_policy(
        self,
        id=None,  # type: Optional[str]
        allowed_tenant_ids=None,  # type: Optional[List[str]]
        arm_resource_id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrivateLinkResource"
        """Create new navigation property to privateLinkResourcePolicies for policies.

        Create new navigation property to privateLinkResourcePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param allowed_tenant_ids:
        :type allowed_tenant_ids: list[str]
        :param arm_resource_id:
        :type arm_resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrivateLinkResource, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphPrivateLinkResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrivateLinkResource"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrivateLinkResource(id=id, allowed_tenant_ids=allowed_tenant_ids, arm_resource_id=arm_resource_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_private_link_resource_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrivateLinkResource')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrivateLinkResource', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_private_link_resource_policy.metadata = {'url': '/policies/privateLinkResourcePolicies'}  # type: ignore

    def get_private_link_resource_policy(
        self,
        private_link_resource_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum241"]]]
        expand=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphPrivateLinkResource"
        """Get privateLinkResourcePolicies from policies.

        Get privateLinkResourcePolicies from policies.

        :param private_link_resource_id: key: id of privateLinkResource.
        :type private_link_resource_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum241]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPrivateLinkResource, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphPrivateLinkResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPrivateLinkResource"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_private_link_resource_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'privateLinkResource-id': self._serialize.url("private_link_resource_id", private_link_resource_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPrivateLinkResource', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_private_link_resource_policy.metadata = {'url': '/policies/privateLinkResourcePolicies/{privateLinkResource-id}'}  # type: ignore

    def update_private_link_resource_policy(
        self,
        private_link_resource_id,  # type: str
        id=None,  # type: Optional[str]
        allowed_tenant_ids=None,  # type: Optional[List[str]]
        arm_resource_id=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property privateLinkResourcePolicies in policies.

        Update the navigation property privateLinkResourcePolicies in policies.

        :param private_link_resource_id: key: id of privateLinkResource.
        :type private_link_resource_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_tenant_ids:
        :type allowed_tenant_ids: list[str]
        :param arm_resource_id:
        :type arm_resource_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPrivateLinkResource(id=id, allowed_tenant_ids=allowed_tenant_ids, arm_resource_id=arm_resource_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_private_link_resource_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'privateLinkResource-id': self._serialize.url("private_link_resource_id", private_link_resource_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPrivateLinkResource')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_private_link_resource_policy.metadata = {'url': '/policies/privateLinkResourcePolicies/{privateLinkResource-id}'}  # type: ignore

    def delete_private_link_resource_policy(
        self,
        private_link_resource_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property privateLinkResourcePolicies for policies.

        Delete navigation property privateLinkResourcePolicies for policies.

        :param private_link_resource_id: key: id of privateLinkResource.
        :type private_link_resource_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_private_link_resource_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'privateLinkResource-id': self._serialize.url("private_link_resource_id", private_link_resource_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_private_link_resource_policy.metadata = {'url': '/policies/privateLinkResourcePolicies/{privateLinkResource-id}'}  # type: ignore

    def list_token_issuance_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum242"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum243"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum244"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfTokenIssuancePolicy"]
        """Get tokenIssuancePolicies from policies.

        Get tokenIssuancePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum242]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum243]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum244]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenIssuancePolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfTokenIssuancePolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_issuance_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenIssuancePolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies'}  # type: ignore

    def create_token_issuance_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTokenIssuancePolicy"
        """Create new navigation property to tokenIssuancePolicies for policies.

        Create new navigation property to tokenIssuancePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenIssuancePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenIssuancePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenIssuancePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_token_issuance_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenIssuancePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenIssuancePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies'}  # type: ignore

    def get_token_issuance_policy(
        self,
        token_issuance_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum245"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum246"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTokenIssuancePolicy"
        """Get tokenIssuancePolicies from policies.

        Get tokenIssuancePolicies from policies.

        :param token_issuance_policy_id: key: id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum245]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum246]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenIssuancePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenIssuancePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenIssuancePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenIssuancePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    def update_token_issuance_policy(
        self,
        token_issuance_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property tokenIssuancePolicies in policies.

        Update the navigation property tokenIssuancePolicies in policies.

        :param token_issuance_policy_id: key: id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenIssuancePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenIssuancePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    def delete_token_issuance_policy(
        self,
        token_issuance_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property tokenIssuancePolicies for policies.

        Delete navigation property tokenIssuancePolicies for policies.

        :param token_issuance_policy_id: key: id of tokenIssuancePolicy.
        :type token_issuance_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_token_issuance_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenIssuancePolicy-id': self._serialize.url("token_issuance_policy_id", token_issuance_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_token_issuance_policy.metadata = {'url': '/policies/tokenIssuancePolicies/{tokenIssuancePolicy-id}'}  # type: ignore

    def list_token_lifetime_policy(
        self,
        orderby=None,  # type: Optional[List[Union[str, "models.Enum247"]]]
        select=None,  # type: Optional[List[Union[str, "models.Enum248"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum249"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["models.CollectionOfTokenLifetimePolicy"]
        """Get tokenLifetimePolicies from policies.

        Get tokenLifetimePolicies from policies.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~identity_sign_ins.models.Enum247]
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum248]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum249]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTokenLifetimePolicy or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~identity_sign_ins.models.CollectionOfTokenLifetimePolicy]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_token_lifetime_policy.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTokenLifetimePolicy', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies'}  # type: ignore

    def create_token_lifetime_policy(
        self,
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTokenLifetimePolicy"
        """Create new navigation property to tokenLifetimePolicies for policies.

        Create new navigation property to tokenLifetimePolicies for policies.

        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenLifetimePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenLifetimePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenLifetimePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_token_lifetime_policy.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenLifetimePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenLifetimePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies'}  # type: ignore

    def get_token_lifetime_policy(
        self,
        token_lifetime_policy_id,  # type: str
        select=None,  # type: Optional[List[Union[str, "models.Enum250"]]]
        expand=None,  # type: Optional[List[Union[str, "models.Enum251"]]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.MicrosoftGraphTokenLifetimePolicy"
        """Get tokenLifetimePolicies from policies.

        Get tokenLifetimePolicies from policies.

        :param token_lifetime_policy_id: key: id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~identity_sign_ins.models.Enum250]
        :param expand: Expand related entities.
        :type expand: list[str or ~identity_sign_ins.models.Enum251]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTokenLifetimePolicy, or the result of cls(response)
        :rtype: ~identity_sign_ins.models.MicrosoftGraphTokenLifetimePolicy
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTokenLifetimePolicy"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTokenLifetimePolicy', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore

    def update_token_lifetime_policy(
        self,
        token_lifetime_policy_id,  # type: str
        id=None,  # type: Optional[str]
        deleted_date_time=None,  # type: Optional[datetime.datetime]
        description=None,  # type: Optional[str]
        display_name=None,  # type: Optional[str]
        definition=None,  # type: Optional[List[str]]
        is_organization_default=None,  # type: Optional[bool]
        applies_to=None,  # type: Optional[List["models.MicrosoftGraphDirectoryObject"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Update the navigation property tokenLifetimePolicies in policies.

        Update the navigation property tokenLifetimePolicies in policies.

        :param token_lifetime_policy_id: key: id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param id: Read-only.
        :type id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param description: Description for this policy.
        :type description: str
        :param display_name: Display name for this policy.
        :type display_name: str
        :param definition: A string collection containing a JSON string that defines the rules and
         settings for a policy. The syntax for the definition differs for each derived policy type.
         Required.
        :type definition: list[str]
        :param is_organization_default: If set to true, activates this policy. There can be many
         policies for the same policy type, but only one can be activated as the organization default.
         Optional, default value is false.
        :type is_organization_default: bool
        :param applies_to:
        :type applies_to: list[~identity_sign_ins.models.MicrosoftGraphDirectoryObject]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTokenLifetimePolicy(id=id, deleted_date_time=deleted_date_time, description=description, display_name=display_name, definition=definition, is_organization_default=is_organization_default, applies_to=applies_to)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTokenLifetimePolicy')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore

    def delete_token_lifetime_policy(
        self,
        token_lifetime_policy_id,  # type: str
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete navigation property tokenLifetimePolicies for policies.

        Delete navigation property tokenLifetimePolicies for policies.

        :param token_lifetime_policy_id: key: id of tokenLifetimePolicy.
        :type token_lifetime_policy_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_token_lifetime_policy.metadata['url']  # type: ignore
        path_format_arguments = {
            'tokenLifetimePolicy-id': self._serialize.url("token_lifetime_policy_id", token_lifetime_policy_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_token_lifetime_policy.metadata = {'url': '/policies/tokenLifetimePolicies/{tokenLifetimePolicy-id}'}  # type: ignore
