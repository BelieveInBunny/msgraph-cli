# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddCreatedBy(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.created_by = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'ip-address':
                d['ip_address'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter created_by. All possible keys are: '
                               'ip-address, user-principal-name, display-name, id'.format(k))
        return d


class AddReviewedEntity(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.reviewed_entity = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter reviewed_entity. All possible keys are: '
                               'display-name, id'.format(k))
        return d


class AddAccessreviewsAccessreviewReviewers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAccessreviewsAccessreviewReviewers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter reviewers. All possible keys are: '
                               'display-name, user-principal-name, id'.format(k))
        return d


class AddAutoReviewSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.auto_review_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'not-reviewed-result':
                d['not_reviewed_result'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter auto_review_settings. All possible keys '
                               'are: not-reviewed-result'.format(k))
        return d


class AddRecurrenceSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.recurrence_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'duration-in-days':
                d['duration_in_days'] = v[0]
            elif kl == 'recurrence-count':
                d['recurrence_count'] = v[0]
            elif kl == 'recurrence-end-type':
                d['recurrence_end_type'] = v[0]
            elif kl == 'recurrence-type':
                d['recurrence_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter recurrence_settings. All possible keys '
                               'are: duration-in-days, recurrence-count, recurrence-end-type, recurrence-type'.format(k))
        return d


class AddTermsExpiration(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.terms_expiration = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'frequency':
                d['frequency'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter terms_expiration. All possible keys are: '
                               'frequency, start-date-time'.format(k))
        return d


class AddAcceptances(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAcceptances, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'agreement-file-id':
                d['agreement_file_id'] = v[0]
            elif kl == 'agreement-id':
                d['agreement_id'] = v[0]
            elif kl == 'device-display-name':
                d['device_display_name'] = v[0]
            elif kl == 'device-id':
                d['device_id'] = v[0]
            elif kl == 'device-os-type':
                d['device_os_type'] = v[0]
            elif kl == 'device-os-version':
                d['device_os_version'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'recorded-date-time':
                d['recorded_date_time'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'user-display-name':
                d['user_display_name'] = v[0]
            elif kl == 'user-email':
                d['user_email'] = v[0]
            elif kl == 'user-id':
                d['user_id'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter acceptances. All possible keys are: '
                               'agreement-file-id, agreement-id, device-display-name, device-id, device-os-type, '
                               'device-os-version, expiration-date-time, recorded-date-time, state, user-display-name, '
                               'user-email, user-id, user-principal-name, id'.format(k))
        return d


class AddFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddFiles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'is-default':
                d['is_default'] = v[0]
            elif kl == 'language':
                d['language'] = v[0]
            elif kl == 'data':
                d['data'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter files. All possible keys are: file-name, '
                               'is-default, language, data, id'.format(k))
        return d


class AddLocalizations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddLocalizations, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'is-default':
                d['is_default'] = v[0]
            elif kl == 'language':
                d['language'] = v[0]
            elif kl == 'data':
                d['data'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter localizations. All possible keys are: '
                               'file-name, is-default, language, data, id'.format(k))
        return d


class AddIdentitygovernanceSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'days-until-external-user-deleted-after-blocked':
                d['days_until_external_user_deleted_after_blocked'] = v[0]
            elif kl == 'external-user-lifecycle-action':
                d['external_user_lifecycle_action'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter settings. All possible keys are: '
                               'days-until-external-user-deleted-after-blocked, external-user-lifecycle-action, id'.
                               format(k))
        return d


class AddIdentitySources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIdentitySources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            v = properties[k]
            d[k] = v
        return d


class AddExternalSponsors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExternalSponsors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter external_sponsors. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddInternalSponsors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddInternalSponsors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter internal_sponsors. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddExpiration(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.expiration = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'duration':
                d['duration'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter expiration. All possible keys are: '
                               'duration, end-date-time, type'.format(k))
        return d


class AddAllowedRequestors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAllowedRequestors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'is-backup':
                d['is_backup'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter allowed_requestors. All possible keys '
                               'are: is-backup'.format(k))
        return d


class AddIdentitygovernanceEntitlementmanagementReviewers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIdentitygovernanceEntitlementmanagementReviewers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'is-backup':
                d['is_backup'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter reviewers. All possible keys are: '
                               'is-backup'.format(k))
        return d


class AddSubject(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.subject = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'email':
                d['email'] = v[0]
            elif kl == 'principal-name':
                d['principal_name'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter subject. All possible keys are: '
                               'display-name, email, principal-name, type, id'.format(k))
        return d


class AddSchedule(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.schedule = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'duration':
                d['duration'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter schedule. All possible keys are: '
                               'duration, end-date-time, start-date-time, type'.format(k))
        return d


class AddStatusDetails(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddStatusDetails, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'key':
                d['key'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter status_details. All possible keys are: '
                               'key, value'.format(k))
        return d


class AddAdminEligibleSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAdminEligibleSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'rule-identifier':
                d['rule_identifier'] = v[0]
            elif kl == 'setting':
                d['setting'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter admin_eligible_settings. All possible '
                               'keys are: rule-identifier, setting'.format(k))
        return d


class AddAdminMemberSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAdminMemberSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'rule-identifier':
                d['rule_identifier'] = v[0]
            elif kl == 'setting':
                d['setting'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter admin_member_settings. All possible keys '
                               'are: rule-identifier, setting'.format(k))
        return d


class AddUserEligibleSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserEligibleSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'rule-identifier':
                d['rule_identifier'] = v[0]
            elif kl == 'setting':
                d['setting'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user_eligible_settings. All possible keys '
                               'are: rule-identifier, setting'.format(k))
        return d


class AddUserMemberSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserMemberSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'rule-identifier':
                d['rule_identifier'] = v[0]
            elif kl == 'setting':
                d['setting'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user_member_settings. All possible keys '
                               'are: rule-identifier, setting'.format(k))
        return d


class AddPrivilegedapprovalSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'approval-on-elevation':
                d['approval_on_elevation'] = v[0]
            elif kl == 'approver-ids':
                d['approver_ids'] = v
            elif kl == 'elevation-duration':
                d['elevation_duration'] = v[0]
            elif kl == 'is-mfa-on-elevation-configurable':
                d['is_mfa_on_elevation_configurable'] = v[0]
            elif kl == 'last-global-admin':
                d['last_global_admin'] = v[0]
            elif kl == 'max-elavation-duration':
                d['max_elavation_duration'] = v[0]
            elif kl == 'mfa-on-elevation':
                d['mfa_on_elevation'] = v[0]
            elif kl == 'min-elevation-duration':
                d['min_elevation_duration'] = v[0]
            elif kl == 'notification-to-user-on-elevation':
                d['notification_to_user_on_elevation'] = v[0]
            elif kl == 'ticketing-info-on-elevation':
                d['ticketing_info_on_elevation'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter settings. All possible keys are: '
                               'approval-on-elevation, approver-ids, elevation-duration, '
                               'is-mfa-on-elevation-configurable, last-global-admin, max-elavation-duration, '
                               'mfa-on-elevation, min-elevation-duration, notification-to-user-on-elevation, '
                               'ticketing-info-on-elevation, id'.format(k))
        return d


class AddSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'elevated-count':
                d['elevated_count'] = v[0]
            elif kl == 'managed-count':
                d['managed_count'] = v[0]
            elif kl == 'mfa-enabled':
                d['mfa_enabled'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'users-count':
                d['users_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter summary. All possible keys are: '
                               'elevated-count, managed-count, mfa-enabled, status, users-count, id'.format(k))
        return d


class AddResource(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.resource = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter resource. All possible keys are: type, '
                               'display-name, id'.format(k))
        return d
