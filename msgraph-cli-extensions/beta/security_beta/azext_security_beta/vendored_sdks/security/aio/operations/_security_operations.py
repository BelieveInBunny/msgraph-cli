# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class SecurityOperations:
    """SecurityOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~security.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_alert(
        self,
        orderby: Optional[List[Union[str, "models.Get5ItemsItem"]]] = None,
        select: Optional[List[Union[str, "models.Get6ItemsItem"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfAlert"]:
        """Get alerts from Security.

        Get alerts from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfAlert or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfAlert]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfAlert"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_alert.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfAlert', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_alert.metadata = {'url': '/Security/alerts'}  # type: ignore

    async def create_alert(
        self,
        id: Optional[str] = None,
        activity_group_name: Optional[str] = None,
        assigned_to: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        category: Optional[str] = None,
        closed_date_time: Optional[datetime.datetime] = None,
        cloud_app_states: Optional[List["models.MicrosoftGraphCloudAppSecurityState"]] = None,
        comments: Optional[List[str]] = None,
        confidence: Optional[int] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        detection_ids: Optional[List[str]] = None,
        event_date_time: Optional[datetime.datetime] = None,
        feedback: Optional[Union[str, "models.MicrosoftGraphAlertFeedback"]] = None,
        file_states: Optional[List["models.MicrosoftGraphFileSecurityState"]] = None,
        history_states: Optional[List["models.MicrosoftGraphAlertHistoryState"]] = None,
        host_states: Optional[List["models.MicrosoftGraphHostSecurityState"]] = None,
        incident_ids: Optional[List[str]] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        malware_states: Optional[List["models.MicrosoftGraphMalwareState"]] = None,
        network_connections: Optional[List["models.MicrosoftGraphNetworkConnection"]] = None,
        processes: Optional[List["models.MicrosoftGraphProcess"]] = None,
        recommended_actions: Optional[List[str]] = None,
        registry_key_states: Optional[List["models.MicrosoftGraphRegistryKeyState"]] = None,
        security_resources: Optional[List["models.MicrosoftGraphSecurityResource"]] = None,
        severity: Optional[Union[str, "models.MicrosoftGraphAlertSeverity"]] = None,
        source_materials: Optional[List[str]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphAlertStatus"]] = None,
        tags: Optional[List[str]] = None,
        title: Optional[str] = None,
        triggers: Optional[List["models.MicrosoftGraphAlertTrigger"]] = None,
        user_states: Optional[List["models.MicrosoftGraphUserSecurityState"]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        vulnerability_states: Optional[List["models.MicrosoftGraphVulnerabilityState"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAlert":
        """Create new navigation property to alerts for Security.

        Create new navigation property to alerts for Security.

        :param id: Read-only.
        :type id: str
        :param activity_group_name: Name or alias of the activity group (attacker) this alert is
         attributed to.
        :type activity_group_name: str
        :param assigned_to: Name of the analyst the alert is assigned to for triage, investigation, or
         remediation (supports update).
        :type assigned_to: str
        :param azure_subscription_id: Azure subscription ID, present if this alert is related to an
         Azure resource.
        :type azure_subscription_id: str
        :param azure_tenant_id: Azure Active Directory tenant ID. Required.
        :type azure_tenant_id: str
        :param category: Category of the alert (for example, credentialTheft, ransomware, etc.).
        :type category: str
        :param closed_date_time: Time at which the alert was closed. The Timestamp type represents date
         and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC
         on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z' (supports update).
        :type closed_date_time: ~datetime.datetime
        :param cloud_app_states: Security-related stateful information generated by the provider about
         the cloud application/s related to this alert.
        :type cloud_app_states: list[~security.models.MicrosoftGraphCloudAppSecurityState]
        :param comments: Customer-provided comments on alert (for customer alert management) (supports
         update).
        :type comments: list[str]
        :param confidence: Confidence of the detection logic (percentage between 1-100).
        :type confidence: int
        :param created_date_time: Time at which the alert was created by the alert provider. The
         Timestamp type represents date and time information using ISO 8601 format and is always in UTC
         time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
         Required.
        :type created_date_time: ~datetime.datetime
        :param description: Alert description.
        :type description: str
        :param detection_ids: Set of alerts related to this alert entity (each alert is pushed to the
         SIEM as a separate record).
        :type detection_ids: list[str]
        :param event_date_time: Time at which the event(s) that served as the trigger(s) to generate
         the alert occurred. The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Required.
        :type event_date_time: ~datetime.datetime
        :param feedback:
        :type feedback: str or ~security.models.MicrosoftGraphAlertFeedback
        :param file_states: Security-related stateful information generated by the provider about the
         file(s) related to this alert.
        :type file_states: list[~security.models.MicrosoftGraphFileSecurityState]
        :param history_states:
        :type history_states: list[~security.models.MicrosoftGraphAlertHistoryState]
        :param host_states: Security-related stateful information generated by the provider about the
         host(s) related to this alert.
        :type host_states: list[~security.models.MicrosoftGraphHostSecurityState]
        :param incident_ids: IDs of incidents related to current alert.
        :type incident_ids: list[str]
        :param last_modified_date_time: Time at which the alert entity was last modified. The Timestamp
         type represents date and time information using ISO 8601 format and is always in UTC time. For
         example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param malware_states: Threat Intelligence pertaining to malware related to this alert.
        :type malware_states: list[~security.models.MicrosoftGraphMalwareState]
        :param network_connections: Security-related stateful information generated by the provider
         about the network connection(s) related to this alert.
        :type network_connections: list[~security.models.MicrosoftGraphNetworkConnection]
        :param processes: Security-related stateful information generated by the provider about the
         process or processes related to this alert.
        :type processes: list[~security.models.MicrosoftGraphProcess]
        :param recommended_actions: Vendor/provider recommended action(s) to take as a result of the
         alert (for example, isolate machine, enforce2FA, reimage host).
        :type recommended_actions: list[str]
        :param registry_key_states: Security-related stateful information generated by the provider
         about the registry keys related to this alert.
        :type registry_key_states: list[~security.models.MicrosoftGraphRegistryKeyState]
        :param security_resources: Resources related to current alert. For example, for some alerts
         this can have the Azure Resource value.
        :type security_resources: list[~security.models.MicrosoftGraphSecurityResource]
        :param severity:
        :type severity: str or ~security.models.MicrosoftGraphAlertSeverity
        :param source_materials: Hyperlinks (URIs) to the source material related to the alert, for
         example, provider's user interface for alerts or log search, etc.
        :type source_materials: list[str]
        :param status:
        :type status: str or ~security.models.MicrosoftGraphAlertStatus
        :param tags: User-definable labels that can be applied to an alert and can serve as filter
         conditions (for example 'HVA', 'SAW', etc.) (supports update).
        :type tags: list[str]
        :param title: Alert title. Required.
        :type title: str
        :param triggers: Security-related information about the specific properties that triggered the
         alert (properties appearing in the alert). Alerts might contain information about multiple
         users, hosts, files, ip addresses. This field indicates which properties triggered the alert
         generation.
        :type triggers: list[~security.models.MicrosoftGraphAlertTrigger]
        :param user_states: Security-related stateful information generated by the provider about the
         user accounts related to this alert.
        :type user_states: list[~security.models.MicrosoftGraphUserSecurityState]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :param vulnerability_states: Threat intelligence pertaining to one or more vulnerabilities
         related to this alert.
        :type vulnerability_states: list[~security.models.MicrosoftGraphVulnerabilityState]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAlert, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphAlert
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAlert"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAlert(id=id, activity_group_name=activity_group_name, assigned_to=assigned_to, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, category=category, closed_date_time=closed_date_time, cloud_app_states=cloud_app_states, comments=comments, confidence=confidence, created_date_time=created_date_time, description=description, detection_ids=detection_ids, event_date_time=event_date_time, feedback=feedback, file_states=file_states, history_states=history_states, host_states=host_states, incident_ids=incident_ids, last_modified_date_time=last_modified_date_time, malware_states=malware_states, network_connections=network_connections, processes=processes, recommended_actions=recommended_actions, registry_key_states=registry_key_states, security_resources=security_resources, severity=severity, source_materials=source_materials, status=status, tags=tags, title=title, triggers=triggers, user_states=user_states, vendor_information=vendor_information, vulnerability_states=vulnerability_states)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_alert.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAlert')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAlert', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_alert.metadata = {'url': '/Security/alerts'}  # type: ignore

    async def get_alert(
        self,
        alert_id: str,
        select: Optional[List[Union[str, "models.Enum25"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphAlert":
        """Get alerts from Security.

        Get alerts from Security.

        :param alert_id: key: id of alert.
        :type alert_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphAlert, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphAlert
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphAlert"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_alert.metadata['url']  # type: ignore
        path_format_arguments = {
            'alert-id': self._serialize.url("alert_id", alert_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphAlert', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_alert.metadata = {'url': '/Security/alerts/{alert-id}'}  # type: ignore

    async def update_alert(
        self,
        alert_id: str,
        id: Optional[str] = None,
        activity_group_name: Optional[str] = None,
        assigned_to: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        category: Optional[str] = None,
        closed_date_time: Optional[datetime.datetime] = None,
        cloud_app_states: Optional[List["models.MicrosoftGraphCloudAppSecurityState"]] = None,
        comments: Optional[List[str]] = None,
        confidence: Optional[int] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        detection_ids: Optional[List[str]] = None,
        event_date_time: Optional[datetime.datetime] = None,
        feedback: Optional[Union[str, "models.MicrosoftGraphAlertFeedback"]] = None,
        file_states: Optional[List["models.MicrosoftGraphFileSecurityState"]] = None,
        history_states: Optional[List["models.MicrosoftGraphAlertHistoryState"]] = None,
        host_states: Optional[List["models.MicrosoftGraphHostSecurityState"]] = None,
        incident_ids: Optional[List[str]] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        malware_states: Optional[List["models.MicrosoftGraphMalwareState"]] = None,
        network_connections: Optional[List["models.MicrosoftGraphNetworkConnection"]] = None,
        processes: Optional[List["models.MicrosoftGraphProcess"]] = None,
        recommended_actions: Optional[List[str]] = None,
        registry_key_states: Optional[List["models.MicrosoftGraphRegistryKeyState"]] = None,
        security_resources: Optional[List["models.MicrosoftGraphSecurityResource"]] = None,
        severity: Optional[Union[str, "models.MicrosoftGraphAlertSeverity"]] = None,
        source_materials: Optional[List[str]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphAlertStatus"]] = None,
        tags: Optional[List[str]] = None,
        title: Optional[str] = None,
        triggers: Optional[List["models.MicrosoftGraphAlertTrigger"]] = None,
        user_states: Optional[List["models.MicrosoftGraphUserSecurityState"]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        vulnerability_states: Optional[List["models.MicrosoftGraphVulnerabilityState"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property alerts in Security.

        Update the navigation property alerts in Security.

        :param alert_id: key: id of alert.
        :type alert_id: str
        :param id: Read-only.
        :type id: str
        :param activity_group_name: Name or alias of the activity group (attacker) this alert is
         attributed to.
        :type activity_group_name: str
        :param assigned_to: Name of the analyst the alert is assigned to for triage, investigation, or
         remediation (supports update).
        :type assigned_to: str
        :param azure_subscription_id: Azure subscription ID, present if this alert is related to an
         Azure resource.
        :type azure_subscription_id: str
        :param azure_tenant_id: Azure Active Directory tenant ID. Required.
        :type azure_tenant_id: str
        :param category: Category of the alert (for example, credentialTheft, ransomware, etc.).
        :type category: str
        :param closed_date_time: Time at which the alert was closed. The Timestamp type represents date
         and time information using ISO 8601 format and is always in UTC time. For example, midnight UTC
         on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z' (supports update).
        :type closed_date_time: ~datetime.datetime
        :param cloud_app_states: Security-related stateful information generated by the provider about
         the cloud application/s related to this alert.
        :type cloud_app_states: list[~security.models.MicrosoftGraphCloudAppSecurityState]
        :param comments: Customer-provided comments on alert (for customer alert management) (supports
         update).
        :type comments: list[str]
        :param confidence: Confidence of the detection logic (percentage between 1-100).
        :type confidence: int
        :param created_date_time: Time at which the alert was created by the alert provider. The
         Timestamp type represents date and time information using ISO 8601 format and is always in UTC
         time. For example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
         Required.
        :type created_date_time: ~datetime.datetime
        :param description: Alert description.
        :type description: str
        :param detection_ids: Set of alerts related to this alert entity (each alert is pushed to the
         SIEM as a separate record).
        :type detection_ids: list[str]
        :param event_date_time: Time at which the event(s) that served as the trigger(s) to generate
         the alert occurred. The Timestamp type represents date and time information using ISO 8601
         format and is always in UTC time. For example, midnight UTC on Jan 1, 2014 would look like
         this: '2014-01-01T00:00:00Z'. Required.
        :type event_date_time: ~datetime.datetime
        :param feedback:
        :type feedback: str or ~security.models.MicrosoftGraphAlertFeedback
        :param file_states: Security-related stateful information generated by the provider about the
         file(s) related to this alert.
        :type file_states: list[~security.models.MicrosoftGraphFileSecurityState]
        :param history_states:
        :type history_states: list[~security.models.MicrosoftGraphAlertHistoryState]
        :param host_states: Security-related stateful information generated by the provider about the
         host(s) related to this alert.
        :type host_states: list[~security.models.MicrosoftGraphHostSecurityState]
        :param incident_ids: IDs of incidents related to current alert.
        :type incident_ids: list[str]
        :param last_modified_date_time: Time at which the alert entity was last modified. The Timestamp
         type represents date and time information using ISO 8601 format and is always in UTC time. For
         example, midnight UTC on Jan 1, 2014 would look like this: '2014-01-01T00:00:00Z'.
        :type last_modified_date_time: ~datetime.datetime
        :param malware_states: Threat Intelligence pertaining to malware related to this alert.
        :type malware_states: list[~security.models.MicrosoftGraphMalwareState]
        :param network_connections: Security-related stateful information generated by the provider
         about the network connection(s) related to this alert.
        :type network_connections: list[~security.models.MicrosoftGraphNetworkConnection]
        :param processes: Security-related stateful information generated by the provider about the
         process or processes related to this alert.
        :type processes: list[~security.models.MicrosoftGraphProcess]
        :param recommended_actions: Vendor/provider recommended action(s) to take as a result of the
         alert (for example, isolate machine, enforce2FA, reimage host).
        :type recommended_actions: list[str]
        :param registry_key_states: Security-related stateful information generated by the provider
         about the registry keys related to this alert.
        :type registry_key_states: list[~security.models.MicrosoftGraphRegistryKeyState]
        :param security_resources: Resources related to current alert. For example, for some alerts
         this can have the Azure Resource value.
        :type security_resources: list[~security.models.MicrosoftGraphSecurityResource]
        :param severity:
        :type severity: str or ~security.models.MicrosoftGraphAlertSeverity
        :param source_materials: Hyperlinks (URIs) to the source material related to the alert, for
         example, provider's user interface for alerts or log search, etc.
        :type source_materials: list[str]
        :param status:
        :type status: str or ~security.models.MicrosoftGraphAlertStatus
        :param tags: User-definable labels that can be applied to an alert and can serve as filter
         conditions (for example 'HVA', 'SAW', etc.) (supports update).
        :type tags: list[str]
        :param title: Alert title. Required.
        :type title: str
        :param triggers: Security-related information about the specific properties that triggered the
         alert (properties appearing in the alert). Alerts might contain information about multiple
         users, hosts, files, ip addresses. This field indicates which properties triggered the alert
         generation.
        :type triggers: list[~security.models.MicrosoftGraphAlertTrigger]
        :param user_states: Security-related stateful information generated by the provider about the
         user accounts related to this alert.
        :type user_states: list[~security.models.MicrosoftGraphUserSecurityState]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :param vulnerability_states: Threat intelligence pertaining to one or more vulnerabilities
         related to this alert.
        :type vulnerability_states: list[~security.models.MicrosoftGraphVulnerabilityState]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphAlert(id=id, activity_group_name=activity_group_name, assigned_to=assigned_to, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, category=category, closed_date_time=closed_date_time, cloud_app_states=cloud_app_states, comments=comments, confidence=confidence, created_date_time=created_date_time, description=description, detection_ids=detection_ids, event_date_time=event_date_time, feedback=feedback, file_states=file_states, history_states=history_states, host_states=host_states, incident_ids=incident_ids, last_modified_date_time=last_modified_date_time, malware_states=malware_states, network_connections=network_connections, processes=processes, recommended_actions=recommended_actions, registry_key_states=registry_key_states, security_resources=security_resources, severity=severity, source_materials=source_materials, status=status, tags=tags, title=title, triggers=triggers, user_states=user_states, vendor_information=vendor_information, vulnerability_states=vulnerability_states)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_alert.metadata['url']  # type: ignore
        path_format_arguments = {
            'alert-id': self._serialize.url("alert_id", alert_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphAlert')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_alert.metadata = {'url': '/Security/alerts/{alert-id}'}  # type: ignore

    async def delete_alert(
        self,
        alert_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property alerts for Security.

        Delete navigation property alerts for Security.

        :param alert_id: key: id of alert.
        :type alert_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_alert.metadata['url']  # type: ignore
        path_format_arguments = {
            'alert-id': self._serialize.url("alert_id", alert_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_alert.metadata = {'url': '/Security/alerts/{alert-id}'}  # type: ignore

    def list_cloud_app_security_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum26"]]] = None,
        select: Optional[List[Union[str, "models.Enum27"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfCloudAppSecurityProfile"]:
        """Get cloudAppSecurityProfiles from Security.

        Get cloudAppSecurityProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum26]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum27]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfCloudAppSecurityProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfCloudAppSecurityProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfCloudAppSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_cloud_app_security_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfCloudAppSecurityProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_cloud_app_security_profile.metadata = {'url': '/Security/cloudAppSecurityProfiles'}  # type: ignore

    async def create_cloud_app_security_profile(
        self,
        id: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        deployment_package_url: Optional[str] = None,
        destination_service_name: Optional[str] = None,
        is_signed: Optional[bool] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        manifest: Optional[str] = None,
        name: Optional[str] = None,
        permissions_required: Optional[Union[str, "models.MicrosoftGraphApplicationPermissionsRequired"]] = None,
        platform: Optional[str] = None,
        policy_name: Optional[str] = None,
        publisher: Optional[str] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        type: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCloudAppSecurityProfile":
        """Create new navigation property to cloudAppSecurityProfiles for Security.

        Create new navigation property to cloudAppSecurityProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param deployment_package_url:
        :type deployment_package_url: str
        :param destination_service_name:
        :type destination_service_name: str
        :param is_signed:
        :type is_signed: bool
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param manifest:
        :type manifest: str
        :param name:
        :type name: str
        :param permissions_required:
        :type permissions_required: str or ~security.models.MicrosoftGraphApplicationPermissionsRequired
        :param platform:
        :type platform: str
        :param policy_name:
        :type policy_name: str
        :param publisher:
        :type publisher: str
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param type:
        :type type: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCloudAppSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphCloudAppSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCloudAppSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCloudAppSecurityProfile(id=id, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, created_date_time=created_date_time, deployment_package_url=deployment_package_url, destination_service_name=destination_service_name, is_signed=is_signed, last_modified_date_time=last_modified_date_time, manifest=manifest, name=name, permissions_required=permissions_required, platform=platform, policy_name=policy_name, publisher=publisher, risk_score=risk_score, tags=tags, type=type, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_cloud_app_security_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCloudAppSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCloudAppSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_cloud_app_security_profile.metadata = {'url': '/Security/cloudAppSecurityProfiles'}  # type: ignore

    async def get_cloud_app_security_profile(
        self,
        cloud_app_security_profile_id: str,
        select: Optional[List[Union[str, "models.Enum28"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphCloudAppSecurityProfile":
        """Get cloudAppSecurityProfiles from Security.

        Get cloudAppSecurityProfiles from Security.

        :param cloud_app_security_profile_id: key: id of cloudAppSecurityProfile.
        :type cloud_app_security_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum28]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphCloudAppSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphCloudAppSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphCloudAppSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_cloud_app_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'cloudAppSecurityProfile-id': self._serialize.url("cloud_app_security_profile_id", cloud_app_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphCloudAppSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_cloud_app_security_profile.metadata = {'url': '/Security/cloudAppSecurityProfiles/{cloudAppSecurityProfile-id}'}  # type: ignore

    async def update_cloud_app_security_profile(
        self,
        cloud_app_security_profile_id: str,
        id: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        deployment_package_url: Optional[str] = None,
        destination_service_name: Optional[str] = None,
        is_signed: Optional[bool] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        manifest: Optional[str] = None,
        name: Optional[str] = None,
        permissions_required: Optional[Union[str, "models.MicrosoftGraphApplicationPermissionsRequired"]] = None,
        platform: Optional[str] = None,
        policy_name: Optional[str] = None,
        publisher: Optional[str] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        type: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property cloudAppSecurityProfiles in Security.

        Update the navigation property cloudAppSecurityProfiles in Security.

        :param cloud_app_security_profile_id: key: id of cloudAppSecurityProfile.
        :type cloud_app_security_profile_id: str
        :param id: Read-only.
        :type id: str
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param deployment_package_url:
        :type deployment_package_url: str
        :param destination_service_name:
        :type destination_service_name: str
        :param is_signed:
        :type is_signed: bool
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param manifest:
        :type manifest: str
        :param name:
        :type name: str
        :param permissions_required:
        :type permissions_required: str or ~security.models.MicrosoftGraphApplicationPermissionsRequired
        :param platform:
        :type platform: str
        :param policy_name:
        :type policy_name: str
        :param publisher:
        :type publisher: str
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param type:
        :type type: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphCloudAppSecurityProfile(id=id, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, created_date_time=created_date_time, deployment_package_url=deployment_package_url, destination_service_name=destination_service_name, is_signed=is_signed, last_modified_date_time=last_modified_date_time, manifest=manifest, name=name, permissions_required=permissions_required, platform=platform, policy_name=policy_name, publisher=publisher, risk_score=risk_score, tags=tags, type=type, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_cloud_app_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'cloudAppSecurityProfile-id': self._serialize.url("cloud_app_security_profile_id", cloud_app_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphCloudAppSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_cloud_app_security_profile.metadata = {'url': '/Security/cloudAppSecurityProfiles/{cloudAppSecurityProfile-id}'}  # type: ignore

    async def delete_cloud_app_security_profile(
        self,
        cloud_app_security_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property cloudAppSecurityProfiles for Security.

        Delete navigation property cloudAppSecurityProfiles for Security.

        :param cloud_app_security_profile_id: key: id of cloudAppSecurityProfile.
        :type cloud_app_security_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_cloud_app_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'cloudAppSecurityProfile-id': self._serialize.url("cloud_app_security_profile_id", cloud_app_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_cloud_app_security_profile.metadata = {'url': '/Security/cloudAppSecurityProfiles/{cloudAppSecurityProfile-id}'}  # type: ignore

    def list_domain_security_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum29"]]] = None,
        select: Optional[List[Union[str, "models.Enum30"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfDomainSecurityProfile"]:
        """Get domainSecurityProfiles from Security.

        Get domainSecurityProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum29]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum30]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfDomainSecurityProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfDomainSecurityProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfDomainSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_domain_security_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfDomainSecurityProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_domain_security_profile.metadata = {'url': '/Security/domainSecurityProfiles'}  # type: ignore

    async def create_domain_security_profile(
        self,
        id: Optional[str] = None,
        activity_group_names: Optional[List[str]] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        count_hits: Optional[int] = None,
        count_in_org: Optional[int] = None,
        domain_categories: Optional[List["models.MicrosoftGraphReputationCategory"]] = None,
        domain_registered_date_time: Optional[datetime.datetime] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        registrant: Optional["models.MicrosoftGraphDomainRegistrant"] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDomainSecurityProfile":
        """Create new navigation property to domainSecurityProfiles for Security.

        Create new navigation property to domainSecurityProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param count_hits:
        :type count_hits: int
        :param count_in_org:
        :type count_in_org: int
        :param domain_categories:
        :type domain_categories: list[~security.models.MicrosoftGraphReputationCategory]
        :param domain_registered_date_time:
        :type domain_registered_date_time: ~datetime.datetime
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param name:
        :type name: str
        :param registrant: domainRegistrant.
        :type registrant: ~security.models.MicrosoftGraphDomainRegistrant
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDomainSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphDomainSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDomainSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDomainSecurityProfile(id=id, activity_group_names=activity_group_names, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, count_hits=count_hits, count_in_org=count_in_org, domain_categories=domain_categories, domain_registered_date_time=domain_registered_date_time, first_seen_date_time=first_seen_date_time, last_seen_date_time=last_seen_date_time, name=name, registrant=registrant, risk_score=risk_score, tags=tags, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_domain_security_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDomainSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDomainSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_domain_security_profile.metadata = {'url': '/Security/domainSecurityProfiles'}  # type: ignore

    async def get_domain_security_profile(
        self,
        domain_security_profile_id: str,
        select: Optional[List[Union[str, "models.Enum31"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphDomainSecurityProfile":
        """Get domainSecurityProfiles from Security.

        Get domainSecurityProfiles from Security.

        :param domain_security_profile_id: key: id of domainSecurityProfile.
        :type domain_security_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum31]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphDomainSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphDomainSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphDomainSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_domain_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'domainSecurityProfile-id': self._serialize.url("domain_security_profile_id", domain_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphDomainSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_domain_security_profile.metadata = {'url': '/Security/domainSecurityProfiles/{domainSecurityProfile-id}'}  # type: ignore

    async def update_domain_security_profile(
        self,
        domain_security_profile_id: str,
        id: Optional[str] = None,
        activity_group_names: Optional[List[str]] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        count_hits: Optional[int] = None,
        count_in_org: Optional[int] = None,
        domain_categories: Optional[List["models.MicrosoftGraphReputationCategory"]] = None,
        domain_registered_date_time: Optional[datetime.datetime] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        registrant: Optional["models.MicrosoftGraphDomainRegistrant"] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property domainSecurityProfiles in Security.

        Update the navigation property domainSecurityProfiles in Security.

        :param domain_security_profile_id: key: id of domainSecurityProfile.
        :type domain_security_profile_id: str
        :param id: Read-only.
        :type id: str
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param count_hits:
        :type count_hits: int
        :param count_in_org:
        :type count_in_org: int
        :param domain_categories:
        :type domain_categories: list[~security.models.MicrosoftGraphReputationCategory]
        :param domain_registered_date_time:
        :type domain_registered_date_time: ~datetime.datetime
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param name:
        :type name: str
        :param registrant: domainRegistrant.
        :type registrant: ~security.models.MicrosoftGraphDomainRegistrant
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphDomainSecurityProfile(id=id, activity_group_names=activity_group_names, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, count_hits=count_hits, count_in_org=count_in_org, domain_categories=domain_categories, domain_registered_date_time=domain_registered_date_time, first_seen_date_time=first_seen_date_time, last_seen_date_time=last_seen_date_time, name=name, registrant=registrant, risk_score=risk_score, tags=tags, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_domain_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'domainSecurityProfile-id': self._serialize.url("domain_security_profile_id", domain_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphDomainSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_domain_security_profile.metadata = {'url': '/Security/domainSecurityProfiles/{domainSecurityProfile-id}'}  # type: ignore

    async def delete_domain_security_profile(
        self,
        domain_security_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property domainSecurityProfiles for Security.

        Delete navigation property domainSecurityProfiles for Security.

        :param domain_security_profile_id: key: id of domainSecurityProfile.
        :type domain_security_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_domain_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'domainSecurityProfile-id': self._serialize.url("domain_security_profile_id", domain_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_domain_security_profile.metadata = {'url': '/Security/domainSecurityProfiles/{domainSecurityProfile-id}'}  # type: ignore

    def list_file_security_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum32"]]] = None,
        select: Optional[List[Union[str, "models.Enum33"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfFileSecurityProfile"]:
        """Get fileSecurityProfiles from Security.

        Get fileSecurityProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum32]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum33]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfFileSecurityProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfFileSecurityProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfFileSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_file_security_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfFileSecurityProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_file_security_profile.metadata = {'url': '/Security/fileSecurityProfiles'}  # type: ignore

    async def create_file_security_profile(
        self,
        id: Optional[str] = None,
        activity_group_names: Optional[List[str]] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        certificate_thumbprint: Optional[str] = None,
        extensions: Optional[List[str]] = None,
        file_type: Optional[str] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        hashes: Optional[List["models.MicrosoftGraphFileHash"]] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        malware_states: Optional[List["models.MicrosoftGraphMalwareState"]] = None,
        names: Optional[List[str]] = None,
        risk_score: Optional[str] = None,
        size: Optional[int] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        vulnerability_states: Optional[List["models.MicrosoftGraphVulnerabilityState"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphFileSecurityProfile":
        """Create new navigation property to fileSecurityProfiles for Security.

        Create new navigation property to fileSecurityProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param certificate_thumbprint:
        :type certificate_thumbprint: str
        :param extensions:
        :type extensions: list[str]
        :param file_type:
        :type file_type: str
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param hashes:
        :type hashes: list[~security.models.MicrosoftGraphFileHash]
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param malware_states:
        :type malware_states: list[~security.models.MicrosoftGraphMalwareState]
        :param names:
        :type names: list[str]
        :param risk_score:
        :type risk_score: str
        :param size:
        :type size: long
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :param vulnerability_states:
        :type vulnerability_states: list[~security.models.MicrosoftGraphVulnerabilityState]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphFileSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphFileSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphFileSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphFileSecurityProfile(id=id, activity_group_names=activity_group_names, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, certificate_thumbprint=certificate_thumbprint, extensions=extensions, file_type=file_type, first_seen_date_time=first_seen_date_time, hashes=hashes, last_seen_date_time=last_seen_date_time, malware_states=malware_states, names=names, risk_score=risk_score, size=size, tags=tags, vendor_information=vendor_information, vulnerability_states=vulnerability_states)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_file_security_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphFileSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphFileSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_file_security_profile.metadata = {'url': '/Security/fileSecurityProfiles'}  # type: ignore

    async def get_file_security_profile(
        self,
        file_security_profile_id: str,
        select: Optional[List[Union[str, "models.Enum34"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphFileSecurityProfile":
        """Get fileSecurityProfiles from Security.

        Get fileSecurityProfiles from Security.

        :param file_security_profile_id: key: id of fileSecurityProfile.
        :type file_security_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum34]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphFileSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphFileSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphFileSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_file_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'fileSecurityProfile-id': self._serialize.url("file_security_profile_id", file_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphFileSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_file_security_profile.metadata = {'url': '/Security/fileSecurityProfiles/{fileSecurityProfile-id}'}  # type: ignore

    async def update_file_security_profile(
        self,
        file_security_profile_id: str,
        id: Optional[str] = None,
        activity_group_names: Optional[List[str]] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        certificate_thumbprint: Optional[str] = None,
        extensions: Optional[List[str]] = None,
        file_type: Optional[str] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        hashes: Optional[List["models.MicrosoftGraphFileHash"]] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        malware_states: Optional[List["models.MicrosoftGraphMalwareState"]] = None,
        names: Optional[List[str]] = None,
        risk_score: Optional[str] = None,
        size: Optional[int] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        vulnerability_states: Optional[List["models.MicrosoftGraphVulnerabilityState"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property fileSecurityProfiles in Security.

        Update the navigation property fileSecurityProfiles in Security.

        :param file_security_profile_id: key: id of fileSecurityProfile.
        :type file_security_profile_id: str
        :param id: Read-only.
        :type id: str
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param certificate_thumbprint:
        :type certificate_thumbprint: str
        :param extensions:
        :type extensions: list[str]
        :param file_type:
        :type file_type: str
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param hashes:
        :type hashes: list[~security.models.MicrosoftGraphFileHash]
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param malware_states:
        :type malware_states: list[~security.models.MicrosoftGraphMalwareState]
        :param names:
        :type names: list[str]
        :param risk_score:
        :type risk_score: str
        :param size:
        :type size: long
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :param vulnerability_states:
        :type vulnerability_states: list[~security.models.MicrosoftGraphVulnerabilityState]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphFileSecurityProfile(id=id, activity_group_names=activity_group_names, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, certificate_thumbprint=certificate_thumbprint, extensions=extensions, file_type=file_type, first_seen_date_time=first_seen_date_time, hashes=hashes, last_seen_date_time=last_seen_date_time, malware_states=malware_states, names=names, risk_score=risk_score, size=size, tags=tags, vendor_information=vendor_information, vulnerability_states=vulnerability_states)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_file_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'fileSecurityProfile-id': self._serialize.url("file_security_profile_id", file_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphFileSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_file_security_profile.metadata = {'url': '/Security/fileSecurityProfiles/{fileSecurityProfile-id}'}  # type: ignore

    async def delete_file_security_profile(
        self,
        file_security_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property fileSecurityProfiles for Security.

        Delete navigation property fileSecurityProfiles for Security.

        :param file_security_profile_id: key: id of fileSecurityProfile.
        :type file_security_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_file_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'fileSecurityProfile-id': self._serialize.url("file_security_profile_id", file_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_file_security_profile.metadata = {'url': '/Security/fileSecurityProfiles/{fileSecurityProfile-id}'}  # type: ignore

    def list_host_security_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum35"]]] = None,
        select: Optional[List[Union[str, "models.Enum36"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfHostSecurityProfile"]:
        """Get hostSecurityProfiles from Security.

        Get hostSecurityProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum35]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum36]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfHostSecurityProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfHostSecurityProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfHostSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_host_security_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfHostSecurityProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_host_security_profile.metadata = {'url': '/Security/hostSecurityProfiles'}  # type: ignore

    async def create_host_security_profile(
        self,
        id: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        fqdn: Optional[str] = None,
        is_azure_ad_joined: Optional[bool] = None,
        is_azure_ad_registered: Optional[bool] = None,
        is_hybrid_azure_domain_joined: Optional[bool] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        logon_users: Optional[List["models.MicrosoftGraphLogonUser"]] = None,
        net_bios_name: Optional[str] = None,
        network_interfaces: Optional[List["models.MicrosoftGraphNetworkInterface"]] = None,
        os: Optional[str] = None,
        os_version: Optional[str] = None,
        parent_host: Optional[str] = None,
        related_host_ids: Optional[List[str]] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphHostSecurityProfile":
        """Create new navigation property to hostSecurityProfiles for Security.

        Create new navigation property to hostSecurityProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param fqdn:
        :type fqdn: str
        :param is_azure_ad_joined:
        :type is_azure_ad_joined: bool
        :param is_azure_ad_registered:
        :type is_azure_ad_registered: bool
        :param is_hybrid_azure_domain_joined:
        :type is_hybrid_azure_domain_joined: bool
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param logon_users:
        :type logon_users: list[~security.models.MicrosoftGraphLogonUser]
        :param net_bios_name:
        :type net_bios_name: str
        :param network_interfaces:
        :type network_interfaces: list[~security.models.MicrosoftGraphNetworkInterface]
        :param os:
        :type os: str
        :param os_version:
        :type os_version: str
        :param parent_host:
        :type parent_host: str
        :param related_host_ids:
        :type related_host_ids: list[str]
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphHostSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphHostSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphHostSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphHostSecurityProfile(id=id, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, first_seen_date_time=first_seen_date_time, fqdn=fqdn, is_azure_ad_joined=is_azure_ad_joined, is_azure_ad_registered=is_azure_ad_registered, is_hybrid_azure_domain_joined=is_hybrid_azure_domain_joined, last_seen_date_time=last_seen_date_time, logon_users=logon_users, net_bios_name=net_bios_name, network_interfaces=network_interfaces, os=os, os_version=os_version, parent_host=parent_host, related_host_ids=related_host_ids, risk_score=risk_score, tags=tags, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_host_security_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphHostSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphHostSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_host_security_profile.metadata = {'url': '/Security/hostSecurityProfiles'}  # type: ignore

    async def get_host_security_profile(
        self,
        host_security_profile_id: str,
        select: Optional[List[Union[str, "models.Enum37"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphHostSecurityProfile":
        """Get hostSecurityProfiles from Security.

        Get hostSecurityProfiles from Security.

        :param host_security_profile_id: key: id of hostSecurityProfile.
        :type host_security_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum37]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphHostSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphHostSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphHostSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_host_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'hostSecurityProfile-id': self._serialize.url("host_security_profile_id", host_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphHostSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_host_security_profile.metadata = {'url': '/Security/hostSecurityProfiles/{hostSecurityProfile-id}'}  # type: ignore

    async def update_host_security_profile(
        self,
        host_security_profile_id: str,
        id: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        fqdn: Optional[str] = None,
        is_azure_ad_joined: Optional[bool] = None,
        is_azure_ad_registered: Optional[bool] = None,
        is_hybrid_azure_domain_joined: Optional[bool] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        logon_users: Optional[List["models.MicrosoftGraphLogonUser"]] = None,
        net_bios_name: Optional[str] = None,
        network_interfaces: Optional[List["models.MicrosoftGraphNetworkInterface"]] = None,
        os: Optional[str] = None,
        os_version: Optional[str] = None,
        parent_host: Optional[str] = None,
        related_host_ids: Optional[List[str]] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property hostSecurityProfiles in Security.

        Update the navigation property hostSecurityProfiles in Security.

        :param host_security_profile_id: key: id of hostSecurityProfile.
        :type host_security_profile_id: str
        :param id: Read-only.
        :type id: str
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param fqdn:
        :type fqdn: str
        :param is_azure_ad_joined:
        :type is_azure_ad_joined: bool
        :param is_azure_ad_registered:
        :type is_azure_ad_registered: bool
        :param is_hybrid_azure_domain_joined:
        :type is_hybrid_azure_domain_joined: bool
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param logon_users:
        :type logon_users: list[~security.models.MicrosoftGraphLogonUser]
        :param net_bios_name:
        :type net_bios_name: str
        :param network_interfaces:
        :type network_interfaces: list[~security.models.MicrosoftGraphNetworkInterface]
        :param os:
        :type os: str
        :param os_version:
        :type os_version: str
        :param parent_host:
        :type parent_host: str
        :param related_host_ids:
        :type related_host_ids: list[str]
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphHostSecurityProfile(id=id, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, first_seen_date_time=first_seen_date_time, fqdn=fqdn, is_azure_ad_joined=is_azure_ad_joined, is_azure_ad_registered=is_azure_ad_registered, is_hybrid_azure_domain_joined=is_hybrid_azure_domain_joined, last_seen_date_time=last_seen_date_time, logon_users=logon_users, net_bios_name=net_bios_name, network_interfaces=network_interfaces, os=os, os_version=os_version, parent_host=parent_host, related_host_ids=related_host_ids, risk_score=risk_score, tags=tags, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_host_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'hostSecurityProfile-id': self._serialize.url("host_security_profile_id", host_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphHostSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_host_security_profile.metadata = {'url': '/Security/hostSecurityProfiles/{hostSecurityProfile-id}'}  # type: ignore

    async def delete_host_security_profile(
        self,
        host_security_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property hostSecurityProfiles for Security.

        Delete navigation property hostSecurityProfiles for Security.

        :param host_security_profile_id: key: id of hostSecurityProfile.
        :type host_security_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_host_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'hostSecurityProfile-id': self._serialize.url("host_security_profile_id", host_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_host_security_profile.metadata = {'url': '/Security/hostSecurityProfiles/{hostSecurityProfile-id}'}  # type: ignore

    def list_ip_security_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum38"]]] = None,
        select: Optional[List[Union[str, "models.Enum39"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfIpSecurityProfile"]:
        """Get ipSecurityProfiles from Security.

        Get ipSecurityProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum38]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum39]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfIpSecurityProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfIpSecurityProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfIpSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_ip_security_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfIpSecurityProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ip_security_profile.metadata = {'url': '/Security/ipSecurityProfiles'}  # type: ignore

    async def create_ip_security_profile(
        self,
        id: Optional[str] = None,
        activity_group_names: Optional[List[str]] = None,
        address: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        count_hits: Optional[int] = None,
        count_hosts: Optional[int] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        ip_categories: Optional[List["models.MicrosoftGraphIpCategory"]] = None,
        ip_reference_data: Optional[List["models.MicrosoftGraphIpReferenceData"]] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphIpSecurityProfile":
        """Create new navigation property to ipSecurityProfiles for Security.

        Create new navigation property to ipSecurityProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param address:
        :type address: str
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param count_hits:
        :type count_hits: int
        :param count_hosts:
        :type count_hosts: int
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param ip_categories:
        :type ip_categories: list[~security.models.MicrosoftGraphIpCategory]
        :param ip_reference_data:
        :type ip_reference_data: list[~security.models.MicrosoftGraphIpReferenceData]
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIpSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphIpSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIpSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphIpSecurityProfile(id=id, activity_group_names=activity_group_names, address=address, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, count_hits=count_hits, count_hosts=count_hosts, first_seen_date_time=first_seen_date_time, ip_categories=ip_categories, ip_reference_data=ip_reference_data, last_seen_date_time=last_seen_date_time, risk_score=risk_score, tags=tags, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ip_security_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphIpSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIpSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ip_security_profile.metadata = {'url': '/Security/ipSecurityProfiles'}  # type: ignore

    async def get_ip_security_profile(
        self,
        ip_security_profile_id: str,
        select: Optional[List[Union[str, "models.Enum40"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphIpSecurityProfile":
        """Get ipSecurityProfiles from Security.

        Get ipSecurityProfiles from Security.

        :param ip_security_profile_id: key: id of ipSecurityProfile.
        :type ip_security_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum40]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphIpSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphIpSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphIpSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_ip_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'ipSecurityProfile-id': self._serialize.url("ip_security_profile_id", ip_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphIpSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_ip_security_profile.metadata = {'url': '/Security/ipSecurityProfiles/{ipSecurityProfile-id}'}  # type: ignore

    async def update_ip_security_profile(
        self,
        ip_security_profile_id: str,
        id: Optional[str] = None,
        activity_group_names: Optional[List[str]] = None,
        address: Optional[str] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        count_hits: Optional[int] = None,
        count_hosts: Optional[int] = None,
        first_seen_date_time: Optional[datetime.datetime] = None,
        ip_categories: Optional[List["models.MicrosoftGraphIpCategory"]] = None,
        ip_reference_data: Optional[List["models.MicrosoftGraphIpReferenceData"]] = None,
        last_seen_date_time: Optional[datetime.datetime] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property ipSecurityProfiles in Security.

        Update the navigation property ipSecurityProfiles in Security.

        :param ip_security_profile_id: key: id of ipSecurityProfile.
        :type ip_security_profile_id: str
        :param id: Read-only.
        :type id: str
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param address:
        :type address: str
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param count_hits:
        :type count_hits: int
        :param count_hosts:
        :type count_hosts: int
        :param first_seen_date_time:
        :type first_seen_date_time: ~datetime.datetime
        :param ip_categories:
        :type ip_categories: list[~security.models.MicrosoftGraphIpCategory]
        :param ip_reference_data:
        :type ip_reference_data: list[~security.models.MicrosoftGraphIpReferenceData]
        :param last_seen_date_time:
        :type last_seen_date_time: ~datetime.datetime
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphIpSecurityProfile(id=id, activity_group_names=activity_group_names, address=address, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, count_hits=count_hits, count_hosts=count_hosts, first_seen_date_time=first_seen_date_time, ip_categories=ip_categories, ip_reference_data=ip_reference_data, last_seen_date_time=last_seen_date_time, risk_score=risk_score, tags=tags, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_ip_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'ipSecurityProfile-id': self._serialize.url("ip_security_profile_id", ip_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphIpSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_ip_security_profile.metadata = {'url': '/Security/ipSecurityProfiles/{ipSecurityProfile-id}'}  # type: ignore

    async def delete_ip_security_profile(
        self,
        ip_security_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property ipSecurityProfiles for Security.

        Delete navigation property ipSecurityProfiles for Security.

        :param ip_security_profile_id: key: id of ipSecurityProfile.
        :type ip_security_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_ip_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'ipSecurityProfile-id': self._serialize.url("ip_security_profile_id", ip_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_ip_security_profile.metadata = {'url': '/Security/ipSecurityProfiles/{ipSecurityProfile-id}'}  # type: ignore

    def list_provider_tenant_setting(
        self,
        orderby: Optional[List[Union[str, "models.Enum41"]]] = None,
        select: Optional[List[Union[str, "models.Enum42"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfProviderTenantSetting"]:
        """Get providerTenantSettings from Security.

        Get providerTenantSettings from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum41]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum42]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfProviderTenantSetting or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfProviderTenantSetting]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfProviderTenantSetting"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_provider_tenant_setting.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfProviderTenantSetting', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_provider_tenant_setting.metadata = {'url': '/Security/providerTenantSettings'}  # type: ignore

    async def create_provider_tenant_setting(
        self,
        id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        enabled: Optional[bool] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        provider: Optional[str] = None,
        vendor: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphProviderTenantSetting":
        """Create new navigation property to providerTenantSettings for Security.

        Create new navigation property to providerTenantSettings for Security.

        :param id: Read-only.
        :type id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param enabled:
        :type enabled: bool
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param provider:
        :type provider: str
        :param vendor:
        :type vendor: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphProviderTenantSetting, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphProviderTenantSetting
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphProviderTenantSetting"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphProviderTenantSetting(id=id, azure_tenant_id=azure_tenant_id, enabled=enabled, last_modified_date_time=last_modified_date_time, provider=provider, vendor=vendor)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_provider_tenant_setting.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphProviderTenantSetting')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphProviderTenantSetting', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_provider_tenant_setting.metadata = {'url': '/Security/providerTenantSettings'}  # type: ignore

    async def get_provider_tenant_setting(
        self,
        provider_tenant_setting_id: str,
        select: Optional[List[Union[str, "models.Enum43"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphProviderTenantSetting":
        """Get providerTenantSettings from Security.

        Get providerTenantSettings from Security.

        :param provider_tenant_setting_id: key: id of providerTenantSetting.
        :type provider_tenant_setting_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum43]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphProviderTenantSetting, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphProviderTenantSetting
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphProviderTenantSetting"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_provider_tenant_setting.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerTenantSetting-id': self._serialize.url("provider_tenant_setting_id", provider_tenant_setting_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphProviderTenantSetting', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_provider_tenant_setting.metadata = {'url': '/Security/providerTenantSettings/{providerTenantSetting-id}'}  # type: ignore

    async def update_provider_tenant_setting(
        self,
        provider_tenant_setting_id: str,
        id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        enabled: Optional[bool] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        provider: Optional[str] = None,
        vendor: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property providerTenantSettings in Security.

        Update the navigation property providerTenantSettings in Security.

        :param provider_tenant_setting_id: key: id of providerTenantSetting.
        :type provider_tenant_setting_id: str
        :param id: Read-only.
        :type id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param enabled:
        :type enabled: bool
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param provider:
        :type provider: str
        :param vendor:
        :type vendor: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphProviderTenantSetting(id=id, azure_tenant_id=azure_tenant_id, enabled=enabled, last_modified_date_time=last_modified_date_time, provider=provider, vendor=vendor)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_provider_tenant_setting.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerTenantSetting-id': self._serialize.url("provider_tenant_setting_id", provider_tenant_setting_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphProviderTenantSetting')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_provider_tenant_setting.metadata = {'url': '/Security/providerTenantSettings/{providerTenantSetting-id}'}  # type: ignore

    async def delete_provider_tenant_setting(
        self,
        provider_tenant_setting_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property providerTenantSettings for Security.

        Delete navigation property providerTenantSettings for Security.

        :param provider_tenant_setting_id: key: id of providerTenantSetting.
        :type provider_tenant_setting_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_provider_tenant_setting.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerTenantSetting-id': self._serialize.url("provider_tenant_setting_id", provider_tenant_setting_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_provider_tenant_setting.metadata = {'url': '/Security/providerTenantSettings/{providerTenantSetting-id}'}  # type: ignore

    def list_secure_score_control_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum44"]]] = None,
        select: Optional[List[Union[str, "models.Enum45"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSecureScoreControlProfile"]:
        """Get secureScoreControlProfiles from Security.

        Get secureScoreControlProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum44]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum45]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSecureScoreControlProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfSecureScoreControlProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSecureScoreControlProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_secure_score_control_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSecureScoreControlProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles'}  # type: ignore

    async def create_secure_score_control_profile(
        self,
        id: Optional[str] = None,
        action_type: Optional[str] = None,
        action_url: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        compliance_information: Optional[List["models.MicrosoftGraphComplianceInformation"]] = None,
        control_category: Optional[str] = None,
        control_state_updates: Optional[List["models.MicrosoftGraphSecureScoreControlStateUpdate"]] = None,
        deprecated: Optional[bool] = None,
        implementation_cost: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        max_score: Optional[float] = None,
        rank: Optional[int] = None,
        remediation: Optional[str] = None,
        remediation_impact: Optional[str] = None,
        service: Optional[str] = None,
        threats: Optional[List[str]] = None,
        tier: Optional[str] = None,
        title: Optional[str] = None,
        user_impact: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScoreControlProfile":
        """Create new navigation property to secureScoreControlProfiles for Security.

        Create new navigation property to secureScoreControlProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param action_type: Control action type (Config, Review, Behavior).
        :type action_type: str
        :param action_url: URL to where the control can be actioned.
        :type action_url: str
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param compliance_information:
        :type compliance_information: list[~security.models.MicrosoftGraphComplianceInformation]
        :param control_category: Control action category (Identity, Data, Device, Apps,
         Infrastructure).
        :type control_category: str
        :param control_state_updates:
        :type control_state_updates: list[~security.models.MicrosoftGraphSecureScoreControlStateUpdate]
        :param deprecated: Flag to indicate if a control is depreciated.
        :type deprecated: bool
        :param implementation_cost: Resource cost of implemmentating control (low, moderate, high).
        :type implementation_cost: str
        :param last_modified_date_time: Time at which the control profile entity was last modified. The
         Timestamp type represents date and time.
        :type last_modified_date_time: ~datetime.datetime
        :param max_score: max attainable score for the control.
        :type max_score: float
        :param rank: Microsoft's stack ranking of control.
        :type rank: int
        :param remediation: Description of what the control will help remediate.
        :type remediation: str
        :param remediation_impact: Description of the impact on users of the remediation.
        :type remediation_impact: str
        :param service: Service that owns the control (Exchange, Sharepoint, Azure AD).
        :type service: str
        :param threats: List of threats the control mitigates
         (accountBreach,dataDeletion,dataExfiltration,dataSpillage,.
        :type threats: list[str]
        :param tier:
        :type tier: str
        :param title: Title of the control.
        :type title: str
        :param user_impact:
        :type user_impact: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScoreControlProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScoreControlProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScoreControlProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScoreControlProfile(id=id, action_type=action_type, action_url=action_url, azure_tenant_id=azure_tenant_id, compliance_information=compliance_information, control_category=control_category, control_state_updates=control_state_updates, deprecated=deprecated, implementation_cost=implementation_cost, last_modified_date_time=last_modified_date_time, max_score=max_score, rank=rank, remediation=remediation, remediation_impact=remediation_impact, service=service, threats=threats, tier=tier, title=title, user_impact=user_impact, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_secure_score_control_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScoreControlProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScoreControlProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles'}  # type: ignore

    async def get_secure_score_control_profile(
        self,
        secure_score_control_profile_id: str,
        select: Optional[List[Union[str, "models.Enum46"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScoreControlProfile":
        """Get secureScoreControlProfiles from Security.

        Get secureScoreControlProfiles from Security.

        :param secure_score_control_profile_id: key: id of secureScoreControlProfile.
        :type secure_score_control_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum46]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScoreControlProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScoreControlProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScoreControlProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_secure_score_control_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScoreControlProfile-id': self._serialize.url("secure_score_control_profile_id", secure_score_control_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScoreControlProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles/{secureScoreControlProfile-id}'}  # type: ignore

    async def update_secure_score_control_profile(
        self,
        secure_score_control_profile_id: str,
        id: Optional[str] = None,
        action_type: Optional[str] = None,
        action_url: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        compliance_information: Optional[List["models.MicrosoftGraphComplianceInformation"]] = None,
        control_category: Optional[str] = None,
        control_state_updates: Optional[List["models.MicrosoftGraphSecureScoreControlStateUpdate"]] = None,
        deprecated: Optional[bool] = None,
        implementation_cost: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        max_score: Optional[float] = None,
        rank: Optional[int] = None,
        remediation: Optional[str] = None,
        remediation_impact: Optional[str] = None,
        service: Optional[str] = None,
        threats: Optional[List[str]] = None,
        tier: Optional[str] = None,
        title: Optional[str] = None,
        user_impact: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property secureScoreControlProfiles in Security.

        Update the navigation property secureScoreControlProfiles in Security.

        :param secure_score_control_profile_id: key: id of secureScoreControlProfile.
        :type secure_score_control_profile_id: str
        :param id: Read-only.
        :type id: str
        :param action_type: Control action type (Config, Review, Behavior).
        :type action_type: str
        :param action_url: URL to where the control can be actioned.
        :type action_url: str
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param compliance_information:
        :type compliance_information: list[~security.models.MicrosoftGraphComplianceInformation]
        :param control_category: Control action category (Identity, Data, Device, Apps,
         Infrastructure).
        :type control_category: str
        :param control_state_updates:
        :type control_state_updates: list[~security.models.MicrosoftGraphSecureScoreControlStateUpdate]
        :param deprecated: Flag to indicate if a control is depreciated.
        :type deprecated: bool
        :param implementation_cost: Resource cost of implemmentating control (low, moderate, high).
        :type implementation_cost: str
        :param last_modified_date_time: Time at which the control profile entity was last modified. The
         Timestamp type represents date and time.
        :type last_modified_date_time: ~datetime.datetime
        :param max_score: max attainable score for the control.
        :type max_score: float
        :param rank: Microsoft's stack ranking of control.
        :type rank: int
        :param remediation: Description of what the control will help remediate.
        :type remediation: str
        :param remediation_impact: Description of the impact on users of the remediation.
        :type remediation_impact: str
        :param service: Service that owns the control (Exchange, Sharepoint, Azure AD).
        :type service: str
        :param threats: List of threats the control mitigates
         (accountBreach,dataDeletion,dataExfiltration,dataSpillage,.
        :type threats: list[str]
        :param tier:
        :type tier: str
        :param title: Title of the control.
        :type title: str
        :param user_impact:
        :type user_impact: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScoreControlProfile(id=id, action_type=action_type, action_url=action_url, azure_tenant_id=azure_tenant_id, compliance_information=compliance_information, control_category=control_category, control_state_updates=control_state_updates, deprecated=deprecated, implementation_cost=implementation_cost, last_modified_date_time=last_modified_date_time, max_score=max_score, rank=rank, remediation=remediation, remediation_impact=remediation_impact, service=service, threats=threats, tier=tier, title=title, user_impact=user_impact, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_secure_score_control_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScoreControlProfile-id': self._serialize.url("secure_score_control_profile_id", secure_score_control_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScoreControlProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles/{secureScoreControlProfile-id}'}  # type: ignore

    async def delete_secure_score_control_profile(
        self,
        secure_score_control_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property secureScoreControlProfiles for Security.

        Delete navigation property secureScoreControlProfiles for Security.

        :param secure_score_control_profile_id: key: id of secureScoreControlProfile.
        :type secure_score_control_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_secure_score_control_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScoreControlProfile-id': self._serialize.url("secure_score_control_profile_id", secure_score_control_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_secure_score_control_profile.metadata = {'url': '/Security/secureScoreControlProfiles/{secureScoreControlProfile-id}'}  # type: ignore

    def list_secure_score(
        self,
        orderby: Optional[List[Union[str, "models.Enum47"]]] = None,
        select: Optional[List[Union[str, "models.Enum48"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSecureScore"]:
        """Get secureScores from Security.

        Get secureScores from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum47]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum48]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSecureScore or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfSecureScore]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSecureScore"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_secure_score.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSecureScore', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_secure_score.metadata = {'url': '/Security/secureScores'}  # type: ignore

    async def create_secure_score(
        self,
        id: Optional[str] = None,
        active_user_count: Optional[int] = None,
        average_comparative_scores: Optional[List["models.MicrosoftGraphAverageComparativeScore"]] = None,
        azure_tenant_id: Optional[str] = None,
        control_scores: Optional[List["models.MicrosoftGraphControlScore"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        current_score: Optional[float] = None,
        enabled_services: Optional[List[str]] = None,
        licensed_user_count: Optional[int] = None,
        max_score: Optional[float] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScore":
        """Create new navigation property to secureScores for Security.

        Create new navigation property to secureScores for Security.

        :param id: Read-only.
        :type id: str
        :param active_user_count: Active user count of the given tenant.
        :type active_user_count: int
        :param average_comparative_scores: Average score by different scopes (for example, average by
         industry, average by seating) and control category (Identity, Data, Device, Apps,
         Infrastructure) within the scope.
        :type average_comparative_scores: list[~security.models.MicrosoftGraphAverageComparativeScore]
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param control_scores: Contains tenant scores for a set of controls.
        :type control_scores: list[~security.models.MicrosoftGraphControlScore]
        :param created_date_time: The date when the entity is created.
        :type created_date_time: ~datetime.datetime
        :param current_score: Tenant current attained score on specified date.
        :type current_score: float
        :param enabled_services: Microsoft-provided services for the tenant (for example, Exchange
         online, Skype, Sharepoint).
        :type enabled_services: list[str]
        :param licensed_user_count: Licensed user count of the given tenant.
        :type licensed_user_count: int
        :param max_score: Tenant maximum possible score on specified date.
        :type max_score: float
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScore, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScore
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScore"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScore(id=id, active_user_count=active_user_count, average_comparative_scores=average_comparative_scores, azure_tenant_id=azure_tenant_id, control_scores=control_scores, created_date_time=created_date_time, current_score=current_score, enabled_services=enabled_services, licensed_user_count=licensed_user_count, max_score=max_score, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_secure_score.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScore')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScore', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_secure_score.metadata = {'url': '/Security/secureScores'}  # type: ignore

    async def get_secure_score(
        self,
        secure_score_id: str,
        select: Optional[List[Union[str, "models.Enum49"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecureScore":
        """Get secureScores from Security.

        Get secureScores from Security.

        :param secure_score_id: key: id of secureScore.
        :type secure_score_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum49]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecureScore, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecureScore
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecureScore"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScore-id': self._serialize.url("secure_score_id", secure_score_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecureScore', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_secure_score.metadata = {'url': '/Security/secureScores/{secureScore-id}'}  # type: ignore

    async def update_secure_score(
        self,
        secure_score_id: str,
        id: Optional[str] = None,
        active_user_count: Optional[int] = None,
        average_comparative_scores: Optional[List["models.MicrosoftGraphAverageComparativeScore"]] = None,
        azure_tenant_id: Optional[str] = None,
        control_scores: Optional[List["models.MicrosoftGraphControlScore"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        current_score: Optional[float] = None,
        enabled_services: Optional[List[str]] = None,
        licensed_user_count: Optional[int] = None,
        max_score: Optional[float] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property secureScores in Security.

        Update the navigation property secureScores in Security.

        :param secure_score_id: key: id of secureScore.
        :type secure_score_id: str
        :param id: Read-only.
        :type id: str
        :param active_user_count: Active user count of the given tenant.
        :type active_user_count: int
        :param average_comparative_scores: Average score by different scopes (for example, average by
         industry, average by seating) and control category (Identity, Data, Device, Apps,
         Infrastructure) within the scope.
        :type average_comparative_scores: list[~security.models.MicrosoftGraphAverageComparativeScore]
        :param azure_tenant_id: GUID string for tenant ID.
        :type azure_tenant_id: str
        :param control_scores: Contains tenant scores for a set of controls.
        :type control_scores: list[~security.models.MicrosoftGraphControlScore]
        :param created_date_time: The date when the entity is created.
        :type created_date_time: ~datetime.datetime
        :param current_score: Tenant current attained score on specified date.
        :type current_score: float
        :param enabled_services: Microsoft-provided services for the tenant (for example, Exchange
         online, Skype, Sharepoint).
        :type enabled_services: list[str]
        :param licensed_user_count: Licensed user count of the given tenant.
        :type licensed_user_count: int
        :param max_score: Tenant maximum possible score on specified date.
        :type max_score: float
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecureScore(id=id, active_user_count=active_user_count, average_comparative_scores=average_comparative_scores, azure_tenant_id=azure_tenant_id, control_scores=control_scores, created_date_time=created_date_time, current_score=current_score, enabled_services=enabled_services, licensed_user_count=licensed_user_count, max_score=max_score, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScore-id': self._serialize.url("secure_score_id", secure_score_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecureScore')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_secure_score.metadata = {'url': '/Security/secureScores/{secureScore-id}'}  # type: ignore

    async def delete_secure_score(
        self,
        secure_score_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property secureScores for Security.

        Delete navigation property secureScores for Security.

        :param secure_score_id: key: id of secureScore.
        :type secure_score_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_secure_score.metadata['url']  # type: ignore
        path_format_arguments = {
            'secureScore-id': self._serialize.url("secure_score_id", secure_score_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_secure_score.metadata = {'url': '/Security/secureScores/{secureScore-id}'}  # type: ignore

    def list_security_action(
        self,
        orderby: Optional[List[Union[str, "models.Enum50"]]] = None,
        select: Optional[List[Union[str, "models.Enum51"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSecurityAction"]:
        """Get securityActions from Security.

        Get securityActions from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum50]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum51]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSecurityAction or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfSecurityAction]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSecurityAction"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_security_action.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSecurityAction', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_security_action.metadata = {'url': '/Security/securityActions'}  # type: ignore

    async def create_security_action(
        self,
        id: Optional[str] = None,
        action_reason: Optional[str] = None,
        app_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        client_context: Optional[str] = None,
        completed_date_time: Optional[datetime.datetime] = None,
        created_date_time: Optional[datetime.datetime] = None,
        error_info: Optional["models.MicrosoftGraphResultInfo"] = None,
        last_action_date_time: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        parameters: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        states: Optional[List["models.MicrosoftGraphSecurityActionState"]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphOperationStatus"]] = None,
        user: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecurityAction":
        """Create new navigation property to securityActions for Security.

        Create new navigation property to securityActions for Security.

        :param id: Read-only.
        :type id: str
        :param action_reason:
        :type action_reason: str
        :param app_id:
        :type app_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param client_context:
        :type client_context: str
        :param completed_date_time:
        :type completed_date_time: ~datetime.datetime
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param error_info: ResultInfo.
        :type error_info: ~security.models.MicrosoftGraphResultInfo
        :param last_action_date_time:
        :type last_action_date_time: ~datetime.datetime
        :param name:
        :type name: str
        :param parameters:
        :type parameters: list[~security.models.MicrosoftGraphKeyValuePair]
        :param states:
        :type states: list[~security.models.MicrosoftGraphSecurityActionState]
        :param status:
        :type status: str or ~security.models.MicrosoftGraphOperationStatus
        :param user:
        :type user: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecurityAction, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecurityAction
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecurityAction"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecurityAction(id=id, action_reason=action_reason, app_id=app_id, azure_tenant_id=azure_tenant_id, client_context=client_context, completed_date_time=completed_date_time, created_date_time=created_date_time, error_info=error_info, last_action_date_time=last_action_date_time, name=name, parameters=parameters, states=states, status=status, user=user, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_security_action.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecurityAction')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecurityAction', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_security_action.metadata = {'url': '/Security/securityActions'}  # type: ignore

    async def get_security_action(
        self,
        security_action_id: str,
        select: Optional[List[Union[str, "models.Enum52"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSecurityAction":
        """Get securityActions from Security.

        Get securityActions from Security.

        :param security_action_id: key: id of securityAction.
        :type security_action_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum52]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSecurityAction, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphSecurityAction
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSecurityAction"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_security_action.metadata['url']  # type: ignore
        path_format_arguments = {
            'securityAction-id': self._serialize.url("security_action_id", security_action_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSecurityAction', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_security_action.metadata = {'url': '/Security/securityActions/{securityAction-id}'}  # type: ignore

    async def update_security_action(
        self,
        security_action_id: str,
        id: Optional[str] = None,
        action_reason: Optional[str] = None,
        app_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        client_context: Optional[str] = None,
        completed_date_time: Optional[datetime.datetime] = None,
        created_date_time: Optional[datetime.datetime] = None,
        error_info: Optional["models.MicrosoftGraphResultInfo"] = None,
        last_action_date_time: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        parameters: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        states: Optional[List["models.MicrosoftGraphSecurityActionState"]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphOperationStatus"]] = None,
        user: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property securityActions in Security.

        Update the navigation property securityActions in Security.

        :param security_action_id: key: id of securityAction.
        :type security_action_id: str
        :param id: Read-only.
        :type id: str
        :param action_reason:
        :type action_reason: str
        :param app_id:
        :type app_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param client_context:
        :type client_context: str
        :param completed_date_time:
        :type completed_date_time: ~datetime.datetime
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param error_info: ResultInfo.
        :type error_info: ~security.models.MicrosoftGraphResultInfo
        :param last_action_date_time:
        :type last_action_date_time: ~datetime.datetime
        :param name:
        :type name: str
        :param parameters:
        :type parameters: list[~security.models.MicrosoftGraphKeyValuePair]
        :param states:
        :type states: list[~security.models.MicrosoftGraphSecurityActionState]
        :param status:
        :type status: str or ~security.models.MicrosoftGraphOperationStatus
        :param user:
        :type user: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphSecurityAction(id=id, action_reason=action_reason, app_id=app_id, azure_tenant_id=azure_tenant_id, client_context=client_context, completed_date_time=completed_date_time, created_date_time=created_date_time, error_info=error_info, last_action_date_time=last_action_date_time, name=name, parameters=parameters, states=states, status=status, user=user, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_security_action.metadata['url']  # type: ignore
        path_format_arguments = {
            'securityAction-id': self._serialize.url("security_action_id", security_action_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphSecurityAction')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_security_action.metadata = {'url': '/Security/securityActions/{securityAction-id}'}  # type: ignore

    async def delete_security_action(
        self,
        security_action_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property securityActions for Security.

        Delete navigation property securityActions for Security.

        :param security_action_id: key: id of securityAction.
        :type security_action_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_security_action.metadata['url']  # type: ignore
        path_format_arguments = {
            'securityAction-id': self._serialize.url("security_action_id", security_action_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_security_action.metadata = {'url': '/Security/securityActions/{securityAction-id}'}  # type: ignore

    def list_ti_indicator(
        self,
        orderby: Optional[List[Union[str, "models.Enum53"]]] = None,
        select: Optional[List[Union[str, "models.Enum54"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTIIndicator"]:
        """Get tiIndicators from Security.

        Get tiIndicators from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum53]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum54]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTIIndicator or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfTIIndicator]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTIIndicator"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_ti_indicator.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTIIndicator', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ti_indicator.metadata = {'url': '/Security/tiIndicators'}  # type: ignore

    async def create_ti_indicator(
        self,
        id: Optional[str] = None,
        action: Optional[Union[str, "models.MicrosoftGraphTIAction"]] = None,
        activity_group_names: Optional[List[str]] = None,
        additional_information: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        confidence: Optional[int] = None,
        description: Optional[str] = None,
        diamond_model: Optional[Union[str, "models.MicrosoftGraphDiamondModel"]] = None,
        domain_name: Optional[str] = None,
        email_encoding: Optional[str] = None,
        email_language: Optional[str] = None,
        email_recipient: Optional[str] = None,
        email_sender_address: Optional[str] = None,
        email_sender_name: Optional[str] = None,
        email_source_domain: Optional[str] = None,
        email_source_ip_address: Optional[str] = None,
        email_subject: Optional[str] = None,
        email_x_mailer: Optional[str] = None,
        expiration_date_time: Optional[datetime.datetime] = None,
        external_id: Optional[str] = None,
        file_compile_date_time: Optional[datetime.datetime] = None,
        file_created_date_time: Optional[datetime.datetime] = None,
        file_hash_type: Optional[Union[str, "models.MicrosoftGraphFileHashType"]] = None,
        file_hash_value: Optional[str] = None,
        file_mutex_name: Optional[str] = None,
        file_name: Optional[str] = None,
        file_packer: Optional[str] = None,
        file_path: Optional[str] = None,
        file_size: Optional[int] = None,
        file_type: Optional[str] = None,
        ingested_date_time: Optional[datetime.datetime] = None,
        is_active: Optional[bool] = None,
        kill_chain: Optional[List[str]] = None,
        known_false_positives: Optional[str] = None,
        last_reported_date_time: Optional[datetime.datetime] = None,
        malware_family_names: Optional[List[str]] = None,
        network_cidr_block: Optional[str] = None,
        network_destination_asn: Optional[int] = None,
        network_destination_cidr_block: Optional[str] = None,
        network_destination_i_pv4: Optional[str] = None,
        network_destination_i_pv6: Optional[str] = None,
        network_destination_port: Optional[int] = None,
        network_i_pv4: Optional[str] = None,
        network_i_pv6: Optional[str] = None,
        network_port: Optional[int] = None,
        network_protocol: Optional[int] = None,
        network_source_asn: Optional[int] = None,
        network_source_cidr_block: Optional[str] = None,
        network_source_i_pv4: Optional[str] = None,
        network_source_i_pv6: Optional[str] = None,
        network_source_port: Optional[int] = None,
        passive_only: Optional[bool] = None,
        severity: Optional[int] = None,
        tags: Optional[List[str]] = None,
        target_product: Optional[str] = None,
        threat_type: Optional[str] = None,
        tlp_level: Optional[Union[str, "models.MicrosoftGraphTlpLevel"]] = None,
        url: Optional[str] = None,
        user_agent_parameter: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTIIndicator":
        """Create new navigation property to tiIndicators for Security.

        Create new navigation property to tiIndicators for Security.

        :param id: Read-only.
        :type id: str
        :param action:
        :type action: str or ~security.models.MicrosoftGraphTIAction
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param additional_information:
        :type additional_information: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param confidence:
        :type confidence: int
        :param description:
        :type description: str
        :param diamond_model:
        :type diamond_model: str or ~security.models.MicrosoftGraphDiamondModel
        :param domain_name:
        :type domain_name: str
        :param email_encoding:
        :type email_encoding: str
        :param email_language:
        :type email_language: str
        :param email_recipient:
        :type email_recipient: str
        :param email_sender_address:
        :type email_sender_address: str
        :param email_sender_name:
        :type email_sender_name: str
        :param email_source_domain:
        :type email_source_domain: str
        :param email_source_ip_address:
        :type email_source_ip_address: str
        :param email_subject:
        :type email_subject: str
        :param email_x_mailer:
        :type email_x_mailer: str
        :param expiration_date_time:
        :type expiration_date_time: ~datetime.datetime
        :param external_id:
        :type external_id: str
        :param file_compile_date_time:
        :type file_compile_date_time: ~datetime.datetime
        :param file_created_date_time:
        :type file_created_date_time: ~datetime.datetime
        :param file_hash_type:
        :type file_hash_type: str or ~security.models.MicrosoftGraphFileHashType
        :param file_hash_value:
        :type file_hash_value: str
        :param file_mutex_name:
        :type file_mutex_name: str
        :param file_name:
        :type file_name: str
        :param file_packer:
        :type file_packer: str
        :param file_path:
        :type file_path: str
        :param file_size:
        :type file_size: long
        :param file_type:
        :type file_type: str
        :param ingested_date_time:
        :type ingested_date_time: ~datetime.datetime
        :param is_active:
        :type is_active: bool
        :param kill_chain:
        :type kill_chain: list[str]
        :param known_false_positives:
        :type known_false_positives: str
        :param last_reported_date_time:
        :type last_reported_date_time: ~datetime.datetime
        :param malware_family_names:
        :type malware_family_names: list[str]
        :param network_cidr_block:
        :type network_cidr_block: str
        :param network_destination_asn:
        :type network_destination_asn: int
        :param network_destination_cidr_block:
        :type network_destination_cidr_block: str
        :param network_destination_i_pv4:
        :type network_destination_i_pv4: str
        :param network_destination_i_pv6:
        :type network_destination_i_pv6: str
        :param network_destination_port:
        :type network_destination_port: int
        :param network_i_pv4:
        :type network_i_pv4: str
        :param network_i_pv6:
        :type network_i_pv6: str
        :param network_port:
        :type network_port: int
        :param network_protocol:
        :type network_protocol: int
        :param network_source_asn:
        :type network_source_asn: int
        :param network_source_cidr_block:
        :type network_source_cidr_block: str
        :param network_source_i_pv4:
        :type network_source_i_pv4: str
        :param network_source_i_pv6:
        :type network_source_i_pv6: str
        :param network_source_port:
        :type network_source_port: int
        :param passive_only:
        :type passive_only: bool
        :param severity:
        :type severity: int
        :param tags:
        :type tags: list[str]
        :param target_product:
        :type target_product: str
        :param threat_type:
        :type threat_type: str
        :param tlp_level:
        :type tlp_level: str or ~security.models.MicrosoftGraphTlpLevel
        :param url:
        :type url: str
        :param user_agent_parameter:
        :type user_agent_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTIIndicator, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphTIIndicator
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTIIndicator"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTIIndicator(id=id, action=action, activity_group_names=activity_group_names, additional_information=additional_information, azure_tenant_id=azure_tenant_id, confidence=confidence, description=description, diamond_model=diamond_model, domain_name=domain_name, email_encoding=email_encoding, email_language=email_language, email_recipient=email_recipient, email_sender_address=email_sender_address, email_sender_name=email_sender_name, email_source_domain=email_source_domain, email_source_ip_address=email_source_ip_address, email_subject=email_subject, email_x_mailer=email_x_mailer, expiration_date_time=expiration_date_time, external_id=external_id, file_compile_date_time=file_compile_date_time, file_created_date_time=file_created_date_time, file_hash_type=file_hash_type, file_hash_value=file_hash_value, file_mutex_name=file_mutex_name, file_name=file_name, file_packer=file_packer, file_path=file_path, file_size=file_size, file_type=file_type, ingested_date_time=ingested_date_time, is_active=is_active, kill_chain=kill_chain, known_false_positives=known_false_positives, last_reported_date_time=last_reported_date_time, malware_family_names=malware_family_names, network_cidr_block=network_cidr_block, network_destination_asn=network_destination_asn, network_destination_cidr_block=network_destination_cidr_block, network_destination_i_pv4=network_destination_i_pv4, network_destination_i_pv6=network_destination_i_pv6, network_destination_port=network_destination_port, network_i_pv4=network_i_pv4, network_i_pv6=network_i_pv6, network_port=network_port, network_protocol=network_protocol, network_source_asn=network_source_asn, network_source_cidr_block=network_source_cidr_block, network_source_i_pv4=network_source_i_pv4, network_source_i_pv6=network_source_i_pv6, network_source_port=network_source_port, passive_only=passive_only, severity=severity, tags=tags, target_product=target_product, threat_type=threat_type, tlp_level=tlp_level, url=url, user_agent=user_agent_parameter)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ti_indicator.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTIIndicator')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTIIndicator', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ti_indicator.metadata = {'url': '/Security/tiIndicators'}  # type: ignore

    async def get_ti_indicator(
        self,
        ti_indicator_id: str,
        select: Optional[List[Union[str, "models.Enum55"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTIIndicator":
        """Get tiIndicators from Security.

        Get tiIndicators from Security.

        :param ti_indicator_id: key: id of tiIndicator.
        :type ti_indicator_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum55]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTIIndicator, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphTIIndicator
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTIIndicator"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_ti_indicator.metadata['url']  # type: ignore
        path_format_arguments = {
            'tiIndicator-id': self._serialize.url("ti_indicator_id", ti_indicator_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTIIndicator', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_ti_indicator.metadata = {'url': '/Security/tiIndicators/{tiIndicator-id}'}  # type: ignore

    async def update_ti_indicator(
        self,
        ti_indicator_id: str,
        id: Optional[str] = None,
        action: Optional[Union[str, "models.MicrosoftGraphTIAction"]] = None,
        activity_group_names: Optional[List[str]] = None,
        additional_information: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        confidence: Optional[int] = None,
        description: Optional[str] = None,
        diamond_model: Optional[Union[str, "models.MicrosoftGraphDiamondModel"]] = None,
        domain_name: Optional[str] = None,
        email_encoding: Optional[str] = None,
        email_language: Optional[str] = None,
        email_recipient: Optional[str] = None,
        email_sender_address: Optional[str] = None,
        email_sender_name: Optional[str] = None,
        email_source_domain: Optional[str] = None,
        email_source_ip_address: Optional[str] = None,
        email_subject: Optional[str] = None,
        email_x_mailer: Optional[str] = None,
        expiration_date_time: Optional[datetime.datetime] = None,
        external_id: Optional[str] = None,
        file_compile_date_time: Optional[datetime.datetime] = None,
        file_created_date_time: Optional[datetime.datetime] = None,
        file_hash_type: Optional[Union[str, "models.MicrosoftGraphFileHashType"]] = None,
        file_hash_value: Optional[str] = None,
        file_mutex_name: Optional[str] = None,
        file_name: Optional[str] = None,
        file_packer: Optional[str] = None,
        file_path: Optional[str] = None,
        file_size: Optional[int] = None,
        file_type: Optional[str] = None,
        ingested_date_time: Optional[datetime.datetime] = None,
        is_active: Optional[bool] = None,
        kill_chain: Optional[List[str]] = None,
        known_false_positives: Optional[str] = None,
        last_reported_date_time: Optional[datetime.datetime] = None,
        malware_family_names: Optional[List[str]] = None,
        network_cidr_block: Optional[str] = None,
        network_destination_asn: Optional[int] = None,
        network_destination_cidr_block: Optional[str] = None,
        network_destination_i_pv4: Optional[str] = None,
        network_destination_i_pv6: Optional[str] = None,
        network_destination_port: Optional[int] = None,
        network_i_pv4: Optional[str] = None,
        network_i_pv6: Optional[str] = None,
        network_port: Optional[int] = None,
        network_protocol: Optional[int] = None,
        network_source_asn: Optional[int] = None,
        network_source_cidr_block: Optional[str] = None,
        network_source_i_pv4: Optional[str] = None,
        network_source_i_pv6: Optional[str] = None,
        network_source_port: Optional[int] = None,
        passive_only: Optional[bool] = None,
        severity: Optional[int] = None,
        tags: Optional[List[str]] = None,
        target_product: Optional[str] = None,
        threat_type: Optional[str] = None,
        tlp_level: Optional[Union[str, "models.MicrosoftGraphTlpLevel"]] = None,
        url: Optional[str] = None,
        user_agent_parameter: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property tiIndicators in Security.

        Update the navigation property tiIndicators in Security.

        :param ti_indicator_id: key: id of tiIndicator.
        :type ti_indicator_id: str
        :param id: Read-only.
        :type id: str
        :param action:
        :type action: str or ~security.models.MicrosoftGraphTIAction
        :param activity_group_names:
        :type activity_group_names: list[str]
        :param additional_information:
        :type additional_information: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param confidence:
        :type confidence: int
        :param description:
        :type description: str
        :param diamond_model:
        :type diamond_model: str or ~security.models.MicrosoftGraphDiamondModel
        :param domain_name:
        :type domain_name: str
        :param email_encoding:
        :type email_encoding: str
        :param email_language:
        :type email_language: str
        :param email_recipient:
        :type email_recipient: str
        :param email_sender_address:
        :type email_sender_address: str
        :param email_sender_name:
        :type email_sender_name: str
        :param email_source_domain:
        :type email_source_domain: str
        :param email_source_ip_address:
        :type email_source_ip_address: str
        :param email_subject:
        :type email_subject: str
        :param email_x_mailer:
        :type email_x_mailer: str
        :param expiration_date_time:
        :type expiration_date_time: ~datetime.datetime
        :param external_id:
        :type external_id: str
        :param file_compile_date_time:
        :type file_compile_date_time: ~datetime.datetime
        :param file_created_date_time:
        :type file_created_date_time: ~datetime.datetime
        :param file_hash_type:
        :type file_hash_type: str or ~security.models.MicrosoftGraphFileHashType
        :param file_hash_value:
        :type file_hash_value: str
        :param file_mutex_name:
        :type file_mutex_name: str
        :param file_name:
        :type file_name: str
        :param file_packer:
        :type file_packer: str
        :param file_path:
        :type file_path: str
        :param file_size:
        :type file_size: long
        :param file_type:
        :type file_type: str
        :param ingested_date_time:
        :type ingested_date_time: ~datetime.datetime
        :param is_active:
        :type is_active: bool
        :param kill_chain:
        :type kill_chain: list[str]
        :param known_false_positives:
        :type known_false_positives: str
        :param last_reported_date_time:
        :type last_reported_date_time: ~datetime.datetime
        :param malware_family_names:
        :type malware_family_names: list[str]
        :param network_cidr_block:
        :type network_cidr_block: str
        :param network_destination_asn:
        :type network_destination_asn: int
        :param network_destination_cidr_block:
        :type network_destination_cidr_block: str
        :param network_destination_i_pv4:
        :type network_destination_i_pv4: str
        :param network_destination_i_pv6:
        :type network_destination_i_pv6: str
        :param network_destination_port:
        :type network_destination_port: int
        :param network_i_pv4:
        :type network_i_pv4: str
        :param network_i_pv6:
        :type network_i_pv6: str
        :param network_port:
        :type network_port: int
        :param network_protocol:
        :type network_protocol: int
        :param network_source_asn:
        :type network_source_asn: int
        :param network_source_cidr_block:
        :type network_source_cidr_block: str
        :param network_source_i_pv4:
        :type network_source_i_pv4: str
        :param network_source_i_pv6:
        :type network_source_i_pv6: str
        :param network_source_port:
        :type network_source_port: int
        :param passive_only:
        :type passive_only: bool
        :param severity:
        :type severity: int
        :param tags:
        :type tags: list[str]
        :param target_product:
        :type target_product: str
        :param threat_type:
        :type threat_type: str
        :param tlp_level:
        :type tlp_level: str or ~security.models.MicrosoftGraphTlpLevel
        :param url:
        :type url: str
        :param user_agent_parameter:
        :type user_agent_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphTIIndicator(id=id, action=action, activity_group_names=activity_group_names, additional_information=additional_information, azure_tenant_id=azure_tenant_id, confidence=confidence, description=description, diamond_model=diamond_model, domain_name=domain_name, email_encoding=email_encoding, email_language=email_language, email_recipient=email_recipient, email_sender_address=email_sender_address, email_sender_name=email_sender_name, email_source_domain=email_source_domain, email_source_ip_address=email_source_ip_address, email_subject=email_subject, email_x_mailer=email_x_mailer, expiration_date_time=expiration_date_time, external_id=external_id, file_compile_date_time=file_compile_date_time, file_created_date_time=file_created_date_time, file_hash_type=file_hash_type, file_hash_value=file_hash_value, file_mutex_name=file_mutex_name, file_name=file_name, file_packer=file_packer, file_path=file_path, file_size=file_size, file_type=file_type, ingested_date_time=ingested_date_time, is_active=is_active, kill_chain=kill_chain, known_false_positives=known_false_positives, last_reported_date_time=last_reported_date_time, malware_family_names=malware_family_names, network_cidr_block=network_cidr_block, network_destination_asn=network_destination_asn, network_destination_cidr_block=network_destination_cidr_block, network_destination_i_pv4=network_destination_i_pv4, network_destination_i_pv6=network_destination_i_pv6, network_destination_port=network_destination_port, network_i_pv4=network_i_pv4, network_i_pv6=network_i_pv6, network_port=network_port, network_protocol=network_protocol, network_source_asn=network_source_asn, network_source_cidr_block=network_source_cidr_block, network_source_i_pv4=network_source_i_pv4, network_source_i_pv6=network_source_i_pv6, network_source_port=network_source_port, passive_only=passive_only, severity=severity, tags=tags, target_product=target_product, threat_type=threat_type, tlp_level=tlp_level, url=url, user_agent=user_agent_parameter)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_ti_indicator.metadata['url']  # type: ignore
        path_format_arguments = {
            'tiIndicator-id': self._serialize.url("ti_indicator_id", ti_indicator_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphTIIndicator')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_ti_indicator.metadata = {'url': '/Security/tiIndicators/{tiIndicator-id}'}  # type: ignore

    async def delete_ti_indicator(
        self,
        ti_indicator_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property tiIndicators for Security.

        Delete navigation property tiIndicators for Security.

        :param ti_indicator_id: key: id of tiIndicator.
        :type ti_indicator_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_ti_indicator.metadata['url']  # type: ignore
        path_format_arguments = {
            'tiIndicator-id': self._serialize.url("ti_indicator_id", ti_indicator_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_ti_indicator.metadata = {'url': '/Security/tiIndicators/{tiIndicator-id}'}  # type: ignore

    def list_user_security_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum56"]]] = None,
        select: Optional[List[Union[str, "models.Enum57"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfUserSecurityProfile"]:
        """Get userSecurityProfiles from Security.

        Get userSecurityProfiles from Security.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~security.models.Enum56]
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum57]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfUserSecurityProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~security.models.CollectionOfUserSecurityProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfUserSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_user_security_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfUserSecurityProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_user_security_profile.metadata = {'url': '/Security/userSecurityProfiles'}  # type: ignore

    async def create_user_security_profile(
        self,
        id: Optional[str] = None,
        accounts: Optional[List["models.MicrosoftGraphUserAccount"]] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_principal_name: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphUserSecurityProfile":
        """Create new navigation property to userSecurityProfiles for Security.

        Create new navigation property to userSecurityProfiles for Security.

        :param id: Read-only.
        :type id: str
        :param accounts:
        :type accounts: list[~security.models.MicrosoftGraphUserAccount]
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param user_principal_name:
        :type user_principal_name: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUserSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphUserSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUserSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphUserSecurityProfile(id=id, accounts=accounts, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, created_date_time=created_date_time, display_name=display_name, last_modified_date_time=last_modified_date_time, risk_score=risk_score, tags=tags, user_principal_name=user_principal_name, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_user_security_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphUserSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUserSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_user_security_profile.metadata = {'url': '/Security/userSecurityProfiles'}  # type: ignore

    async def get_user_security_profile(
        self,
        user_security_profile_id: str,
        select: Optional[List[Union[str, "models.Enum58"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphUserSecurityProfile":
        """Get userSecurityProfiles from Security.

        Get userSecurityProfiles from Security.

        :param user_security_profile_id: key: id of userSecurityProfile.
        :type user_security_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~security.models.Enum58]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUserSecurityProfile, or the result of cls(response)
        :rtype: ~security.models.MicrosoftGraphUserSecurityProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUserSecurityProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'userSecurityProfile-id': self._serialize.url("user_security_profile_id", user_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUserSecurityProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_security_profile.metadata = {'url': '/Security/userSecurityProfiles/{userSecurityProfile-id}'}  # type: ignore

    async def update_user_security_profile(
        self,
        user_security_profile_id: str,
        id: Optional[str] = None,
        accounts: Optional[List["models.MicrosoftGraphUserAccount"]] = None,
        azure_subscription_id: Optional[str] = None,
        azure_tenant_id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        risk_score: Optional[str] = None,
        tags: Optional[List[str]] = None,
        user_principal_name: Optional[str] = None,
        vendor_information: Optional["models.MicrosoftGraphSecurityVendorInformation"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property userSecurityProfiles in Security.

        Update the navigation property userSecurityProfiles in Security.

        :param user_security_profile_id: key: id of userSecurityProfile.
        :type user_security_profile_id: str
        :param id: Read-only.
        :type id: str
        :param accounts:
        :type accounts: list[~security.models.MicrosoftGraphUserAccount]
        :param azure_subscription_id:
        :type azure_subscription_id: str
        :param azure_tenant_id:
        :type azure_tenant_id: str
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param display_name:
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param risk_score:
        :type risk_score: str
        :param tags:
        :type tags: list[str]
        :param user_principal_name:
        :type user_principal_name: str
        :param vendor_information: securityVendorInformation.
        :type vendor_information: ~security.models.MicrosoftGraphSecurityVendorInformation
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphUserSecurityProfile(id=id, accounts=accounts, azure_subscription_id=azure_subscription_id, azure_tenant_id=azure_tenant_id, created_date_time=created_date_time, display_name=display_name, last_modified_date_time=last_modified_date_time, risk_score=risk_score, tags=tags, user_principal_name=user_principal_name, vendor_information=vendor_information)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_user_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'userSecurityProfile-id': self._serialize.url("user_security_profile_id", user_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphUserSecurityProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_user_security_profile.metadata = {'url': '/Security/userSecurityProfiles/{userSecurityProfile-id}'}  # type: ignore

    async def delete_user_security_profile(
        self,
        user_security_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property userSecurityProfiles for Security.

        Delete navigation property userSecurityProfiles for Security.

        :param user_security_profile_id: key: id of userSecurityProfile.
        :type user_security_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_user_security_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'userSecurityProfile-id': self._serialize.url("user_security_profile_id", user_security_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_user_security_profile.metadata = {'url': '/Security/userSecurityProfiles/{userSecurityProfile-id}'}  # type: ignore
