# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddProviderStatus(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProviderStatus, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'enabled':
                d['enabled'] = v[0]
            elif kl == 'endpoint':
                d['endpoint'] = v[0]
            elif kl == 'provider':
                d['provider'] = v[0]
            elif kl == 'region':
                d['region'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_status. All possible keys are: '
                               'enabled, endpoint, provider, region, vendor'.format(k))
        return d


class AddProviderTenantSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProviderTenantSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'enabled':
                d['enabled'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'provider':
                d['provider'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_tenant_settings. All possible '
                               'keys are: azure-tenant-id, enabled, last-modified-date-time, provider, vendor, id'.
                               format(k))
        return d


class AddTiIndicators(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTiIndicators, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'activity-group-names':
                d['activity_group_names'] = v
            elif kl == 'additional-information':
                d['additional_information'] = v[0]
            elif kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'confidence':
                d['confidence'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'diamond-model':
                d['diamond_model'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-encoding':
                d['email_encoding'] = v[0]
            elif kl == 'email-language':
                d['email_language'] = v[0]
            elif kl == 'email-recipient':
                d['email_recipient'] = v[0]
            elif kl == 'email-sender-address':
                d['email_sender_address'] = v[0]
            elif kl == 'email-sender-name':
                d['email_sender_name'] = v[0]
            elif kl == 'email-source-domain':
                d['email_source_domain'] = v[0]
            elif kl == 'email-source-ip-address':
                d['email_source_ip_address'] = v[0]
            elif kl == 'email-subject':
                d['email_subject'] = v[0]
            elif kl == 'email-x-mailer':
                d['email_x_mailer'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'external-id':
                d['external_id'] = v[0]
            elif kl == 'file-compile-date-time':
                d['file_compile_date_time'] = v[0]
            elif kl == 'file-created-date-time':
                d['file_created_date_time'] = v[0]
            elif kl == 'file-hash-type':
                d['file_hash_type'] = v[0]
            elif kl == 'file-hash-value':
                d['file_hash_value'] = v[0]
            elif kl == 'file-mutex-name':
                d['file_mutex_name'] = v[0]
            elif kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'file-packer':
                d['file_packer'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-size':
                d['file_size'] = v[0]
            elif kl == 'file-type':
                d['file_type'] = v[0]
            elif kl == 'ingested-date-time':
                d['ingested_date_time'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'kill-chain':
                d['kill_chain'] = v
            elif kl == 'known-false-positives':
                d['known_false_positives'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'malware-family-names':
                d['malware_family_names'] = v
            elif kl == 'network-cidr-block':
                d['network_cidr_block'] = v[0]
            elif kl == 'network-destination-asn':
                d['network_destination_asn'] = v[0]
            elif kl == 'network-destination-cidr-block':
                d['network_destination_cidr_block'] = v[0]
            elif kl == 'network-destination-i-pv4':
                d['network_destination_i_pv4'] = v[0]
            elif kl == 'network-destination-i-pv6':
                d['network_destination_i_pv6'] = v[0]
            elif kl == 'network-destination-port':
                d['network_destination_port'] = v[0]
            elif kl == 'network-i-pv4':
                d['network_i_pv4'] = v[0]
            elif kl == 'network-i-pv6':
                d['network_i_pv6'] = v[0]
            elif kl == 'network-port':
                d['network_port'] = v[0]
            elif kl == 'network-protocol':
                d['network_protocol'] = v[0]
            elif kl == 'network-source-asn':
                d['network_source_asn'] = v[0]
            elif kl == 'network-source-cidr-block':
                d['network_source_cidr_block'] = v[0]
            elif kl == 'network-source-i-pv4':
                d['network_source_i_pv4'] = v[0]
            elif kl == 'network-source-i-pv6':
                d['network_source_i_pv6'] = v[0]
            elif kl == 'network-source-port':
                d['network_source_port'] = v[0]
            elif kl == 'passive-only':
                d['passive_only'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'tags':
                d['tags'] = v
            elif kl == 'target-product':
                d['target_product'] = v[0]
            elif kl == 'threat-type':
                d['threat_type'] = v[0]
            elif kl == 'tlp-level':
                d['tlp_level'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'user-agent':
                d['user_agent'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter ti_indicators. All possible keys are: '
                               'action, activity-group-names, additional-information, azure-tenant-id, confidence, '
                               'description, diamond-model, domain-name, email-encoding, email-language, '
                               'email-recipient, email-sender-address, email-sender-name, email-source-domain, '
                               'email-source-ip-address, email-subject, email-x-mailer, expiration-date-time, '
                               'external-id, file-compile-date-time, file-created-date-time, file-hash-type, '
                               'file-hash-value, file-mutex-name, file-name, file-packer, file-path, file-size, '
                               'file-type, ingested-date-time, is-active, kill-chain, known-false-positives, '
                               'last-reported-date-time, malware-family-names, network-cidr-block, '
                               'network-destination-asn, network-destination-cidr-block, network-destination-i-pv4, '
                               'network-destination-i-pv6, network-destination-port, network-i-pv4, network-i-pv6, '
                               'network-port, network-protocol, network-source-asn, network-source-cidr-block, '
                               'network-source-i-pv4, network-source-i-pv6, network-source-port, passive-only, '
                               'severity, tags, target-product, threat-type, tlp-level, url, user-agent, id'.format(k))
        return d


class AddErrorInfo(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.error_info = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'code':
                d['code'] = v[0]
            elif kl == 'message':
                d['message'] = v[0]
            elif kl == 'subcode':
                d['subcode'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter error_info. All possible keys are: code, '
                               'message, subcode'.format(k))
        return d


class AddParameters(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddParameters, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter parameters. All possible keys are: name, '
                               'value'.format(k))
        return d


class AddStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-id':
                d['app_id'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'updated-date-time':
                d['updated_date_time'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter states. All possible keys are: app-id, '
                               'status, updated-date-time, user'.format(k))
        return d


class AddVendorInformation(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.vendor_information = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'provider':
                d['provider'] = v[0]
            elif kl == 'provider-version':
                d['provider_version'] = v[0]
            elif kl == 'sub-provider':
                d['sub_provider'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vendor_information. All possible keys '
                               'are: provider, provider-version, sub-provider, vendor'.format(k))
        return d


class AddCloudAppStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCloudAppStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'destination-service-ip':
                d['destination_service_ip'] = v[0]
            elif kl == 'destination-service-name':
                d['destination_service_name'] = v[0]
            elif kl == 'risk-score':
                d['risk_score'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter cloud_app_states. All possible keys are: '
                               'destination-service-ip, destination-service-name, risk-score'.format(k))
        return d


class AddHistoryStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddHistoryStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-id':
                d['app_id'] = v[0]
            elif kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'comments':
                d['comments'] = v
            elif kl == 'feedback':
                d['feedback'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'updated-date-time':
                d['updated_date_time'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter history_states. All possible keys are: '
                               'app-id, assigned-to, comments, feedback, status, updated-date-time, user'.format(k))
        return d


class AddHostStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddHostStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'fqdn':
                d['fqdn'] = v[0]
            elif kl == 'is-azure-ad-joined':
                d['is_azure_ad_joined'] = v[0]
            elif kl == 'is-azure-ad-registered':
                d['is_azure_ad_registered'] = v[0]
            elif kl == 'is-hybrid-azure-domain-joined':
                d['is_hybrid_azure_domain_joined'] = v[0]
            elif kl == 'net-bios-name':
                d['net_bios_name'] = v[0]
            elif kl == 'os':
                d['os'] = v[0]
            elif kl == 'private-ip-address':
                d['private_ip_address'] = v[0]
            elif kl == 'public-ip-address':
                d['public_ip_address'] = v[0]
            elif kl == 'risk-score':
                d['risk_score'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter host_states. All possible keys are: fqdn, '
                               'is-azure-ad-joined, is-azure-ad-registered, is-hybrid-azure-domain-joined, '
                               'net-bios-name, os, private-ip-address, public-ip-address, risk-score'.format(k))
        return d


class AddSecuritySecurityCreateAlertMalwareStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecurityCreateAlertMalwareStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'category':
                d['category'] = v[0]
            elif kl == 'family':
                d['family'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'was-running':
                d['was_running'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter malware_states. All possible keys are: '
                               'category, family, name, severity, was-running'.format(k))
        return d


class AddNetworkConnections(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNetworkConnections, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'application-name':
                d['application_name'] = v[0]
            elif kl == 'destination-address':
                d['destination_address'] = v[0]
            elif kl == 'destination-domain':
                d['destination_domain'] = v[0]
            elif kl == 'destination-location':
                d['destination_location'] = v[0]
            elif kl == 'destination-port':
                d['destination_port'] = v[0]
            elif kl == 'destination-url':
                d['destination_url'] = v[0]
            elif kl == 'direction':
                d['direction'] = v[0]
            elif kl == 'domain-registered-date-time':
                d['domain_registered_date_time'] = v[0]
            elif kl == 'local-dns-name':
                d['local_dns_name'] = v[0]
            elif kl == 'nat-destination-address':
                d['nat_destination_address'] = v[0]
            elif kl == 'nat-destination-port':
                d['nat_destination_port'] = v[0]
            elif kl == 'nat-source-address':
                d['nat_source_address'] = v[0]
            elif kl == 'nat-source-port':
                d['nat_source_port'] = v[0]
            elif kl == 'protocol':
                d['protocol'] = v[0]
            elif kl == 'risk-score':
                d['risk_score'] = v[0]
            elif kl == 'source-address':
                d['source_address'] = v[0]
            elif kl == 'source-location':
                d['source_location'] = v[0]
            elif kl == 'source-port':
                d['source_port'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'url-parameters':
                d['url_parameters'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter network_connections. All possible keys '
                               'are: application-name, destination-address, destination-domain, destination-location, '
                               'destination-port, destination-url, direction, domain-registered-date-time, '
                               'local-dns-name, nat-destination-address, nat-destination-port, nat-source-address, '
                               'nat-source-port, protocol, risk-score, source-address, source-location, source-port, '
                               'status, url-parameters'.format(k))
        return d


class AddRegistryKeyStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddRegistryKeyStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'hive':
                d['hive'] = v[0]
            elif kl == 'key':
                d['key'] = v[0]
            elif kl == 'old-key':
                d['old_key'] = v[0]
            elif kl == 'old-value-data':
                d['old_value_data'] = v[0]
            elif kl == 'old-value-name':
                d['old_value_name'] = v[0]
            elif kl == 'operation':
                d['operation'] = v[0]
            elif kl == 'process-id':
                d['process_id'] = v[0]
            elif kl == 'value-data':
                d['value_data'] = v[0]
            elif kl == 'value-name':
                d['value_name'] = v[0]
            elif kl == 'value-type':
                d['value_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter registry_key_states. All possible keys '
                               'are: hive, key, old-key, old-value-data, old-value-name, operation, process-id, '
                               'value-data, value-name, value-type'.format(k))
        return d


class AddSecurityResources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecurityResources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'resource':
                d['resource'] = v[0]
            elif kl == 'resource-type':
                d['resource_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter security_resources. All possible keys '
                               'are: resource, resource-type'.format(k))
        return d


class AddTriggers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTriggers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter triggers. All possible keys are: name, '
                               'type, value'.format(k))
        return d


class AddUserStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'aad-user-id':
                d['aad_user_id'] = v[0]
            elif kl == 'account-name':
                d['account_name'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-role':
                d['email_role'] = v[0]
            elif kl == 'is-vpn':
                d['is_vpn'] = v[0]
            elif kl == 'logon-date-time':
                d['logon_date_time'] = v[0]
            elif kl == 'logon-id':
                d['logon_id'] = v[0]
            elif kl == 'logon-ip':
                d['logon_ip'] = v[0]
            elif kl == 'logon-location':
                d['logon_location'] = v[0]
            elif kl == 'logon-type':
                d['logon_type'] = v[0]
            elif kl == 'on-premises-security-identifier':
                d['on_premises_security_identifier'] = v[0]
            elif kl == 'risk-score':
                d['risk_score'] = v[0]
            elif kl == 'user-account-type':
                d['user_account_type'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user_states. All possible keys are: '
                               'aad-user-id, account-name, domain-name, email-role, is-vpn, logon-date-time, logon-id, '
                               'logon-ip, logon-location, logon-type, on-premises-security-identifier, risk-score, '
                               'user-account-type, user-principal-name'.format(k))
        return d


class AddSecuritySecurityCreateAlertVulnerabilityStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecurityCreateAlertVulnerabilityStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'cve':
                d['cve'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'was-running':
                d['was_running'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vulnerability_states. All possible keys '
                               'are: cve, severity, was-running'.format(k))
        return d


class AddDomainCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDomainCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter domain_categories. All possible keys are: '
                               'description, name, vendor'.format(k))
        return d


class AddRegistrant(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.registrant = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'country-or-region-code':
                d['country_or_region_code'] = v[0]
            elif kl == 'organization':
                d['organization'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter registrant. All possible keys are: '
                               'country-or-region-code, organization, url, vendor'.format(k))
        return d


class AddHashes(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddHashes, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'hash-type':
                d['hash_type'] = v[0]
            elif kl == 'hash-value':
                d['hash_value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter hashes. All possible keys are: hash-type, '
                               'hash-value'.format(k))
        return d


class AddSecuritySecurityCreateFileSecurityProfileMalwareStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecurityCreateFileSecurityProfileMalwareStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'category':
                d['category'] = v[0]
            elif kl == 'family':
                d['family'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'was-running':
                d['was_running'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter malware_states. All possible keys are: '
                               'category, family, name, severity, was-running'.format(k))
        return d


class AddSecuritySecurityCreateFileSecurityProfileVulnerabilityStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecurityCreateFileSecurityProfileVulnerabilityStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'cve':
                d['cve'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'was-running':
                d['was_running'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vulnerability_states. All possible keys '
                               'are: cve, severity, was-running'.format(k))
        return d


class AddLogonUsers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddLogonUsers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'account-domain':
                d['account_domain'] = v[0]
            elif kl == 'account-name':
                d['account_name'] = v[0]
            elif kl == 'account-type':
                d['account_type'] = v[0]
            elif kl == 'first-seen-date-time':
                d['first_seen_date_time'] = v[0]
            elif kl == 'last-seen-date-time':
                d['last_seen_date_time'] = v[0]
            elif kl == 'logon-id':
                d['logon_id'] = v[0]
            elif kl == 'logon-types':
                d['logon_types'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter logon_users. All possible keys are: '
                               'account-domain, account-name, account-type, first-seen-date-time, last-seen-date-time, '
                               'logon-id, logon-types'.format(k))
        return d


class AddNetworkInterfaces(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNetworkInterfaces, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'ip-v4-address':
                d['ip_v4_address'] = v[0]
            elif kl == 'ip-v6-address':
                d['ip_v6_address'] = v[0]
            elif kl == 'local-ip-v6-address':
                d['local_ip_v6_address'] = v[0]
            elif kl == 'mac-address':
                d['mac_address'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter network_interfaces. All possible keys '
                               'are: description, ip-v4-address, ip-v6-address, local-ip-v6-address, mac-address'.
                               format(k))
        return d


class AddIpCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIpCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter ip_categories. All possible keys are: '
                               'description, name, vendor'.format(k))
        return d


class AddIpReferenceData(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIpReferenceData, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'asn':
                d['asn'] = v[0]
            elif kl == 'city':
                d['city'] = v[0]
            elif kl == 'country-or-region-code':
                d['country_or_region_code'] = v[0]
            elif kl == 'organization':
                d['organization'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter ip_reference_data. All possible keys are: '
                               'asn, city, country-or-region-code, organization, state, vendor'.format(k))
        return d


class AddAverageComparativeScores(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAverageComparativeScores, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'average-score':
                d['average_score'] = v[0]
            elif kl == 'basis':
                d['basis'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter average_comparative_scores. All possible '
                               'keys are: average-score, basis'.format(k))
        return d


class AddControlScores(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddControlScores, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'control-category':
                d['control_category'] = v[0]
            elif kl == 'control-name':
                d['control_name'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'score':
                d['score'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter control_scores. All possible keys are: '
                               'control-category, control-name, description, score'.format(k))
        return d


class AddComplianceInformation(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddComplianceInformation, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'certification-controls':
                d['certification_controls'] = v
            elif kl == 'certification-name':
                d['certification_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter compliance_information. All possible keys '
                               'are: certification-controls, certification-name'.format(k))
        return d


class AddControlStateUpdates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddControlStateUpdates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'comment':
                d['comment'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'updated-by':
                d['updated_by'] = v[0]
            elif kl == 'updated-date-time':
                d['updated_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter control_state_updates. All possible keys '
                               'are: assigned-to, comment, state, updated-by, updated-date-time'.format(k))
        return d


class AddAccounts(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAccounts, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-seen-date-time':
                d['last_seen_date_time'] = v[0]
            elif kl == 'risk-score':
                d['risk_score'] = v[0]
            elif kl == 'service':
                d['service'] = v[0]
            elif kl == 'signin-name':
                d['signin_name'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter accounts. All possible keys are: '
                               'display-name, last-seen-date-time, risk-score, service, signin-name, status'.format(k))
        return d


class AddSecuritySecurityTiIndicatorSubmitTiIndicatorValue(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecurityTiIndicatorSubmitTiIndicatorValue, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'activity-group-names':
                d['activity_group_names'] = v
            elif kl == 'additional-information':
                d['additional_information'] = v[0]
            elif kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'confidence':
                d['confidence'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'diamond-model':
                d['diamond_model'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-encoding':
                d['email_encoding'] = v[0]
            elif kl == 'email-language':
                d['email_language'] = v[0]
            elif kl == 'email-recipient':
                d['email_recipient'] = v[0]
            elif kl == 'email-sender-address':
                d['email_sender_address'] = v[0]
            elif kl == 'email-sender-name':
                d['email_sender_name'] = v[0]
            elif kl == 'email-source-domain':
                d['email_source_domain'] = v[0]
            elif kl == 'email-source-ip-address':
                d['email_source_ip_address'] = v[0]
            elif kl == 'email-subject':
                d['email_subject'] = v[0]
            elif kl == 'email-x-mailer':
                d['email_x_mailer'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'external-id':
                d['external_id'] = v[0]
            elif kl == 'file-compile-date-time':
                d['file_compile_date_time'] = v[0]
            elif kl == 'file-created-date-time':
                d['file_created_date_time'] = v[0]
            elif kl == 'file-hash-type':
                d['file_hash_type'] = v[0]
            elif kl == 'file-hash-value':
                d['file_hash_value'] = v[0]
            elif kl == 'file-mutex-name':
                d['file_mutex_name'] = v[0]
            elif kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'file-packer':
                d['file_packer'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-size':
                d['file_size'] = v[0]
            elif kl == 'file-type':
                d['file_type'] = v[0]
            elif kl == 'ingested-date-time':
                d['ingested_date_time'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'kill-chain':
                d['kill_chain'] = v
            elif kl == 'known-false-positives':
                d['known_false_positives'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'malware-family-names':
                d['malware_family_names'] = v
            elif kl == 'network-cidr-block':
                d['network_cidr_block'] = v[0]
            elif kl == 'network-destination-asn':
                d['network_destination_asn'] = v[0]
            elif kl == 'network-destination-cidr-block':
                d['network_destination_cidr_block'] = v[0]
            elif kl == 'network-destination-i-pv4':
                d['network_destination_i_pv4'] = v[0]
            elif kl == 'network-destination-i-pv6':
                d['network_destination_i_pv6'] = v[0]
            elif kl == 'network-destination-port':
                d['network_destination_port'] = v[0]
            elif kl == 'network-i-pv4':
                d['network_i_pv4'] = v[0]
            elif kl == 'network-i-pv6':
                d['network_i_pv6'] = v[0]
            elif kl == 'network-port':
                d['network_port'] = v[0]
            elif kl == 'network-protocol':
                d['network_protocol'] = v[0]
            elif kl == 'network-source-asn':
                d['network_source_asn'] = v[0]
            elif kl == 'network-source-cidr-block':
                d['network_source_cidr_block'] = v[0]
            elif kl == 'network-source-i-pv4':
                d['network_source_i_pv4'] = v[0]
            elif kl == 'network-source-i-pv6':
                d['network_source_i_pv6'] = v[0]
            elif kl == 'network-source-port':
                d['network_source_port'] = v[0]
            elif kl == 'passive-only':
                d['passive_only'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'tags':
                d['tags'] = v
            elif kl == 'target-product':
                d['target_product'] = v[0]
            elif kl == 'threat-type':
                d['threat_type'] = v[0]
            elif kl == 'tlp-level':
                d['tlp_level'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'user-agent':
                d['user_agent'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter value. All possible keys are: action, '
                               'activity-group-names, additional-information, azure-tenant-id, confidence, '
                               'description, diamond-model, domain-name, email-encoding, email-language, '
                               'email-recipient, email-sender-address, email-sender-name, email-source-domain, '
                               'email-source-ip-address, email-subject, email-x-mailer, expiration-date-time, '
                               'external-id, file-compile-date-time, file-created-date-time, file-hash-type, '
                               'file-hash-value, file-mutex-name, file-name, file-packer, file-path, file-size, '
                               'file-type, ingested-date-time, is-active, kill-chain, known-false-positives, '
                               'last-reported-date-time, malware-family-names, network-cidr-block, '
                               'network-destination-asn, network-destination-cidr-block, network-destination-i-pv4, '
                               'network-destination-i-pv6, network-destination-port, network-i-pv4, network-i-pv6, '
                               'network-port, network-protocol, network-source-asn, network-source-cidr-block, '
                               'network-source-i-pv4, network-source-i-pv6, network-source-port, passive-only, '
                               'severity, tags, target-product, threat-type, tlp-level, url, user-agent, id'.format(k))
        return d


class AddSecuritySecurityTiIndicatorUpdateTiIndicatorValue(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecurityTiIndicatorUpdateTiIndicatorValue, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'activity-group-names':
                d['activity_group_names'] = v
            elif kl == 'additional-information':
                d['additional_information'] = v[0]
            elif kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'confidence':
                d['confidence'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'diamond-model':
                d['diamond_model'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-encoding':
                d['email_encoding'] = v[0]
            elif kl == 'email-language':
                d['email_language'] = v[0]
            elif kl == 'email-recipient':
                d['email_recipient'] = v[0]
            elif kl == 'email-sender-address':
                d['email_sender_address'] = v[0]
            elif kl == 'email-sender-name':
                d['email_sender_name'] = v[0]
            elif kl == 'email-source-domain':
                d['email_source_domain'] = v[0]
            elif kl == 'email-source-ip-address':
                d['email_source_ip_address'] = v[0]
            elif kl == 'email-subject':
                d['email_subject'] = v[0]
            elif kl == 'email-x-mailer':
                d['email_x_mailer'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'external-id':
                d['external_id'] = v[0]
            elif kl == 'file-compile-date-time':
                d['file_compile_date_time'] = v[0]
            elif kl == 'file-created-date-time':
                d['file_created_date_time'] = v[0]
            elif kl == 'file-hash-type':
                d['file_hash_type'] = v[0]
            elif kl == 'file-hash-value':
                d['file_hash_value'] = v[0]
            elif kl == 'file-mutex-name':
                d['file_mutex_name'] = v[0]
            elif kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'file-packer':
                d['file_packer'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-size':
                d['file_size'] = v[0]
            elif kl == 'file-type':
                d['file_type'] = v[0]
            elif kl == 'ingested-date-time':
                d['ingested_date_time'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'kill-chain':
                d['kill_chain'] = v
            elif kl == 'known-false-positives':
                d['known_false_positives'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'malware-family-names':
                d['malware_family_names'] = v
            elif kl == 'network-cidr-block':
                d['network_cidr_block'] = v[0]
            elif kl == 'network-destination-asn':
                d['network_destination_asn'] = v[0]
            elif kl == 'network-destination-cidr-block':
                d['network_destination_cidr_block'] = v[0]
            elif kl == 'network-destination-i-pv4':
                d['network_destination_i_pv4'] = v[0]
            elif kl == 'network-destination-i-pv6':
                d['network_destination_i_pv6'] = v[0]
            elif kl == 'network-destination-port':
                d['network_destination_port'] = v[0]
            elif kl == 'network-i-pv4':
                d['network_i_pv4'] = v[0]
            elif kl == 'network-i-pv6':
                d['network_i_pv6'] = v[0]
            elif kl == 'network-port':
                d['network_port'] = v[0]
            elif kl == 'network-protocol':
                d['network_protocol'] = v[0]
            elif kl == 'network-source-asn':
                d['network_source_asn'] = v[0]
            elif kl == 'network-source-cidr-block':
                d['network_source_cidr_block'] = v[0]
            elif kl == 'network-source-i-pv4':
                d['network_source_i_pv4'] = v[0]
            elif kl == 'network-source-i-pv6':
                d['network_source_i_pv6'] = v[0]
            elif kl == 'network-source-port':
                d['network_source_port'] = v[0]
            elif kl == 'passive-only':
                d['passive_only'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'tags':
                d['tags'] = v
            elif kl == 'target-product':
                d['target_product'] = v[0]
            elif kl == 'threat-type':
                d['threat_type'] = v[0]
            elif kl == 'tlp-level':
                d['tlp_level'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'user-agent':
                d['user_agent'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter value. All possible keys are: action, '
                               'activity-group-names, additional-information, azure-tenant-id, confidence, '
                               'description, diamond-model, domain-name, email-encoding, email-language, '
                               'email-recipient, email-sender-address, email-sender-name, email-source-domain, '
                               'email-source-ip-address, email-subject, email-x-mailer, expiration-date-time, '
                               'external-id, file-compile-date-time, file-created-date-time, file-hash-type, '
                               'file-hash-value, file-mutex-name, file-name, file-packer, file-path, file-size, '
                               'file-type, ingested-date-time, is-active, kill-chain, known-false-positives, '
                               'last-reported-date-time, malware-family-names, network-cidr-block, '
                               'network-destination-asn, network-destination-cidr-block, network-destination-i-pv4, '
                               'network-destination-i-pv6, network-destination-port, network-i-pv4, network-i-pv6, '
                               'network-port, network-protocol, network-source-asn, network-source-cidr-block, '
                               'network-source-i-pv4, network-source-i-pv6, network-source-port, passive-only, '
                               'severity, tags, target-product, threat-type, tlp-level, url, user-agent, id'.format(k))
        return d
