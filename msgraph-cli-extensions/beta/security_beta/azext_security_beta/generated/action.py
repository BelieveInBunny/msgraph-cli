# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddProviderStatus(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProviderStatus, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'enabled':
                d['enabled'] = v[0]
            elif kl == 'endpoint':
                d['endpoint'] = v[0]
            elif kl == 'provider':
                d['provider'] = v[0]
            elif kl == 'region':
                d['region'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_status. All possible keys are: '
                               'enabled, endpoint, provider, region, vendor'.format(k))
        return d


class AddProviderTenantSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProviderTenantSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'enabled':
                d['enabled'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'provider':
                d['provider'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter provider_tenant_settings. All possible '
                               'keys are: azure-tenant-id, enabled, last-modified-date-time, provider, vendor, id'.
                               format(k))
        return d


class AddTiIndicators(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTiIndicators, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'activity-group-names':
                d['activity_group_names'] = v
            elif kl == 'additional-information':
                d['additional_information'] = v[0]
            elif kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'confidence':
                d['confidence'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'diamond-model':
                d['diamond_model'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-encoding':
                d['email_encoding'] = v[0]
            elif kl == 'email-language':
                d['email_language'] = v[0]
            elif kl == 'email-recipient':
                d['email_recipient'] = v[0]
            elif kl == 'email-sender-address':
                d['email_sender_address'] = v[0]
            elif kl == 'email-sender-name':
                d['email_sender_name'] = v[0]
            elif kl == 'email-source-domain':
                d['email_source_domain'] = v[0]
            elif kl == 'email-source-ip-address':
                d['email_source_ip_address'] = v[0]
            elif kl == 'email-subject':
                d['email_subject'] = v[0]
            elif kl == 'email-x-mailer':
                d['email_x_mailer'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'external-id':
                d['external_id'] = v[0]
            elif kl == 'file-compile-date-time':
                d['file_compile_date_time'] = v[0]
            elif kl == 'file-created-date-time':
                d['file_created_date_time'] = v[0]
            elif kl == 'file-hash-type':
                d['file_hash_type'] = v[0]
            elif kl == 'file-hash-value':
                d['file_hash_value'] = v[0]
            elif kl == 'file-mutex-name':
                d['file_mutex_name'] = v[0]
            elif kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'file-packer':
                d['file_packer'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-size':
                d['file_size'] = v[0]
            elif kl == 'file-type':
                d['file_type'] = v[0]
            elif kl == 'ingested-date-time':
                d['ingested_date_time'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'kill-chain':
                d['kill_chain'] = v
            elif kl == 'known-false-positives':
                d['known_false_positives'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'malware-family-names':
                d['malware_family_names'] = v
            elif kl == 'network-cidr-block':
                d['network_cidr_block'] = v[0]
            elif kl == 'network-destination-asn':
                d['network_destination_asn'] = v[0]
            elif kl == 'network-destination-cidr-block':
                d['network_destination_cidr_block'] = v[0]
            elif kl == 'network-destination-i-pv4':
                d['network_destination_i_pv4'] = v[0]
            elif kl == 'network-destination-i-pv6':
                d['network_destination_i_pv6'] = v[0]
            elif kl == 'network-destination-port':
                d['network_destination_port'] = v[0]
            elif kl == 'network-i-pv4':
                d['network_i_pv4'] = v[0]
            elif kl == 'network-i-pv6':
                d['network_i_pv6'] = v[0]
            elif kl == 'network-port':
                d['network_port'] = v[0]
            elif kl == 'network-protocol':
                d['network_protocol'] = v[0]
            elif kl == 'network-source-asn':
                d['network_source_asn'] = v[0]
            elif kl == 'network-source-cidr-block':
                d['network_source_cidr_block'] = v[0]
            elif kl == 'network-source-i-pv4':
                d['network_source_i_pv4'] = v[0]
            elif kl == 'network-source-i-pv6':
                d['network_source_i_pv6'] = v[0]
            elif kl == 'network-source-port':
                d['network_source_port'] = v[0]
            elif kl == 'passive-only':
                d['passive_only'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'tags':
                d['tags'] = v
            elif kl == 'target-product':
                d['target_product'] = v[0]
            elif kl == 'threat-type':
                d['threat_type'] = v[0]
            elif kl == 'tlp-level':
                d['tlp_level'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'user-agent':
                d['user_agent'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter ti_indicators. All possible keys are: '
                               'action, activity-group-names, additional-information, azure-tenant-id, confidence, '
                               'description, diamond-model, domain-name, email-encoding, email-language, '
                               'email-recipient, email-sender-address, email-sender-name, email-source-domain, '
                               'email-source-ip-address, email-subject, email-x-mailer, expiration-date-time, '
                               'external-id, file-compile-date-time, file-created-date-time, file-hash-type, '
                               'file-hash-value, file-mutex-name, file-name, file-packer, file-path, file-size, '
                               'file-type, ingested-date-time, is-active, kill-chain, known-false-positives, '
                               'last-reported-date-time, malware-family-names, network-cidr-block, '
                               'network-destination-asn, network-destination-cidr-block, network-destination-i-pv4, '
                               'network-destination-i-pv6, network-destination-port, network-i-pv4, network-i-pv6, '
                               'network-port, network-protocol, network-source-asn, network-source-cidr-block, '
                               'network-source-i-pv4, network-source-i-pv6, network-source-port, passive-only, '
                               'severity, tags, target-product, threat-type, tlp-level, url, user-agent, id'.format(k))
        return d


class AddVendorInformation(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.vendor_information = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'provider':
                d['provider'] = v[0]
            elif kl == 'provider-version':
                d['provider_version'] = v[0]
            elif kl == 'sub-provider':
                d['sub_provider'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vendor_information. All possible keys '
                               'are: provider, provider-version, sub-provider, vendor'.format(k))
        return d


class AddDomainCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDomainCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter domain_categories. All possible keys are: '
                               'description, name, vendor'.format(k))
        return d


class AddRegistrant(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.registrant = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'country-or-region-code':
                d['country_or_region_code'] = v[0]
            elif kl == 'organization':
                d['organization'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter registrant. All possible keys are: '
                               'country-or-region-code, organization, url, vendor'.format(k))
        return d


class AddHashes(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddHashes, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'hash-type':
                d['hash_type'] = v[0]
            elif kl == 'hash-value':
                d['hash_value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter hashes. All possible keys are: hash-type, '
                               'hash-value'.format(k))
        return d


class AddMalwareStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMalwareStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'category':
                d['category'] = v[0]
            elif kl == 'family':
                d['family'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'was-running':
                d['was_running'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter malware_states. All possible keys are: '
                               'category, family, name, severity, was-running'.format(k))
        return d


class AddVulnerabilityStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddVulnerabilityStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'cve':
                d['cve'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'was-running':
                d['was_running'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vulnerability_states. All possible keys '
                               'are: cve, severity, was-running'.format(k))
        return d


class AddLogonUsers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddLogonUsers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'account-domain':
                d['account_domain'] = v[0]
            elif kl == 'account-name':
                d['account_name'] = v[0]
            elif kl == 'account-type':
                d['account_type'] = v[0]
            elif kl == 'first-seen-date-time':
                d['first_seen_date_time'] = v[0]
            elif kl == 'last-seen-date-time':
                d['last_seen_date_time'] = v[0]
            elif kl == 'logon-id':
                d['logon_id'] = v[0]
            elif kl == 'logon-types':
                d['logon_types'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter logon_users. All possible keys are: '
                               'account-domain, account-name, account-type, first-seen-date-time, last-seen-date-time, '
                               'logon-id, logon-types'.format(k))
        return d


class AddNetworkInterfaces(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNetworkInterfaces, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'ip-v4-address':
                d['ip_v4_address'] = v[0]
            elif kl == 'ip-v6-address':
                d['ip_v6_address'] = v[0]
            elif kl == 'local-ip-v6-address':
                d['local_ip_v6_address'] = v[0]
            elif kl == 'mac-address':
                d['mac_address'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter network_interfaces. All possible keys '
                               'are: description, ip-v4-address, ip-v6-address, local-ip-v6-address, mac-address'.
                               format(k))
        return d


class AddIpCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIpCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter ip_categories. All possible keys are: '
                               'description, name, vendor'.format(k))
        return d


class AddIpReferenceData(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIpReferenceData, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'asn':
                d['asn'] = v[0]
            elif kl == 'city':
                d['city'] = v[0]
            elif kl == 'country-or-region-code':
                d['country_or_region_code'] = v[0]
            elif kl == 'organization':
                d['organization'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'vendor':
                d['vendor'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter ip_reference_data. All possible keys are: '
                               'asn, city, country-or-region-code, organization, state, vendor'.format(k))
        return d


class AddAverageComparativeScores(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAverageComparativeScores, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'average-score':
                d['average_score'] = v[0]
            elif kl == 'basis':
                d['basis'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter average_comparative_scores. All possible '
                               'keys are: average-score, basis'.format(k))
        return d


class AddControlScores(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddControlScores, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'control-category':
                d['control_category'] = v[0]
            elif kl == 'control-name':
                d['control_name'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'score':
                d['score'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter control_scores. All possible keys are: '
                               'control-category, control-name, description, score'.format(k))
        return d


class AddControlStateUpdates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddControlStateUpdates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'comment':
                d['comment'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'updated-by':
                d['updated_by'] = v[0]
            elif kl == 'updated-date-time':
                d['updated_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter control_state_updates. All possible keys '
                               'are: assigned-to, comment, state, updated-by, updated-date-time'.format(k))
        return d


class AddErrorInfo(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.error_info = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'code':
                d['code'] = v[0]
            elif kl == 'message':
                d['message'] = v[0]
            elif kl == 'subcode':
                d['subcode'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter error_info. All possible keys are: code, '
                               'message, subcode'.format(k))
        return d


class AddParameters(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddParameters, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter parameters. All possible keys are: name, '
                               'value'.format(k))
        return d


class AddStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-id':
                d['app_id'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'updated-date-time':
                d['updated_date_time'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter states. All possible keys are: app-id, '
                               'status, updated-date-time, user'.format(k))
        return d


class AddAccounts(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAccounts, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-seen-date-time':
                d['last_seen_date_time'] = v[0]
            elif kl == 'risk-score':
                d['risk_score'] = v[0]
            elif kl == 'service':
                d['service'] = v[0]
            elif kl == 'signin-name':
                d['signin_name'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter accounts. All possible keys are: '
                               'display-name, last-seen-date-time, risk-score, service, signin-name, status'.format(k))
        return d


class AddSecuritySecuritytiindicatorSubmitTiIndicatorValue(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecuritytiindicatorSubmitTiIndicatorValue, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'activity-group-names':
                d['activity_group_names'] = v
            elif kl == 'additional-information':
                d['additional_information'] = v[0]
            elif kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'confidence':
                d['confidence'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'diamond-model':
                d['diamond_model'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-encoding':
                d['email_encoding'] = v[0]
            elif kl == 'email-language':
                d['email_language'] = v[0]
            elif kl == 'email-recipient':
                d['email_recipient'] = v[0]
            elif kl == 'email-sender-address':
                d['email_sender_address'] = v[0]
            elif kl == 'email-sender-name':
                d['email_sender_name'] = v[0]
            elif kl == 'email-source-domain':
                d['email_source_domain'] = v[0]
            elif kl == 'email-source-ip-address':
                d['email_source_ip_address'] = v[0]
            elif kl == 'email-subject':
                d['email_subject'] = v[0]
            elif kl == 'email-x-mailer':
                d['email_x_mailer'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'external-id':
                d['external_id'] = v[0]
            elif kl == 'file-compile-date-time':
                d['file_compile_date_time'] = v[0]
            elif kl == 'file-created-date-time':
                d['file_created_date_time'] = v[0]
            elif kl == 'file-hash-type':
                d['file_hash_type'] = v[0]
            elif kl == 'file-hash-value':
                d['file_hash_value'] = v[0]
            elif kl == 'file-mutex-name':
                d['file_mutex_name'] = v[0]
            elif kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'file-packer':
                d['file_packer'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-size':
                d['file_size'] = v[0]
            elif kl == 'file-type':
                d['file_type'] = v[0]
            elif kl == 'ingested-date-time':
                d['ingested_date_time'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'kill-chain':
                d['kill_chain'] = v
            elif kl == 'known-false-positives':
                d['known_false_positives'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'malware-family-names':
                d['malware_family_names'] = v
            elif kl == 'network-cidr-block':
                d['network_cidr_block'] = v[0]
            elif kl == 'network-destination-asn':
                d['network_destination_asn'] = v[0]
            elif kl == 'network-destination-cidr-block':
                d['network_destination_cidr_block'] = v[0]
            elif kl == 'network-destination-i-pv4':
                d['network_destination_i_pv4'] = v[0]
            elif kl == 'network-destination-i-pv6':
                d['network_destination_i_pv6'] = v[0]
            elif kl == 'network-destination-port':
                d['network_destination_port'] = v[0]
            elif kl == 'network-i-pv4':
                d['network_i_pv4'] = v[0]
            elif kl == 'network-i-pv6':
                d['network_i_pv6'] = v[0]
            elif kl == 'network-port':
                d['network_port'] = v[0]
            elif kl == 'network-protocol':
                d['network_protocol'] = v[0]
            elif kl == 'network-source-asn':
                d['network_source_asn'] = v[0]
            elif kl == 'network-source-cidr-block':
                d['network_source_cidr_block'] = v[0]
            elif kl == 'network-source-i-pv4':
                d['network_source_i_pv4'] = v[0]
            elif kl == 'network-source-i-pv6':
                d['network_source_i_pv6'] = v[0]
            elif kl == 'network-source-port':
                d['network_source_port'] = v[0]
            elif kl == 'passive-only':
                d['passive_only'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'tags':
                d['tags'] = v
            elif kl == 'target-product':
                d['target_product'] = v[0]
            elif kl == 'threat-type':
                d['threat_type'] = v[0]
            elif kl == 'tlp-level':
                d['tlp_level'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'user-agent':
                d['user_agent'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter value. All possible keys are: action, '
                               'activity-group-names, additional-information, azure-tenant-id, confidence, '
                               'description, diamond-model, domain-name, email-encoding, email-language, '
                               'email-recipient, email-sender-address, email-sender-name, email-source-domain, '
                               'email-source-ip-address, email-subject, email-x-mailer, expiration-date-time, '
                               'external-id, file-compile-date-time, file-created-date-time, file-hash-type, '
                               'file-hash-value, file-mutex-name, file-name, file-packer, file-path, file-size, '
                               'file-type, ingested-date-time, is-active, kill-chain, known-false-positives, '
                               'last-reported-date-time, malware-family-names, network-cidr-block, '
                               'network-destination-asn, network-destination-cidr-block, network-destination-i-pv4, '
                               'network-destination-i-pv6, network-destination-port, network-i-pv4, network-i-pv6, '
                               'network-port, network-protocol, network-source-asn, network-source-cidr-block, '
                               'network-source-i-pv4, network-source-i-pv6, network-source-port, passive-only, '
                               'severity, tags, target-product, threat-type, tlp-level, url, user-agent, id'.format(k))
        return d


class AddSecuritySecuritytiindicatorUpdateTiIndicatorValue(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSecuritySecuritytiindicatorUpdateTiIndicatorValue, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action':
                d['action'] = v[0]
            elif kl == 'activity-group-names':
                d['activity_group_names'] = v
            elif kl == 'additional-information':
                d['additional_information'] = v[0]
            elif kl == 'azure-tenant-id':
                d['azure_tenant_id'] = v[0]
            elif kl == 'confidence':
                d['confidence'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'diamond-model':
                d['diamond_model'] = v[0]
            elif kl == 'domain-name':
                d['domain_name'] = v[0]
            elif kl == 'email-encoding':
                d['email_encoding'] = v[0]
            elif kl == 'email-language':
                d['email_language'] = v[0]
            elif kl == 'email-recipient':
                d['email_recipient'] = v[0]
            elif kl == 'email-sender-address':
                d['email_sender_address'] = v[0]
            elif kl == 'email-sender-name':
                d['email_sender_name'] = v[0]
            elif kl == 'email-source-domain':
                d['email_source_domain'] = v[0]
            elif kl == 'email-source-ip-address':
                d['email_source_ip_address'] = v[0]
            elif kl == 'email-subject':
                d['email_subject'] = v[0]
            elif kl == 'email-x-mailer':
                d['email_x_mailer'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'external-id':
                d['external_id'] = v[0]
            elif kl == 'file-compile-date-time':
                d['file_compile_date_time'] = v[0]
            elif kl == 'file-created-date-time':
                d['file_created_date_time'] = v[0]
            elif kl == 'file-hash-type':
                d['file_hash_type'] = v[0]
            elif kl == 'file-hash-value':
                d['file_hash_value'] = v[0]
            elif kl == 'file-mutex-name':
                d['file_mutex_name'] = v[0]
            elif kl == 'file-name':
                d['file_name'] = v[0]
            elif kl == 'file-packer':
                d['file_packer'] = v[0]
            elif kl == 'file-path':
                d['file_path'] = v[0]
            elif kl == 'file-size':
                d['file_size'] = v[0]
            elif kl == 'file-type':
                d['file_type'] = v[0]
            elif kl == 'ingested-date-time':
                d['ingested_date_time'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'kill-chain':
                d['kill_chain'] = v
            elif kl == 'known-false-positives':
                d['known_false_positives'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'malware-family-names':
                d['malware_family_names'] = v
            elif kl == 'network-cidr-block':
                d['network_cidr_block'] = v[0]
            elif kl == 'network-destination-asn':
                d['network_destination_asn'] = v[0]
            elif kl == 'network-destination-cidr-block':
                d['network_destination_cidr_block'] = v[0]
            elif kl == 'network-destination-i-pv4':
                d['network_destination_i_pv4'] = v[0]
            elif kl == 'network-destination-i-pv6':
                d['network_destination_i_pv6'] = v[0]
            elif kl == 'network-destination-port':
                d['network_destination_port'] = v[0]
            elif kl == 'network-i-pv4':
                d['network_i_pv4'] = v[0]
            elif kl == 'network-i-pv6':
                d['network_i_pv6'] = v[0]
            elif kl == 'network-port':
                d['network_port'] = v[0]
            elif kl == 'network-protocol':
                d['network_protocol'] = v[0]
            elif kl == 'network-source-asn':
                d['network_source_asn'] = v[0]
            elif kl == 'network-source-cidr-block':
                d['network_source_cidr_block'] = v[0]
            elif kl == 'network-source-i-pv4':
                d['network_source_i_pv4'] = v[0]
            elif kl == 'network-source-i-pv6':
                d['network_source_i_pv6'] = v[0]
            elif kl == 'network-source-port':
                d['network_source_port'] = v[0]
            elif kl == 'passive-only':
                d['passive_only'] = v[0]
            elif kl == 'severity':
                d['severity'] = v[0]
            elif kl == 'tags':
                d['tags'] = v
            elif kl == 'target-product':
                d['target_product'] = v[0]
            elif kl == 'threat-type':
                d['threat_type'] = v[0]
            elif kl == 'tlp-level':
                d['tlp_level'] = v[0]
            elif kl == 'url':
                d['url'] = v[0]
            elif kl == 'user-agent':
                d['user_agent'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter value. All possible keys are: action, '
                               'activity-group-names, additional-information, azure-tenant-id, confidence, '
                               'description, diamond-model, domain-name, email-encoding, email-language, '
                               'email-recipient, email-sender-address, email-sender-name, email-source-domain, '
                               'email-source-ip-address, email-subject, email-x-mailer, expiration-date-time, '
                               'external-id, file-compile-date-time, file-created-date-time, file-hash-type, '
                               'file-hash-value, file-mutex-name, file-name, file-packer, file-path, file-size, '
                               'file-type, ingested-date-time, is-active, kill-chain, known-false-positives, '
                               'last-reported-date-time, malware-family-names, network-cidr-block, '
                               'network-destination-asn, network-destination-cidr-block, network-destination-i-pv4, '
                               'network-destination-i-pv6, network-destination-port, network-i-pv4, network-i-pv6, '
                               'network-port, network-protocol, network-source-asn, network-source-cidr-block, '
                               'network-source-i-pv4, network-source-i-pv6, network-source-port, passive-only, '
                               'severity, tags, target-product, threat-type, tlp-level, url, user-agent, id'.format(k))
        return d
