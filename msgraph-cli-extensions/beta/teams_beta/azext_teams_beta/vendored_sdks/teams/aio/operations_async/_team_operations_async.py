# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class TeamOperations:
    """TeamOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~teams.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_channel(
        self,
        team_id: str,
        orderby: Optional[List[Union[str, "models.Enum171"]]] = None,
        select: Optional[List[Union[str, "models.Enum172"]]] = None,
        expand: Optional[List[Union[str, "models.Enum173"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfChannel"]:
        """Get channels from teams.

        Get channels from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum171]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum172]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum173]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfChannel or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~teams.models.CollectionOfChannel]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_channel.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfChannel', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_channel.metadata = {'url': '/teams/{team-id}/channels'}  # type: ignore

    async def create_channel(
        self,
        team_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        is_favorite_by_default: Optional[bool] = None,
        membership_type: Optional[Union[str, "models.MicrosoftGraphChannelMembershipType"]] = None,
        moderation_settings: Optional["models.MicrosoftGraphChannelModerationSettings"] = None,
        web_url: Optional[str] = None,
        files_folder: Optional["models.MicrosoftGraphDriveItem"] = None,
        members: Optional[List["models.MicrosoftGraphConversationMember"]] = None,
        messages: Optional[List["models.MicrosoftGraphChatMessage"]] = None,
        tabs: Optional[List["models.MicrosoftGraphTeamsTab"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphChannel":
        """Create new navigation property to channels for teams.

        Create new navigation property to channels for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: Read only. Timestamp at which the channel was created.
        :type created_date_time: ~datetime.datetime
        :param description: Optional textual description for the channel.
        :type description: str
        :param display_name: Channel name as it will appear to the user in Microsoft Teams.
        :type display_name: str
        :param email: The email address for sending messages to the channel. Read-only.
        :type email: str
        :param is_favorite_by_default: Indicates whether the channel should automatically be marked
         'favorite' for all members of the team. Can only be set programmatically with Create team.
         Default: false.
        :type is_favorite_by_default: bool
        :param membership_type:
        :type membership_type: str or ~teams.models.MicrosoftGraphChannelMembershipType
        :param moderation_settings: channelModerationSettings.
        :type moderation_settings: ~teams.models.MicrosoftGraphChannelModerationSettings
        :param web_url: A hyperlink that will go to the channel in Microsoft Teams. This is the URL
         that you get when you right-click a channel in Microsoft Teams and select Get link to channel.
         This URL should be treated as an opaque blob, and not parsed. Read-only.
        :type web_url: str
        :param files_folder: driveItem.
        :type files_folder: ~teams.models.MicrosoftGraphDriveItem
        :param members:
        :type members: list[~teams.models.MicrosoftGraphConversationMember]
        :param messages: A collection of all the messages in the channel. A navigation property.
         Nullable.
        :type messages: list[~teams.models.MicrosoftGraphChatMessage]
        :param tabs: A collection of all the tabs in the channel. A navigation property.
        :type tabs: list[~teams.models.MicrosoftGraphTeamsTab]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphChannel, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphChannel
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphChannel(id=id, created_date_time=created_date_time, description=description, display_name=display_name, email=email, is_favorite_by_default=is_favorite_by_default, membership_type=membership_type, moderation_settings=moderation_settings, web_url=web_url, files_folder=files_folder, members=members, messages=messages, tabs=tabs)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphChannel')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphChannel', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_channel.metadata = {'url': '/teams/{team-id}/channels'}  # type: ignore

    async def get_channel(
        self,
        team_id: str,
        channel_id: str,
        select: Optional[List[Union[str, "models.Enum174"]]] = None,
        expand: Optional[List[Union[str, "models.Enum175"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphChannel":
        """Get channels from teams.

        Get channels from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param channel_id: key: id of channel.
        :type channel_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum174]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum175]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphChannel, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphChannel
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'channel-id': self._serialize.url("channel_id", channel_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphChannel', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_channel.metadata = {'url': '/teams/{team-id}/channels/{channel-id}'}  # type: ignore

    async def update_channel(
        self,
        team_id: str,
        channel_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        is_favorite_by_default: Optional[bool] = None,
        membership_type: Optional[Union[str, "models.MicrosoftGraphChannelMembershipType"]] = None,
        moderation_settings: Optional["models.MicrosoftGraphChannelModerationSettings"] = None,
        web_url: Optional[str] = None,
        files_folder: Optional["models.MicrosoftGraphDriveItem"] = None,
        members: Optional[List["models.MicrosoftGraphConversationMember"]] = None,
        messages: Optional[List["models.MicrosoftGraphChatMessage"]] = None,
        tabs: Optional[List["models.MicrosoftGraphTeamsTab"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property channels in teams.

        Update the navigation property channels in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param channel_id: key: id of channel.
        :type channel_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: Read only. Timestamp at which the channel was created.
        :type created_date_time: ~datetime.datetime
        :param description: Optional textual description for the channel.
        :type description: str
        :param display_name: Channel name as it will appear to the user in Microsoft Teams.
        :type display_name: str
        :param email: The email address for sending messages to the channel. Read-only.
        :type email: str
        :param is_favorite_by_default: Indicates whether the channel should automatically be marked
         'favorite' for all members of the team. Can only be set programmatically with Create team.
         Default: false.
        :type is_favorite_by_default: bool
        :param membership_type:
        :type membership_type: str or ~teams.models.MicrosoftGraphChannelMembershipType
        :param moderation_settings: channelModerationSettings.
        :type moderation_settings: ~teams.models.MicrosoftGraphChannelModerationSettings
        :param web_url: A hyperlink that will go to the channel in Microsoft Teams. This is the URL
         that you get when you right-click a channel in Microsoft Teams and select Get link to channel.
         This URL should be treated as an opaque blob, and not parsed. Read-only.
        :type web_url: str
        :param files_folder: driveItem.
        :type files_folder: ~teams.models.MicrosoftGraphDriveItem
        :param members:
        :type members: list[~teams.models.MicrosoftGraphConversationMember]
        :param messages: A collection of all the messages in the channel. A navigation property.
         Nullable.
        :type messages: list[~teams.models.MicrosoftGraphChatMessage]
        :param tabs: A collection of all the tabs in the channel. A navigation property.
        :type tabs: list[~teams.models.MicrosoftGraphTeamsTab]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphChannel(id=id, created_date_time=created_date_time, description=description, display_name=display_name, email=email, is_favorite_by_default=is_favorite_by_default, membership_type=membership_type, moderation_settings=moderation_settings, web_url=web_url, files_folder=files_folder, members=members, messages=messages, tabs=tabs)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'channel-id': self._serialize.url("channel_id", channel_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphChannel')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_channel.metadata = {'url': '/teams/{team-id}/channels/{channel-id}'}  # type: ignore

    async def delete_channel(
        self,
        team_id: str,
        channel_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property channels for teams.

        Delete navigation property channels for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param channel_id: key: id of channel.
        :type channel_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'channel-id': self._serialize.url("channel_id", channel_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_channel.metadata = {'url': '/teams/{team-id}/channels/{channel-id}'}  # type: ignore

    async def get_group(
        self,
        team_id: str,
        select: Optional[List[Union[str, "models.Enum201"]]] = None,
        expand: Optional[List[Union[str, "models.Enum202"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphGroup":
        """Get group from teams.

        Get group from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum201]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum202]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphGroup, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphGroup
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphGroup"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphGroup', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_group.metadata = {'url': '/teams/{team-id}/group'}  # type: ignore

    async def get_ref_group(
        self,
        team_id: str,
        **kwargs
    ) -> str:
        """Get ref of group from teams.

        Get ref of group from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_ref_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_ref_group.metadata = {'url': '/teams/{team-id}/group/$ref'}  # type: ignore

    async def set_ref_group(
        self,
        team_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> None:
        """Update the ref of navigation property group in teams.

        Update the ref of navigation property group in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param body: New navigation property ref values.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.set_ref_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_ref_group.metadata = {'url': '/teams/{team-id}/group/$ref'}  # type: ignore

    async def delete_ref_group(
        self,
        team_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete ref of navigation property group for teams.

        Delete ref of navigation property group for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_ref_group.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_ref_group.metadata = {'url': '/teams/{team-id}/group/$ref'}  # type: ignore

    def list_installed_app(
        self,
        team_id: str,
        orderby: Optional[List[Union[str, "models.Enum203"]]] = None,
        select: Optional[List[Union[str, "models.Enum204"]]] = None,
        expand: Optional[List[Union[str, "models.Enum205"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTeamsAppInstallation0"]:
        """Get installedApps from teams.

        Get installedApps from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum203]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum204]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum205]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTeamsAppInstallation0 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~teams.models.CollectionOfTeamsAppInstallation0]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTeamsAppInstallation0"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_installed_app.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTeamsAppInstallation0', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_installed_app.metadata = {'url': '/teams/{team-id}/installedApps'}  # type: ignore

    async def create_installed_app(
        self,
        team_id: str,
        id: Optional[str] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        azure_ad_app_id: Optional[str] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        publishing_state: Optional[Union[str, "models.MicrosoftGraphTeamsAppPublishingState"]] = None,
        shortdescription: Optional[str] = None,
        teams_app_id: Optional[str] = None,
        version: Optional[str] = None,
        microsoft_graph_identity_display_name: Optional[str] = None,
        microsoft_graph_identity_id: Optional[str] = None,
        display_name1: Optional[str] = None,
        id1: Optional[str] = None,
        display_name2: Optional[str] = None,
        id2: Optional[str] = None,
        id3: Optional[str] = None,
        microsoft_graph_teams_app_display_name: Optional[str] = None,
        distribution_method: Optional[Union[str, "models.MicrosoftGraphTeamsAppDistributionMethod"]] = None,
        external_id: Optional[str] = None,
        app_definitions: Optional[List["models.MicrosoftGraphTeamsAppDefinition"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTeamsAppInstallation":
        """Create new navigation property to installedApps for teams.

        Create new navigation property to installedApps for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param azure_ad_app_id:
        :type azure_ad_app_id: str
        :param description:
        :type description: str
        :param display_name: The name of the app provided by the app developer.
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param publishing_state:
        :type publishing_state: str or ~teams.models.MicrosoftGraphTeamsAppPublishingState
        :param shortdescription:
        :type shortdescription: str
        :param teams_app_id: The ID from the Teams app manifest.
        :type teams_app_id: str
        :param version: The version number of the application.
        :type version: str
        :param microsoft_graph_identity_display_name: The identity's display name. Note that this may
         not always be available or up to date. For example, if a user changes their display name, the
         API may show the new value in a future response, but the items associated with the user won't
         show up as having changed when using delta.
        :type microsoft_graph_identity_display_name: str
        :param microsoft_graph_identity_id: Unique identifier for the identity.
        :type microsoft_graph_identity_id: str
        :param display_name1: The identity's display name. Note that this may not always be available
         or up to date. For example, if a user changes their display name, the API may show the new
         value in a future response, but the items associated with the user won't show up as having
         changed when using delta.
        :type display_name1: str
        :param id1: Unique identifier for the identity.
        :type id1: str
        :param display_name2: The identity's display name. Note that this may not always be available
         or up to date. For example, if a user changes their display name, the API may show the new
         value in a future response, but the items associated with the user won't show up as having
         changed when using delta.
        :type display_name2: str
        :param id2: Unique identifier for the identity.
        :type id2: str
        :param id3: Read-only.
        :type id3: str
        :param microsoft_graph_teams_app_display_name: The name of the catalog app provided by the app
         developer in the Microsoft Teams zip app package.
        :type microsoft_graph_teams_app_display_name: str
        :param distribution_method:
        :type distribution_method: str or ~teams.models.MicrosoftGraphTeamsAppDistributionMethod
        :param external_id: The ID of the catalog provided by the app developer in the Microsoft Teams
         zip app package.
        :type external_id: str
        :param app_definitions: The details for each version of the app.
        :type app_definitions: list[~teams.models.MicrosoftGraphTeamsAppDefinition]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAppInstallation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAppInstallation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAppInstallation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAppInstallation(id=id, id_teams_app_definition_id=microsoft_graph_entity_id, azure_ad_app_id=azure_ad_app_id, description=description, display_name_teams_app_definition_display_name=display_name, last_modified_date_time=last_modified_date_time, publishing_state=publishing_state, shortdescription=shortdescription, teams_app_id=teams_app_id, version=version, display_name_teams_app_definition_created_by_user_display_name=microsoft_graph_identity_display_name, id_teams_app_definition_created_by_user_id=microsoft_graph_identity_id, display_name_teams_app_definition_created_by_device_display_name=display_name1, id_teams_app_definition_created_by_device_id=id1, display_name_teams_app_definition_created_by_application_display_name=display_name2, id_teams_app_definition_created_by_application_id=id2, id_teams_app_id=id3, display_name_teams_app_display_name=microsoft_graph_teams_app_display_name, distribution_method=distribution_method, external_id=external_id, app_definitions=app_definitions)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAppInstallation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAppInstallation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_installed_app.metadata = {'url': '/teams/{team-id}/installedApps'}  # type: ignore

    async def get_installed_app(
        self,
        team_id: str,
        teams_app_installation_id: str,
        select: Optional[List[Union[str, "models.Enum206"]]] = None,
        expand: Optional[List[Union[str, "models.Enum207"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTeamsAppInstallation":
        """Get installedApps from teams.

        Get installedApps from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_app_installation_id: key: id of teamsAppInstallation.
        :type teams_app_installation_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum206]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum207]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAppInstallation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAppInstallation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAppInstallation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAppInstallation-id': self._serialize.url("teams_app_installation_id", teams_app_installation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAppInstallation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_installed_app.metadata = {'url': '/teams/{team-id}/installedApps/{teamsAppInstallation-id}'}  # type: ignore

    async def update_installed_app(
        self,
        team_id: str,
        teams_app_installation_id: str,
        id: Optional[str] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        azure_ad_app_id: Optional[str] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        publishing_state: Optional[Union[str, "models.MicrosoftGraphTeamsAppPublishingState"]] = None,
        shortdescription: Optional[str] = None,
        teams_app_id: Optional[str] = None,
        version: Optional[str] = None,
        microsoft_graph_identity_display_name: Optional[str] = None,
        microsoft_graph_identity_id: Optional[str] = None,
        display_name1: Optional[str] = None,
        id1: Optional[str] = None,
        display_name2: Optional[str] = None,
        id2: Optional[str] = None,
        id3: Optional[str] = None,
        microsoft_graph_teams_app_display_name: Optional[str] = None,
        distribution_method: Optional[Union[str, "models.MicrosoftGraphTeamsAppDistributionMethod"]] = None,
        external_id: Optional[str] = None,
        app_definitions: Optional[List["models.MicrosoftGraphTeamsAppDefinition"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property installedApps in teams.

        Update the navigation property installedApps in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_app_installation_id: key: id of teamsAppInstallation.
        :type teams_app_installation_id: str
        :param id: Read-only.
        :type id: str
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param azure_ad_app_id:
        :type azure_ad_app_id: str
        :param description:
        :type description: str
        :param display_name: The name of the app provided by the app developer.
        :type display_name: str
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param publishing_state:
        :type publishing_state: str or ~teams.models.MicrosoftGraphTeamsAppPublishingState
        :param shortdescription:
        :type shortdescription: str
        :param teams_app_id: The ID from the Teams app manifest.
        :type teams_app_id: str
        :param version: The version number of the application.
        :type version: str
        :param microsoft_graph_identity_display_name: The identity's display name. Note that this may
         not always be available or up to date. For example, if a user changes their display name, the
         API may show the new value in a future response, but the items associated with the user won't
         show up as having changed when using delta.
        :type microsoft_graph_identity_display_name: str
        :param microsoft_graph_identity_id: Unique identifier for the identity.
        :type microsoft_graph_identity_id: str
        :param display_name1: The identity's display name. Note that this may not always be available
         or up to date. For example, if a user changes their display name, the API may show the new
         value in a future response, but the items associated with the user won't show up as having
         changed when using delta.
        :type display_name1: str
        :param id1: Unique identifier for the identity.
        :type id1: str
        :param display_name2: The identity's display name. Note that this may not always be available
         or up to date. For example, if a user changes their display name, the API may show the new
         value in a future response, but the items associated with the user won't show up as having
         changed when using delta.
        :type display_name2: str
        :param id2: Unique identifier for the identity.
        :type id2: str
        :param id3: Read-only.
        :type id3: str
        :param microsoft_graph_teams_app_display_name: The name of the catalog app provided by the app
         developer in the Microsoft Teams zip app package.
        :type microsoft_graph_teams_app_display_name: str
        :param distribution_method:
        :type distribution_method: str or ~teams.models.MicrosoftGraphTeamsAppDistributionMethod
        :param external_id: The ID of the catalog provided by the app developer in the Microsoft Teams
         zip app package.
        :type external_id: str
        :param app_definitions: The details for each version of the app.
        :type app_definitions: list[~teams.models.MicrosoftGraphTeamsAppDefinition]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAppInstallation(id=id, id_teams_app_definition_id=microsoft_graph_entity_id, azure_ad_app_id=azure_ad_app_id, description=description, display_name_teams_app_definition_display_name=display_name, last_modified_date_time=last_modified_date_time, publishing_state=publishing_state, shortdescription=shortdescription, teams_app_id=teams_app_id, version=version, display_name_teams_app_definition_created_by_user_display_name=microsoft_graph_identity_display_name, id_teams_app_definition_created_by_user_id=microsoft_graph_identity_id, display_name_teams_app_definition_created_by_device_display_name=display_name1, id_teams_app_definition_created_by_device_id=id1, display_name_teams_app_definition_created_by_application_display_name=display_name2, id_teams_app_definition_created_by_application_id=id2, id_teams_app_id=id3, display_name_teams_app_display_name=microsoft_graph_teams_app_display_name, distribution_method=distribution_method, external_id=external_id, app_definitions=app_definitions)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAppInstallation-id': self._serialize.url("teams_app_installation_id", teams_app_installation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAppInstallation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_installed_app.metadata = {'url': '/teams/{team-id}/installedApps/{teamsAppInstallation-id}'}  # type: ignore

    async def delete_installed_app(
        self,
        team_id: str,
        teams_app_installation_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property installedApps for teams.

        Delete navigation property installedApps for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_app_installation_id: key: id of teamsAppInstallation.
        :type teams_app_installation_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_installed_app.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAppInstallation-id': self._serialize.url("teams_app_installation_id", teams_app_installation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_installed_app.metadata = {'url': '/teams/{team-id}/installedApps/{teamsAppInstallation-id}'}  # type: ignore

    def list_member(
        self,
        team_id: str,
        orderby: Optional[List[Union[str, "models.Enum211"]]] = None,
        select: Optional[List[Union[str, "models.Enum212"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfConversationMember1"]:
        """Get members from teams.

        Get members from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum211]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum212]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfConversationMember1 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~teams.models.CollectionOfConversationMember1]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfConversationMember1"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_member.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfConversationMember1', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_member.metadata = {'url': '/teams/{team-id}/members'}  # type: ignore

    async def create_member(
        self,
        team_id: str,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        roles: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphConversationMember":
        """Create new navigation property to members for teams.

        Create new navigation property to members for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param display_name: The display name of the user.
        :type display_name: str
        :param roles: The roles for that user.
        :type roles: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConversationMember, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphConversationMember
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConversationMember"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConversationMember(id=id, display_name=display_name, roles=roles)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConversationMember')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConversationMember', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_member.metadata = {'url': '/teams/{team-id}/members'}  # type: ignore

    async def get_member(
        self,
        team_id: str,
        conversation_member_id: str,
        select: Optional[List[Union[str, "models.Enum213"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphConversationMember":
        """Get members from teams.

        Get members from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param conversation_member_id: key: id of conversationMember.
        :type conversation_member_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum213]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphConversationMember, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphConversationMember
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphConversationMember"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'conversationMember-id': self._serialize.url("conversation_member_id", conversation_member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphConversationMember', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_member.metadata = {'url': '/teams/{team-id}/members/{conversationMember-id}'}  # type: ignore

    async def update_member(
        self,
        team_id: str,
        conversation_member_id: str,
        id: Optional[str] = None,
        display_name: Optional[str] = None,
        roles: Optional[List[str]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property members in teams.

        Update the navigation property members in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param conversation_member_id: key: id of conversationMember.
        :type conversation_member_id: str
        :param id: Read-only.
        :type id: str
        :param display_name: The display name of the user.
        :type display_name: str
        :param roles: The roles for that user.
        :type roles: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphConversationMember(id=id, display_name=display_name, roles=roles)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'conversationMember-id': self._serialize.url("conversation_member_id", conversation_member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphConversationMember')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_member.metadata = {'url': '/teams/{team-id}/members/{conversationMember-id}'}  # type: ignore

    async def delete_member(
        self,
        team_id: str,
        conversation_member_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property members for teams.

        Delete navigation property members for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param conversation_member_id: key: id of conversationMember.
        :type conversation_member_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_member.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'conversationMember-id': self._serialize.url("conversation_member_id", conversation_member_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_member.metadata = {'url': '/teams/{team-id}/members/{conversationMember-id}'}  # type: ignore

    async def archive(
        self,
        team_id: str,
        should_set_spo_site_read_only_for_members: Optional[bool] = False,
        **kwargs
    ) -> None:
        """Invoke action archive.

        Invoke action archive.

        :param team_id: key: id of team.
        :type team_id: str
        :param should_set_spo_site_read_only_for_members:
        :type should_set_spo_site_read_only_for_members: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.PathsBezc4TeamsTeamIdMicrosoftGraphArchivePostRequestbodyContentApplicationJsonSchema(should_set_spo_site_read_only_for_members=should_set_spo_site_read_only_for_members)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.archive.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'PathsBezc4TeamsTeamIdMicrosoftGraphArchivePostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    archive.metadata = {'url': '/teams/{team-id}/microsoft.graph.archive'}  # type: ignore

    async def clone(
        self,
        team_id: str,
        display_name: Optional[str] = None,
        description: Optional[str] = None,
        mail_nickname: Optional[str] = None,
        classification: Optional[str] = None,
        visibility: Optional[Union[str, "models.MicrosoftGraphTeamVisibilityType"]] = None,
        parts_to_clone: Optional[Union[str, "models.MicrosoftGraphClonableTeamParts"]] = None,
        **kwargs
    ) -> None:
        """Invoke action clone.

        Invoke action clone.

        :param team_id: key: id of team.
        :type team_id: str
        :param display_name:
        :type display_name: str
        :param description:
        :type description: str
        :param mail_nickname:
        :type mail_nickname: str
        :param classification:
        :type classification: str
        :param visibility:
        :type visibility: str or ~teams.models.MicrosoftGraphTeamVisibilityType
        :param parts_to_clone:
        :type parts_to_clone: str or ~teams.models.MicrosoftGraphClonableTeamParts
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1Izic0UTeamsTeamIdMicrosoftGraphClonePostRequestbodyContentApplicationJsonSchema(display_name=display_name, description=description, mail_nickname=mail_nickname, classification=classification, visibility=visibility, parts_to_clone=parts_to_clone)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.clone.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1Izic0UTeamsTeamIdMicrosoftGraphClonePostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    clone.metadata = {'url': '/teams/{team-id}/microsoft.graph.clone'}  # type: ignore

    async def complete_migration(
        self,
        team_id: str,
        **kwargs
    ) -> None:
        """Invoke action completeMigration.

        Invoke action completeMigration.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.complete_migration.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    complete_migration.metadata = {'url': '/teams/{team-id}/microsoft.graph.completeMigration'}  # type: ignore

    async def send_activity_notification(
        self,
        team_id: str,
        topic: Optional["models.MicrosoftGraphTeamworkActivityTopic"] = None,
        activity_type: Optional[str] = None,
        chain_id: Optional[int] = None,
        preview_text: Optional["models.MicrosoftGraphItemBody"] = None,
        template_parameters: Optional[List["models.MicrosoftGraphKeyValuePair"]] = None,
        recipient: Optional[Dict[str, object]] = None,
        **kwargs
    ) -> None:
        """Invoke action sendActivityNotification.

        Invoke action sendActivityNotification.

        :param team_id: key: id of team.
        :type team_id: str
        :param topic: teamworkActivityTopic.
        :type topic: ~teams.models.MicrosoftGraphTeamworkActivityTopic
        :param activity_type:
        :type activity_type: str
        :param chain_id:
        :type chain_id: long
        :param preview_text: itemBody.
        :type preview_text: ~teams.models.MicrosoftGraphItemBody
        :param template_parameters:
        :type template_parameters: list[~teams.models.MicrosoftGraphKeyValuePair]
        :param recipient: teamworkNotificationRecipient.
        :type recipient: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.Paths1Bflym4TeamsTeamIdMicrosoftGraphSendactivitynotificationPostRequestbodyContentApplicationJsonSchema(topic=topic, activity_type=activity_type, chain_id=chain_id, preview_text=preview_text, template_parameters=template_parameters, recipient=recipient)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.send_activity_notification.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'Paths1Bflym4TeamsTeamIdMicrosoftGraphSendactivitynotificationPostRequestbodyContentApplicationJsonSchema')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    send_activity_notification.metadata = {'url': '/teams/{team-id}/microsoft.graph.sendActivityNotification'}  # type: ignore

    async def unarchive(
        self,
        team_id: str,
        **kwargs
    ) -> None:
        """Invoke action unarchive.

        Invoke action unarchive.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.unarchive.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    unarchive.metadata = {'url': '/teams/{team-id}/microsoft.graph.unarchive'}  # type: ignore

    def list_operation(
        self,
        team_id: str,
        orderby: Optional[List[Union[str, "models.Enum215"]]] = None,
        select: Optional[List[Union[str, "models.Enum216"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfTeamsAsyncOperation"]:
        """Get operations from teams.

        Get operations from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum215]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum216]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfTeamsAsyncOperation or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~teams.models.CollectionOfTeamsAsyncOperation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfTeamsAsyncOperation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_operation.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfTeamsAsyncOperation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_operation.metadata = {'url': '/teams/{team-id}/operations'}  # type: ignore

    async def create_operation(
        self,
        team_id: str,
        id: Optional[str] = None,
        attempts_count: Optional[int] = None,
        created_date_time: Optional[datetime.datetime] = None,
        error: Optional["models.MicrosoftGraphOperationError"] = None,
        last_action_date_time: Optional[datetime.datetime] = None,
        operation_type: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationType"]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationStatus"]] = None,
        target_resource_id: Optional[str] = None,
        target_resource_location: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTeamsAsyncOperation":
        """Create new navigation property to operations for teams.

        Create new navigation property to operations for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param attempts_count: Number of times the operation was attempted before being marked
         successful or failed.
        :type attempts_count: int
        :param created_date_time: Time when the operation was created.
        :type created_date_time: ~datetime.datetime
        :param error: operationError.
        :type error: ~teams.models.MicrosoftGraphOperationError
        :param last_action_date_time: Time when the async operation was last updated.
        :type last_action_date_time: ~datetime.datetime
        :param operation_type:
        :type operation_type: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationType
        :param status:
        :type status: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationStatus
        :param target_resource_id: The ID of the object that's created or modified as result of this
         async operation, typically a team.
        :type target_resource_id: str
        :param target_resource_location: The location of the object that's created or modified as
         result of this async operation. This URL should be treated as an opaque value and not parsed
         into its component paths.
        :type target_resource_location: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAsyncOperation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAsyncOperation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAsyncOperation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAsyncOperation(id=id, attempts_count=attempts_count, created_date_time=created_date_time, error=error, last_action_date_time=last_action_date_time, operation_type=operation_type, status=status, target_resource_id=target_resource_id, target_resource_location=target_resource_location)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAsyncOperation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAsyncOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_operation.metadata = {'url': '/teams/{team-id}/operations'}  # type: ignore

    async def get_operation(
        self,
        team_id: str,
        teams_async_operation_id: str,
        select: Optional[List[Union[str, "models.Enum217"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTeamsAsyncOperation":
        """Get operations from teams.

        Get operations from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_async_operation_id: key: id of teamsAsyncOperation.
        :type teams_async_operation_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum217]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsAsyncOperation, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsAsyncOperation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsAsyncOperation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAsyncOperation-id': self._serialize.url("teams_async_operation_id", teams_async_operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsAsyncOperation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_operation.metadata = {'url': '/teams/{team-id}/operations/{teamsAsyncOperation-id}'}  # type: ignore

    async def update_operation(
        self,
        team_id: str,
        teams_async_operation_id: str,
        id: Optional[str] = None,
        attempts_count: Optional[int] = None,
        created_date_time: Optional[datetime.datetime] = None,
        error: Optional["models.MicrosoftGraphOperationError"] = None,
        last_action_date_time: Optional[datetime.datetime] = None,
        operation_type: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationType"]] = None,
        status: Optional[Union[str, "models.MicrosoftGraphTeamsAsyncOperationStatus"]] = None,
        target_resource_id: Optional[str] = None,
        target_resource_location: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property operations in teams.

        Update the navigation property operations in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_async_operation_id: key: id of teamsAsyncOperation.
        :type teams_async_operation_id: str
        :param id: Read-only.
        :type id: str
        :param attempts_count: Number of times the operation was attempted before being marked
         successful or failed.
        :type attempts_count: int
        :param created_date_time: Time when the operation was created.
        :type created_date_time: ~datetime.datetime
        :param error: operationError.
        :type error: ~teams.models.MicrosoftGraphOperationError
        :param last_action_date_time: Time when the async operation was last updated.
        :type last_action_date_time: ~datetime.datetime
        :param operation_type:
        :type operation_type: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationType
        :param status:
        :type status: str or ~teams.models.MicrosoftGraphTeamsAsyncOperationStatus
        :param target_resource_id: The ID of the object that's created or modified as result of this
         async operation, typically a team.
        :type target_resource_id: str
        :param target_resource_location: The location of the object that's created or modified as
         result of this async operation. This URL should be treated as an opaque value and not parsed
         into its component paths.
        :type target_resource_location: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphTeamsAsyncOperation(id=id, attempts_count=attempts_count, created_date_time=created_date_time, error=error, last_action_date_time=last_action_date_time, operation_type=operation_type, status=status, target_resource_id=target_resource_id, target_resource_location=target_resource_location)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAsyncOperation-id': self._serialize.url("teams_async_operation_id", teams_async_operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphTeamsAsyncOperation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_operation.metadata = {'url': '/teams/{team-id}/operations/{teamsAsyncOperation-id}'}  # type: ignore

    async def delete_operation(
        self,
        team_id: str,
        teams_async_operation_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property operations for teams.

        Delete navigation property operations for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param teams_async_operation_id: key: id of teamsAsyncOperation.
        :type teams_async_operation_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
            'teamsAsyncOperation-id': self._serialize.url("teams_async_operation_id", teams_async_operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_operation.metadata = {'url': '/teams/{team-id}/operations/{teamsAsyncOperation-id}'}  # type: ignore

    def list_owner(
        self,
        team_id: str,
        orderby: Optional[List[Union[str, "models.Enum218"]]] = None,
        select: Optional[List[Union[str, "models.Enum219"]]] = None,
        expand: Optional[List[Union[str, "models.Enum220"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfUser"]:
        """Get owners from teams.

        Get owners from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum218]
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum219]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum220]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfUser or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~teams.models.CollectionOfUser]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_owner.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfUser', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_owner.metadata = {'url': '/teams/{team-id}/owners'}  # type: ignore

    def list_ref_owner(
        self,
        team_id: str,
        orderby: Optional[List[Union[str, "models.Enum221"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLinksOfUser"]:
        """Get ref of owners from teams.

        Get ref of owners from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~teams.models.Enum221]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLinksOfUser or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~teams.models.CollectionOfLinksOfUser]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLinksOfUser"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_ref_owner.metadata['url']  # type: ignore
                path_format_arguments = {
                    'team-id': self._serialize.url("team_id", team_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLinksOfUser', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_ref_owner.metadata = {'url': '/teams/{team-id}/owners/$ref'}  # type: ignore

    async def create_ref_owner(
        self,
        team_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> Dict[str, object]:
        """Create new navigation property ref to owners for teams.

        Create new navigation property ref to owners for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param body: New navigation property ref value.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: dict mapping str to object, or the result of cls(response)
        :rtype: dict[str, object]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Dict[str, object]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_ref_owner.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('{object}', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_ref_owner.metadata = {'url': '/teams/{team-id}/owners/$ref'}  # type: ignore

    async def get_photo(
        self,
        team_id: str,
        select: Optional[List[Union[str, "models.Enum222"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphProfilePhoto":
        """Get photo from teams.

        Get photo from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum222]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphProfilePhoto, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphProfilePhoto
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphProfilePhoto"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_photo.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphProfilePhoto', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_photo.metadata = {'url': '/teams/{team-id}/photo'}  # type: ignore

    async def update_photo(
        self,
        team_id: str,
        id: Optional[str] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        **kwargs
    ) -> None:
        """Update the navigation property photo in teams.

        Update the navigation property photo in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param height: The height of the photo. Read-only.
        :type height: int
        :param width: The width of the photo. Read-only.
        :type width: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphProfilePhoto(id=id, height=height, width=width)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_photo.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphProfilePhoto')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_photo.metadata = {'url': '/teams/{team-id}/photo'}  # type: ignore

    async def delete_photo(
        self,
        team_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property photo for teams.

        Delete navigation property photo for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_photo.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_photo.metadata = {'url': '/teams/{team-id}/photo'}  # type: ignore

    async def get_photo_content(
        self,
        team_id: str,
        **kwargs
    ) -> IO:
        """Get media content for the navigation property photo from teams.

        Get media content for the navigation property photo from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/octet-stream, application/json"

        # Construct URL
        url = self.get_photo_content.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/octet-stream, application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_photo_content.metadata = {'url': '/teams/{team-id}/photo/$value'}  # type: ignore

    async def set_photo_content(
        self,
        team_id: str,
        data: IO,
        **kwargs
    ) -> None:
        """Update media content for the navigation property photo in teams.

        Update media content for the navigation property photo in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param data: New media content.
        :type data: IO
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/octet-stream")
        accept = "application/json"

        # Construct URL
        url = self.set_photo_content.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content_kwargs['stream_content'] = data
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_photo_content.metadata = {'url': '/teams/{team-id}/photo/$value'}  # type: ignore

    async def get_primary_channel(
        self,
        team_id: str,
        select: Optional[List[Union[str, "models.Enum223"]]] = None,
        expand: Optional[List[Union[str, "models.Enum224"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphChannel":
        """Get primaryChannel from teams.

        Get primaryChannel from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum223]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum224]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphChannel, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphChannel
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphChannel"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_primary_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphChannel', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_primary_channel.metadata = {'url': '/teams/{team-id}/primaryChannel'}  # type: ignore

    async def update_primary_channel(
        self,
        team_id: str,
        id: Optional[str] = None,
        created_date_time: Optional[datetime.datetime] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        email: Optional[str] = None,
        is_favorite_by_default: Optional[bool] = None,
        membership_type: Optional[Union[str, "models.MicrosoftGraphChannelMembershipType"]] = None,
        moderation_settings: Optional["models.MicrosoftGraphChannelModerationSettings"] = None,
        web_url: Optional[str] = None,
        files_folder: Optional["models.MicrosoftGraphDriveItem"] = None,
        members: Optional[List["models.MicrosoftGraphConversationMember"]] = None,
        messages: Optional[List["models.MicrosoftGraphChatMessage"]] = None,
        tabs: Optional[List["models.MicrosoftGraphTeamsTab"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property primaryChannel in teams.

        Update the navigation property primaryChannel in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param created_date_time: Read only. Timestamp at which the channel was created.
        :type created_date_time: ~datetime.datetime
        :param description: Optional textual description for the channel.
        :type description: str
        :param display_name: Channel name as it will appear to the user in Microsoft Teams.
        :type display_name: str
        :param email: The email address for sending messages to the channel. Read-only.
        :type email: str
        :param is_favorite_by_default: Indicates whether the channel should automatically be marked
         'favorite' for all members of the team. Can only be set programmatically with Create team.
         Default: false.
        :type is_favorite_by_default: bool
        :param membership_type:
        :type membership_type: str or ~teams.models.MicrosoftGraphChannelMembershipType
        :param moderation_settings: channelModerationSettings.
        :type moderation_settings: ~teams.models.MicrosoftGraphChannelModerationSettings
        :param web_url: A hyperlink that will go to the channel in Microsoft Teams. This is the URL
         that you get when you right-click a channel in Microsoft Teams and select Get link to channel.
         This URL should be treated as an opaque blob, and not parsed. Read-only.
        :type web_url: str
        :param files_folder: driveItem.
        :type files_folder: ~teams.models.MicrosoftGraphDriveItem
        :param members:
        :type members: list[~teams.models.MicrosoftGraphConversationMember]
        :param messages: A collection of all the messages in the channel. A navigation property.
         Nullable.
        :type messages: list[~teams.models.MicrosoftGraphChatMessage]
        :param tabs: A collection of all the tabs in the channel. A navigation property.
        :type tabs: list[~teams.models.MicrosoftGraphTeamsTab]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphChannel(id=id, created_date_time=created_date_time, description=description, display_name=display_name, email=email, is_favorite_by_default=is_favorite_by_default, membership_type=membership_type, moderation_settings=moderation_settings, web_url=web_url, files_folder=files_folder, members=members, messages=messages, tabs=tabs)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_primary_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphChannel')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_primary_channel.metadata = {'url': '/teams/{team-id}/primaryChannel'}  # type: ignore

    async def delete_primary_channel(
        self,
        team_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property primaryChannel for teams.

        Delete navigation property primaryChannel for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_primary_channel.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_primary_channel.metadata = {'url': '/teams/{team-id}/primaryChannel'}  # type: ignore

    async def get_schedule(
        self,
        team_id: str,
        select: Optional[List[Union[str, "models.Enum250"]]] = None,
        expand: Optional[List[Union[str, "models.Enum251"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSchedule":
        """Get schedule from teams.

        Get schedule from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~teams.models.Enum250]
        :param expand: Expand related entities.
        :type expand: list[str or ~teams.models.Enum251]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSchedule, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphSchedule
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSchedule"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSchedule', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_schedule.metadata = {'url': '/teams/{team-id}/schedule'}  # type: ignore

    async def update_schedule(
        self,
        team_id: str,
        id: Optional[str] = None,
        enabled: Optional[bool] = None,
        offer_shift_requests_enabled: Optional[bool] = None,
        open_shifts_enabled: Optional[bool] = None,
        provision_status: Optional[Union[str, "models.MicrosoftGraphOperationStatus"]] = None,
        provision_status_code: Optional[str] = None,
        swap_shifts_requests_enabled: Optional[bool] = None,
        time_clock_enabled: Optional[bool] = None,
        time_off_requests_enabled: Optional[bool] = None,
        time_zone: Optional[str] = None,
        workforce_integration_ids: Optional[List[str]] = None,
        offer_shift_requests: Optional[List["models.MicrosoftGraphOfferShiftRequest"]] = None,
        open_shift_change_requests: Optional[List["models.MicrosoftGraphOpenShiftChangeRequest"]] = None,
        open_shifts: Optional[List["models.MicrosoftGraphOpenShift"]] = None,
        scheduling_groups: Optional[List["models.MicrosoftGraphSchedulingGroup"]] = None,
        shifts: Optional[List["models.MicrosoftGraphShift"]] = None,
        swap_shifts_change_requests: Optional[List["models.MicrosoftGraphSwapShiftsChangeRequest"]] = None,
        time_cards: Optional[List["models.MicrosoftGraphTimeCard"]] = None,
        time_off_reasons: Optional[List["models.MicrosoftGraphTimeOffReason"]] = None,
        time_off_requests: Optional[List["models.MicrosoftGraphTimeOffRequest"]] = None,
        times_off: Optional[List["models.MicrosoftGraphTimeOff"]] = None,
        approved_location: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property schedule in teams.

        Update the navigation property schedule in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param id: Read-only.
        :type id: str
        :param enabled: Indicates whether the schedule is enabled for the team. Required.
        :type enabled: bool
        :param offer_shift_requests_enabled: Indicates whether offer shift requests are enabled for the
         schedule.
        :type offer_shift_requests_enabled: bool
        :param open_shifts_enabled: Indicates whether open shifts are enabled for the schedule.
        :type open_shifts_enabled: bool
        :param provision_status:
        :type provision_status: str or ~teams.models.MicrosoftGraphOperationStatus
        :param provision_status_code: Additional information about why schedule provisioning failed.
        :type provision_status_code: str
        :param swap_shifts_requests_enabled: Indicates whether swap shifts requests are enabled for the
         schedule.
        :type swap_shifts_requests_enabled: bool
        :param time_clock_enabled: Indicates whether time clock is enabled for the schedule.
        :type time_clock_enabled: bool
        :param time_off_requests_enabled: Indicates whether time off requests are enabled for the
         schedule.
        :type time_off_requests_enabled: bool
        :param time_zone: Indicates the time zone of the schedule team using tz database format.
         Required.
        :type time_zone: str
        :param workforce_integration_ids:
        :type workforce_integration_ids: list[str]
        :param offer_shift_requests:
        :type offer_shift_requests: list[~teams.models.MicrosoftGraphOfferShiftRequest]
        :param open_shift_change_requests:
        :type open_shift_change_requests: list[~teams.models.MicrosoftGraphOpenShiftChangeRequest]
        :param open_shifts:
        :type open_shifts: list[~teams.models.MicrosoftGraphOpenShift]
        :param scheduling_groups: The logical grouping of users in the schedule (usually by role).
        :type scheduling_groups: list[~teams.models.MicrosoftGraphSchedulingGroup]
        :param shifts: The shifts in the schedule.
        :type shifts: list[~teams.models.MicrosoftGraphShift]
        :param swap_shifts_change_requests:
        :type swap_shifts_change_requests: list[~teams.models.MicrosoftGraphSwapShiftsChangeRequest]
        :param time_cards:
        :type time_cards: list[~teams.models.MicrosoftGraphTimeCard]
        :param time_off_reasons: The set of reasons for a time off in the schedule.
        :type time_off_reasons: list[~teams.models.MicrosoftGraphTimeOffReason]
        :param time_off_requests:
        :type time_off_requests: list[~teams.models.MicrosoftGraphTimeOffRequest]
        :param times_off: The instances of times off in the schedule.
        :type times_off: list[~teams.models.MicrosoftGraphTimeOff]
        :param approved_location: geoCoordinates.
        :type approved_location: ~teams.models.MicrosoftGraphGeoCoordinates
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSchedule(id=id, enabled=enabled, offer_shift_requests_enabled=offer_shift_requests_enabled, open_shifts_enabled=open_shifts_enabled, provision_status=provision_status, provision_status_code=provision_status_code, swap_shifts_requests_enabled=swap_shifts_requests_enabled, time_clock_enabled=time_clock_enabled, time_off_requests_enabled=time_off_requests_enabled, time_zone=time_zone, workforce_integration_ids=workforce_integration_ids, offer_shift_requests=offer_shift_requests, open_shift_change_requests=open_shift_change_requests, open_shifts=open_shifts, scheduling_groups=scheduling_groups, shifts=shifts, swap_shifts_change_requests=swap_shifts_change_requests, time_cards=time_cards, time_off_reasons=time_off_reasons, time_off_requests=time_off_requests, times_off=times_off, approved_location=approved_location)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSchedule')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_schedule.metadata = {'url': '/teams/{team-id}/schedule'}  # type: ignore

    async def delete_schedule(
        self,
        team_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property schedule for teams.

        Delete navigation property schedule for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_schedule.metadata = {'url': '/teams/{team-id}/schedule'}  # type: ignore

    async def get_template(
        self,
        team_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphTeamsTemplate":
        """Get template from teams.

        Get template from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param select: Select properties to be returned.
        :type select: list[str]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphTeamsTemplate, or the result of cls(response)
        :rtype: ~teams.models.MicrosoftGraphTeamsTemplate
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphTeamsTemplate"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphTeamsTemplate', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_template.metadata = {'url': '/teams/{team-id}/template'}  # type: ignore

    async def get_ref_template(
        self,
        team_id: str,
        **kwargs
    ) -> str:
        """Get ref of template from teams.

        Get ref of template from teams.

        :param team_id: key: id of team.
        :type team_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: str, or the result of cls(response)
        :rtype: str
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[str]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_ref_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('str', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_ref_template.metadata = {'url': '/teams/{team-id}/template/$ref'}  # type: ignore

    async def set_ref_template(
        self,
        team_id: str,
        body: Dict[str, object],
        **kwargs
    ) -> None:
        """Update the ref of navigation property template in teams.

        Update the ref of navigation property template in teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param body: New navigation property ref values.
        :type body: dict[str, object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.set_ref_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, '{object}')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    set_ref_template.metadata = {'url': '/teams/{team-id}/template/$ref'}  # type: ignore

    async def delete_ref_template(
        self,
        team_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete ref of navigation property template for teams.

        Delete ref of navigation property template for teams.

        :param team_id: key: id of team.
        :type team_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_ref_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'team-id': self._serialize.url("team_id", team_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_ref_template.metadata = {'url': '/teams/{team-id}/template/$ref'}  # type: ignore

    async def all_message(
        self,
        **kwargs
    ) -> List["models.MicrosoftGraphChatMessage"]:
        """Invoke function allMessages.

        Invoke function allMessages.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphChatMessage, or the result of cls(response)
        :rtype: list[~teams.models.MicrosoftGraphChatMessage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphChatMessage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.all_message.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphChatMessage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    all_message.metadata = {'url': '/teams/microsoft.graph.allMessages()'}  # type: ignore

    async def get_all_message(
        self,
        **kwargs
    ) -> List["models.MicrosoftGraphChatMessage"]:
        """Invoke function getAllMessages.

        Invoke function getAllMessages.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of MicrosoftGraphChatMessage, or the result of cls(response)
        :rtype: list[~teams.models.MicrosoftGraphChatMessage]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["models.MicrosoftGraphChatMessage"]]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_all_message.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('[MicrosoftGraphChatMessage]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_message.metadata = {'url': '/teams/microsoft.graph.getAllMessages()'}  # type: ignore
