# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class UserProfileOperations:
    """UserProfileOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~people.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_account(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum23"]]] = None,
        select: Optional[List[Union[str, "models.Enum24"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfUserAccountInformation"]:
        """Get account from users.

        Get account from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum23]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum24]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfUserAccountInformation or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfUserAccountInformation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfUserAccountInformation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_account.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfUserAccountInformation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_account.metadata = {'url': '/users/{user-id}/profile/account'}  # type: ignore

    async def create_account(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        age_group: Optional[str] = None,
        country_code: Optional[str] = None,
        preferred_language_tag: Optional["models.MicrosoftGraphLocaleInfo"] = None,
        user_principal_name: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphUserAccountInformation":
        """Create new navigation property to account for users.

        Create new navigation property to account for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param age_group:
        :type age_group: str
        :param country_code:
        :type country_code: str
        :param preferred_language_tag: localeInfo.
        :type preferred_language_tag: ~people.models.MicrosoftGraphLocaleInfo
        :param user_principal_name:
        :type user_principal_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUserAccountInformation, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphUserAccountInformation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUserAccountInformation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphUserAccountInformation(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, age_group=age_group, country_code=country_code, preferred_language_tag=preferred_language_tag, user_principal_name=user_principal_name)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphUserAccountInformation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUserAccountInformation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_account.metadata = {'url': '/users/{user-id}/profile/account'}  # type: ignore

    async def get_account(
        self,
        user_id: str,
        user_account_information_id: str,
        select: Optional[List[Union[str, "models.Enum25"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphUserAccountInformation":
        """Get account from users.

        Get account from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param user_account_information_id: key: id of userAccountInformation.
        :type user_account_information_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum25]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphUserAccountInformation, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphUserAccountInformation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphUserAccountInformation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'userAccountInformation-id': self._serialize.url("user_account_information_id", user_account_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphUserAccountInformation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_account.metadata = {'url': '/users/{user-id}/profile/account/{userAccountInformation-id}'}  # type: ignore

    async def update_account(
        self,
        user_id: str,
        user_account_information_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        age_group: Optional[str] = None,
        country_code: Optional[str] = None,
        preferred_language_tag: Optional["models.MicrosoftGraphLocaleInfo"] = None,
        user_principal_name: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property account in users.

        Update the navigation property account in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param user_account_information_id: key: id of userAccountInformation.
        :type user_account_information_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param age_group:
        :type age_group: str
        :param country_code:
        :type country_code: str
        :param preferred_language_tag: localeInfo.
        :type preferred_language_tag: ~people.models.MicrosoftGraphLocaleInfo
        :param user_principal_name:
        :type user_principal_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphUserAccountInformation(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, age_group=age_group, country_code=country_code, preferred_language_tag=preferred_language_tag, user_principal_name=user_principal_name)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'userAccountInformation-id': self._serialize.url("user_account_information_id", user_account_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphUserAccountInformation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_account.metadata = {'url': '/users/{user-id}/profile/account/{userAccountInformation-id}'}  # type: ignore

    async def delete_account(
        self,
        user_id: str,
        user_account_information_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property account for users.

        Delete navigation property account for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param user_account_information_id: key: id of userAccountInformation.
        :type user_account_information_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'userAccountInformation-id': self._serialize.url("user_account_information_id", user_account_information_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_account.metadata = {'url': '/users/{user-id}/profile/account/{userAccountInformation-id}'}  # type: ignore

    def list_address(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum26"]]] = None,
        select: Optional[List[Union[str, "models.Enum27"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItemAddress"]:
        """Get addresses from users.

        Get addresses from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum26]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum27]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItemAddress or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfItemAddress]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItemAddress"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_address.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItemAddress', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_address.metadata = {'url': '/users/{user-id}/profile/addresses'}  # type: ignore

    async def create_address(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        detail: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        display_name: Optional[str] = None,
        geo_coordinates: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemAddress":
        """Create new navigation property to addresses for users.

        Create new navigation property to addresses for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param detail: physicalAddress.
        :type detail: ~people.models.MicrosoftGraphPhysicalAddress
        :param display_name:
        :type display_name: str
        :param geo_coordinates: geoCoordinates.
        :type geo_coordinates: ~people.models.MicrosoftGraphGeoCoordinates
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemAddress, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemAddress
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemAddress"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemAddress(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, detail=detail, display_name=display_name, geo_coordinates=geo_coordinates)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_address.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemAddress')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemAddress', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_address.metadata = {'url': '/users/{user-id}/profile/addresses'}  # type: ignore

    async def get_address(
        self,
        user_id: str,
        item_address_id: str,
        select: Optional[List[Union[str, "models.Enum28"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemAddress":
        """Get addresses from users.

        Get addresses from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_address_id: key: id of itemAddress.
        :type item_address_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum28]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemAddress, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemAddress
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemAddress"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_address.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemAddress-id': self._serialize.url("item_address_id", item_address_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemAddress', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_address.metadata = {'url': '/users/{user-id}/profile/addresses/{itemAddress-id}'}  # type: ignore

    async def update_address(
        self,
        user_id: str,
        item_address_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        detail: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        display_name: Optional[str] = None,
        geo_coordinates: Optional["models.MicrosoftGraphGeoCoordinates"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property addresses in users.

        Update the navigation property addresses in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_address_id: key: id of itemAddress.
        :type item_address_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param detail: physicalAddress.
        :type detail: ~people.models.MicrosoftGraphPhysicalAddress
        :param display_name:
        :type display_name: str
        :param geo_coordinates: geoCoordinates.
        :type geo_coordinates: ~people.models.MicrosoftGraphGeoCoordinates
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemAddress(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, detail=detail, display_name=display_name, geo_coordinates=geo_coordinates)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_address.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemAddress-id': self._serialize.url("item_address_id", item_address_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemAddress')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_address.metadata = {'url': '/users/{user-id}/profile/addresses/{itemAddress-id}'}  # type: ignore

    async def delete_address(
        self,
        user_id: str,
        item_address_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property addresses for users.

        Delete navigation property addresses for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_address_id: key: id of itemAddress.
        :type item_address_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_address.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemAddress-id': self._serialize.url("item_address_id", item_address_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_address.metadata = {'url': '/users/{user-id}/profile/addresses/{itemAddress-id}'}  # type: ignore

    def list_anniversary(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum29"]]] = None,
        select: Optional[List[Union[str, "models.Enum30"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonAnniversary"]:
        """Get anniversaries from users.

        Get anniversaries from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum29]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum30]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonAnniversary or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonAnniversary]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonAnniversary"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_anniversary.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonAnniversary', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_anniversary.metadata = {'url': '/users/{user-id}/profile/anniversaries'}  # type: ignore

    async def create_anniversary(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        date: Optional[datetime.date] = None,
        type: Optional[Union[str, "models.MicrosoftGraphAnniversaryType"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonAnniversary":
        """Create new navigation property to anniversaries for users.

        Create new navigation property to anniversaries for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param date:
        :type date: ~datetime.date
        :param type:
        :type type: str or ~people.models.MicrosoftGraphAnniversaryType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonAnniversary, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonAnniversary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonAnniversary"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonAnniversary(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, date=date, type=type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_anniversary.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonAnniversary')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonAnniversary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_anniversary.metadata = {'url': '/users/{user-id}/profile/anniversaries'}  # type: ignore

    async def get_anniversary(
        self,
        user_id: str,
        person_anniversary_id: str,
        select: Optional[List[Union[str, "models.Enum31"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonAnniversary":
        """Get anniversaries from users.

        Get anniversaries from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_anniversary_id: key: id of personAnniversary.
        :type person_anniversary_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum31]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonAnniversary, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonAnniversary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonAnniversary"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_anniversary.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAnniversary-id': self._serialize.url("person_anniversary_id", person_anniversary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonAnniversary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_anniversary.metadata = {'url': '/users/{user-id}/profile/anniversaries/{personAnniversary-id}'}  # type: ignore

    async def update_anniversary(
        self,
        user_id: str,
        person_anniversary_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        date: Optional[datetime.date] = None,
        type: Optional[Union[str, "models.MicrosoftGraphAnniversaryType"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property anniversaries in users.

        Update the navigation property anniversaries in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_anniversary_id: key: id of personAnniversary.
        :type person_anniversary_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param date:
        :type date: ~datetime.date
        :param type:
        :type type: str or ~people.models.MicrosoftGraphAnniversaryType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonAnniversary(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, date=date, type=type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_anniversary.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAnniversary-id': self._serialize.url("person_anniversary_id", person_anniversary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonAnniversary')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_anniversary.metadata = {'url': '/users/{user-id}/profile/anniversaries/{personAnniversary-id}'}  # type: ignore

    async def delete_anniversary(
        self,
        user_id: str,
        person_anniversary_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property anniversaries for users.

        Delete navigation property anniversaries for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_anniversary_id: key: id of personAnniversary.
        :type person_anniversary_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_anniversary.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAnniversary-id': self._serialize.url("person_anniversary_id", person_anniversary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_anniversary.metadata = {'url': '/users/{user-id}/profile/anniversaries/{personAnniversary-id}'}  # type: ignore

    def list_award(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum32"]]] = None,
        select: Optional[List[Union[str, "models.Enum33"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonAward"]:
        """Get awards from users.

        Get awards from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum32]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum33]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonAward or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonAward]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonAward"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_award.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonAward', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_award.metadata = {'url': '/users/{user-id}/profile/awards'}  # type: ignore

    async def create_award(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        issued_date: Optional[datetime.date] = None,
        issuing_authority: Optional[str] = None,
        thumbnail_url: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonAward":
        """Create new navigation property to awards for users.

        Create new navigation property to awards for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param issued_date:
        :type issued_date: ~datetime.date
        :param issuing_authority:
        :type issuing_authority: str
        :param thumbnail_url:
        :type thumbnail_url: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonAward, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonAward
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonAward"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonAward(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, display_name=display_name, issued_date=issued_date, issuing_authority=issuing_authority, thumbnail_url=thumbnail_url, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_award.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonAward')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonAward', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_award.metadata = {'url': '/users/{user-id}/profile/awards'}  # type: ignore

    async def get_award(
        self,
        user_id: str,
        person_award_id: str,
        select: Optional[List[Union[str, "models.Enum34"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonAward":
        """Get awards from users.

        Get awards from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_award_id: key: id of personAward.
        :type person_award_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum34]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonAward, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonAward
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonAward"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_award.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAward-id': self._serialize.url("person_award_id", person_award_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonAward', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_award.metadata = {'url': '/users/{user-id}/profile/awards/{personAward-id}'}  # type: ignore

    async def update_award(
        self,
        user_id: str,
        person_award_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        issued_date: Optional[datetime.date] = None,
        issuing_authority: Optional[str] = None,
        thumbnail_url: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property awards in users.

        Update the navigation property awards in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_award_id: key: id of personAward.
        :type person_award_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param issued_date:
        :type issued_date: ~datetime.date
        :param issuing_authority:
        :type issuing_authority: str
        :param thumbnail_url:
        :type thumbnail_url: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonAward(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, display_name=display_name, issued_date=issued_date, issuing_authority=issuing_authority, thumbnail_url=thumbnail_url, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_award.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAward-id': self._serialize.url("person_award_id", person_award_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonAward')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_award.metadata = {'url': '/users/{user-id}/profile/awards/{personAward-id}'}  # type: ignore

    async def delete_award(
        self,
        user_id: str,
        person_award_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property awards for users.

        Delete navigation property awards for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_award_id: key: id of personAward.
        :type person_award_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_award.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAward-id': self._serialize.url("person_award_id", person_award_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_award.metadata = {'url': '/users/{user-id}/profile/awards/{personAward-id}'}  # type: ignore

    def list_certification(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum35"]]] = None,
        select: Optional[List[Union[str, "models.Enum36"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonCertification"]:
        """Get certifications from users.

        Get certifications from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum35]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum36]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonCertification or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonCertification]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonCertification"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_certification.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonCertification', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_certification.metadata = {'url': '/users/{user-id}/profile/certifications'}  # type: ignore

    async def create_certification(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        certification_id: Optional[str] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        end_date: Optional[datetime.date] = None,
        issued_date: Optional[datetime.date] = None,
        issuing_authority: Optional[str] = None,
        issuing_company: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        thumbnail_url: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonCertification":
        """Create new navigation property to certifications for users.

        Create new navigation property to certifications for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param certification_id:
        :type certification_id: str
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param end_date:
        :type end_date: ~datetime.date
        :param issued_date:
        :type issued_date: ~datetime.date
        :param issuing_authority:
        :type issuing_authority: str
        :param issuing_company:
        :type issuing_company: str
        :param start_date:
        :type start_date: ~datetime.date
        :param thumbnail_url:
        :type thumbnail_url: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonCertification, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonCertification
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonCertification"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonCertification(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, certification_id=certification_id, description=description, display_name=display_name, end_date=end_date, issued_date=issued_date, issuing_authority=issuing_authority, issuing_company=issuing_company, start_date=start_date, thumbnail_url=thumbnail_url, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_certification.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonCertification')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonCertification', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_certification.metadata = {'url': '/users/{user-id}/profile/certifications'}  # type: ignore

    async def get_certification(
        self,
        user_id: str,
        person_certification_id: str,
        select: Optional[List[Union[str, "models.Enum37"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonCertification":
        """Get certifications from users.

        Get certifications from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_certification_id: key: id of personCertification.
        :type person_certification_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum37]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonCertification, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonCertification
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonCertification"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_certification.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personCertification-id': self._serialize.url("person_certification_id", person_certification_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonCertification', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_certification.metadata = {'url': '/users/{user-id}/profile/certifications/{personCertification-id}'}  # type: ignore

    async def update_certification(
        self,
        user_id: str,
        person_certification_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        certification_id: Optional[str] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        end_date: Optional[datetime.date] = None,
        issued_date: Optional[datetime.date] = None,
        issuing_authority: Optional[str] = None,
        issuing_company: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        thumbnail_url: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property certifications in users.

        Update the navigation property certifications in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_certification_id: key: id of personCertification.
        :type person_certification_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param certification_id:
        :type certification_id: str
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param end_date:
        :type end_date: ~datetime.date
        :param issued_date:
        :type issued_date: ~datetime.date
        :param issuing_authority:
        :type issuing_authority: str
        :param issuing_company:
        :type issuing_company: str
        :param start_date:
        :type start_date: ~datetime.date
        :param thumbnail_url:
        :type thumbnail_url: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonCertification(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, certification_id=certification_id, description=description, display_name=display_name, end_date=end_date, issued_date=issued_date, issuing_authority=issuing_authority, issuing_company=issuing_company, start_date=start_date, thumbnail_url=thumbnail_url, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_certification.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personCertification-id': self._serialize.url("person_certification_id", person_certification_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonCertification')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_certification.metadata = {'url': '/users/{user-id}/profile/certifications/{personCertification-id}'}  # type: ignore

    async def delete_certification(
        self,
        user_id: str,
        person_certification_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property certifications for users.

        Delete navigation property certifications for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_certification_id: key: id of personCertification.
        :type person_certification_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_certification.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personCertification-id': self._serialize.url("person_certification_id", person_certification_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_certification.metadata = {'url': '/users/{user-id}/profile/certifications/{personCertification-id}'}  # type: ignore

    def list_educational_activity(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum38"]]] = None,
        select: Optional[List[Union[str, "models.Enum39"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEducationalActivity"]:
        """Get educationalActivities from users.

        Get educationalActivities from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum38]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum39]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationalActivity or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfEducationalActivity]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationalActivity"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_educational_activity.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationalActivity', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_educational_activity.metadata = {'url': '/users/{user-id}/profile/educationalActivities'}  # type: ignore

    async def create_educational_activity(
        self,
        user_id: str,
        body: "models.MicrosoftGraphEducationalActivity",
        **kwargs
    ) -> "models.MicrosoftGraphEducationalActivity":
        """Create new navigation property to educationalActivities for users.

        Create new navigation property to educationalActivities for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param body: New navigation property.
        :type body: ~people.models.MicrosoftGraphEducationalActivity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationalActivity, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphEducationalActivity
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationalActivity"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_educational_activity.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationalActivity')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationalActivity', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_educational_activity.metadata = {'url': '/users/{user-id}/profile/educationalActivities'}  # type: ignore

    async def get_educational_activity(
        self,
        user_id: str,
        educational_activity_id: str,
        select: Optional[List[Union[str, "models.Enum40"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationalActivity":
        """Get educationalActivities from users.

        Get educationalActivities from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param educational_activity_id: key: id of educationalActivity.
        :type educational_activity_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum40]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationalActivity, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphEducationalActivity
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationalActivity"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_educational_activity.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'educationalActivity-id': self._serialize.url("educational_activity_id", educational_activity_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationalActivity', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_educational_activity.metadata = {'url': '/users/{user-id}/profile/educationalActivities/{educationalActivity-id}'}  # type: ignore

    async def update_educational_activity(
        self,
        user_id: str,
        educational_activity_id: str,
        body: "models.MicrosoftGraphEducationalActivity",
        **kwargs
    ) -> None:
        """Update the navigation property educationalActivities in users.

        Update the navigation property educationalActivities in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param educational_activity_id: key: id of educationalActivity.
        :type educational_activity_id: str
        :param body: New navigation property values.
        :type body: ~people.models.MicrosoftGraphEducationalActivity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_educational_activity.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'educationalActivity-id': self._serialize.url("educational_activity_id", educational_activity_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationalActivity')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_educational_activity.metadata = {'url': '/users/{user-id}/profile/educationalActivities/{educationalActivity-id}'}  # type: ignore

    async def delete_educational_activity(
        self,
        user_id: str,
        educational_activity_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property educationalActivities for users.

        Delete navigation property educationalActivities for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param educational_activity_id: key: id of educationalActivity.
        :type educational_activity_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_educational_activity.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'educationalActivity-id': self._serialize.url("educational_activity_id", educational_activity_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_educational_activity.metadata = {'url': '/users/{user-id}/profile/educationalActivities/{educationalActivity-id}'}  # type: ignore

    def list_email(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum41"]]] = None,
        select: Optional[List[Union[str, "models.Enum42"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItemEmail"]:
        """Get emails from users.

        Get emails from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum41]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum42]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItemEmail or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfItemEmail]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItemEmail"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_email.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItemEmail', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_email.metadata = {'url': '/users/{user-id}/profile/emails'}  # type: ignore

    async def create_email(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        address: Optional[str] = None,
        display_name: Optional[str] = None,
        type: Optional[Union[str, "models.MicrosoftGraphEmailType"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemEmail":
        """Create new navigation property to emails for users.

        Create new navigation property to emails for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param address:
        :type address: str
        :param display_name:
        :type display_name: str
        :param type:
        :type type: str or ~people.models.MicrosoftGraphEmailType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemEmail, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemEmail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemEmail"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemEmail(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, address=address, display_name=display_name, type=type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_email.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemEmail')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemEmail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_email.metadata = {'url': '/users/{user-id}/profile/emails'}  # type: ignore

    async def get_email(
        self,
        user_id: str,
        item_email_id: str,
        select: Optional[List[Union[str, "models.Enum43"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemEmail":
        """Get emails from users.

        Get emails from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_email_id: key: id of itemEmail.
        :type item_email_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum43]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemEmail, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemEmail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemEmail"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_email.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemEmail-id': self._serialize.url("item_email_id", item_email_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemEmail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_email.metadata = {'url': '/users/{user-id}/profile/emails/{itemEmail-id}'}  # type: ignore

    async def update_email(
        self,
        user_id: str,
        item_email_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        address: Optional[str] = None,
        display_name: Optional[str] = None,
        type: Optional[Union[str, "models.MicrosoftGraphEmailType"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property emails in users.

        Update the navigation property emails in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_email_id: key: id of itemEmail.
        :type item_email_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param address:
        :type address: str
        :param display_name:
        :type display_name: str
        :param type:
        :type type: str or ~people.models.MicrosoftGraphEmailType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemEmail(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, address=address, display_name=display_name, type=type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_email.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemEmail-id': self._serialize.url("item_email_id", item_email_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemEmail')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_email.metadata = {'url': '/users/{user-id}/profile/emails/{itemEmail-id}'}  # type: ignore

    async def delete_email(
        self,
        user_id: str,
        item_email_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property emails for users.

        Delete navigation property emails for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_email_id: key: id of itemEmail.
        :type item_email_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_email.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemEmail-id': self._serialize.url("item_email_id", item_email_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_email.metadata = {'url': '/users/{user-id}/profile/emails/{itemEmail-id}'}  # type: ignore

    def list_interest(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum44"]]] = None,
        select: Optional[List[Union[str, "models.Enum45"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonInterest"]:
        """Get interests from users.

        Get interests from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum44]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum45]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonInterest or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonInterest]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonInterest"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_interest.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonInterest', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_interest.metadata = {'url': '/users/{user-id}/profile/interests'}  # type: ignore

    async def create_interest(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        collaboration_tags: Optional[List[str]] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonInterest":
        """Create new navigation property to interests for users.

        Create new navigation property to interests for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param collaboration_tags:
        :type collaboration_tags: list[str]
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonInterest, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonInterest
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonInterest"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonInterest(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, collaboration_tags=collaboration_tags, description=description, display_name=display_name, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_interest.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonInterest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonInterest', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_interest.metadata = {'url': '/users/{user-id}/profile/interests'}  # type: ignore

    async def get_interest(
        self,
        user_id: str,
        person_interest_id: str,
        select: Optional[List[Union[str, "models.Enum46"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonInterest":
        """Get interests from users.

        Get interests from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_interest_id: key: id of personInterest.
        :type person_interest_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum46]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonInterest, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonInterest
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonInterest"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_interest.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personInterest-id': self._serialize.url("person_interest_id", person_interest_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonInterest', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_interest.metadata = {'url': '/users/{user-id}/profile/interests/{personInterest-id}'}  # type: ignore

    async def update_interest(
        self,
        user_id: str,
        person_interest_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        collaboration_tags: Optional[List[str]] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property interests in users.

        Update the navigation property interests in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_interest_id: key: id of personInterest.
        :type person_interest_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param collaboration_tags:
        :type collaboration_tags: list[str]
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonInterest(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, collaboration_tags=collaboration_tags, description=description, display_name=display_name, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_interest.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personInterest-id': self._serialize.url("person_interest_id", person_interest_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonInterest')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_interest.metadata = {'url': '/users/{user-id}/profile/interests/{personInterest-id}'}  # type: ignore

    async def delete_interest(
        self,
        user_id: str,
        person_interest_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property interests for users.

        Delete navigation property interests for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_interest_id: key: id of personInterest.
        :type person_interest_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_interest.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personInterest-id': self._serialize.url("person_interest_id", person_interest_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_interest.metadata = {'url': '/users/{user-id}/profile/interests/{personInterest-id}'}  # type: ignore

    def list_language(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum47"]]] = None,
        select: Optional[List[Union[str, "models.Enum48"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfLanguageProficiency"]:
        """Get languages from users.

        Get languages from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum47]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum48]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfLanguageProficiency or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfLanguageProficiency]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfLanguageProficiency"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_language.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfLanguageProficiency', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_language.metadata = {'url': '/users/{user-id}/profile/languages'}  # type: ignore

    async def create_language(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        display_name: Optional[str] = None,
        proficiency: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        reading: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        spoken: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        tag: Optional[str] = None,
        written: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphLanguageProficiency":
        """Create new navigation property to languages for users.

        Create new navigation property to languages for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param display_name:
        :type display_name: str
        :param proficiency:
        :type proficiency: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :param reading:
        :type reading: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :param spoken:
        :type spoken: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :param tag:
        :type tag: str
        :param written:
        :type written: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphLanguageProficiency, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphLanguageProficiency
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphLanguageProficiency"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphLanguageProficiency(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, display_name=display_name, proficiency=proficiency, reading=reading, spoken=spoken, tag=tag, written=written)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_language.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphLanguageProficiency')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphLanguageProficiency', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_language.metadata = {'url': '/users/{user-id}/profile/languages'}  # type: ignore

    async def get_language(
        self,
        user_id: str,
        language_proficiency_id: str,
        select: Optional[List[Union[str, "models.Enum49"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphLanguageProficiency":
        """Get languages from users.

        Get languages from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param language_proficiency_id: key: id of languageProficiency.
        :type language_proficiency_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum49]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphLanguageProficiency, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphLanguageProficiency
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphLanguageProficiency"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_language.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'languageProficiency-id': self._serialize.url("language_proficiency_id", language_proficiency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphLanguageProficiency', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_language.metadata = {'url': '/users/{user-id}/profile/languages/{languageProficiency-id}'}  # type: ignore

    async def update_language(
        self,
        user_id: str,
        language_proficiency_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        display_name: Optional[str] = None,
        proficiency: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        reading: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        spoken: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        tag: Optional[str] = None,
        written: Optional[Union[str, "models.MicrosoftGraphLanguageProficiencyLevel"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property languages in users.

        Update the navigation property languages in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param language_proficiency_id: key: id of languageProficiency.
        :type language_proficiency_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param display_name:
        :type display_name: str
        :param proficiency:
        :type proficiency: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :param reading:
        :type reading: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :param spoken:
        :type spoken: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :param tag:
        :type tag: str
        :param written:
        :type written: str or ~people.models.MicrosoftGraphLanguageProficiencyLevel
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphLanguageProficiency(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, display_name=display_name, proficiency=proficiency, reading=reading, spoken=spoken, tag=tag, written=written)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_language.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'languageProficiency-id': self._serialize.url("language_proficiency_id", language_proficiency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphLanguageProficiency')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_language.metadata = {'url': '/users/{user-id}/profile/languages/{languageProficiency-id}'}  # type: ignore

    async def delete_language(
        self,
        user_id: str,
        language_proficiency_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property languages for users.

        Delete navigation property languages for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param language_proficiency_id: key: id of languageProficiency.
        :type language_proficiency_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_language.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'languageProficiency-id': self._serialize.url("language_proficiency_id", language_proficiency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_language.metadata = {'url': '/users/{user-id}/profile/languages/{languageProficiency-id}'}  # type: ignore

    def list_name(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum50"]]] = None,
        select: Optional[List[Union[str, "models.Enum51"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonName"]:
        """Get names from users.

        Get names from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum50]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum51]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonName or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonName]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonName"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_name.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonName', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_name.metadata = {'url': '/users/{user-id}/profile/names'}  # type: ignore

    async def create_name(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        display_name: Optional[str] = None,
        first: Optional[str] = None,
        initials: Optional[str] = None,
        language_tag: Optional[str] = None,
        last: Optional[str] = None,
        maiden: Optional[str] = None,
        middle: Optional[str] = None,
        nickname: Optional[str] = None,
        pronunciation: Optional["models.MicrosoftGraphYomiPersonName"] = None,
        suffix: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonName":
        """Create new navigation property to names for users.

        Create new navigation property to names for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param display_name:
        :type display_name: str
        :param first:
        :type first: str
        :param initials:
        :type initials: str
        :param language_tag:
        :type language_tag: str
        :param last:
        :type last: str
        :param maiden:
        :type maiden: str
        :param middle:
        :type middle: str
        :param nickname:
        :type nickname: str
        :param pronunciation: yomiPersonName.
        :type pronunciation: ~people.models.MicrosoftGraphYomiPersonName
        :param suffix:
        :type suffix: str
        :param title:
        :type title: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonName, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonName
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonName"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonName(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, display_name=display_name, first=first, initials=initials, language_tag=language_tag, last=last, maiden=maiden, middle=middle, nickname=nickname, pronunciation=pronunciation, suffix=suffix, title=title)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_name.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonName')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonName', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_name.metadata = {'url': '/users/{user-id}/profile/names'}  # type: ignore

    async def get_name(
        self,
        user_id: str,
        person_name_id: str,
        select: Optional[List[Union[str, "models.Enum52"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonName":
        """Get names from users.

        Get names from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_name_id: key: id of personName.
        :type person_name_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum52]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonName, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonName
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonName"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_name.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personName-id': self._serialize.url("person_name_id", person_name_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonName', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_name.metadata = {'url': '/users/{user-id}/profile/names/{personName-id}'}  # type: ignore

    async def update_name(
        self,
        user_id: str,
        person_name_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        display_name: Optional[str] = None,
        first: Optional[str] = None,
        initials: Optional[str] = None,
        language_tag: Optional[str] = None,
        last: Optional[str] = None,
        maiden: Optional[str] = None,
        middle: Optional[str] = None,
        nickname: Optional[str] = None,
        pronunciation: Optional["models.MicrosoftGraphYomiPersonName"] = None,
        suffix: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property names in users.

        Update the navigation property names in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_name_id: key: id of personName.
        :type person_name_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param display_name:
        :type display_name: str
        :param first:
        :type first: str
        :param initials:
        :type initials: str
        :param language_tag:
        :type language_tag: str
        :param last:
        :type last: str
        :param maiden:
        :type maiden: str
        :param middle:
        :type middle: str
        :param nickname:
        :type nickname: str
        :param pronunciation: yomiPersonName.
        :type pronunciation: ~people.models.MicrosoftGraphYomiPersonName
        :param suffix:
        :type suffix: str
        :param title:
        :type title: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonName(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, display_name=display_name, first=first, initials=initials, language_tag=language_tag, last=last, maiden=maiden, middle=middle, nickname=nickname, pronunciation=pronunciation, suffix=suffix, title=title)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_name.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personName-id': self._serialize.url("person_name_id", person_name_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonName')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_name.metadata = {'url': '/users/{user-id}/profile/names/{personName-id}'}  # type: ignore

    async def delete_name(
        self,
        user_id: str,
        person_name_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property names for users.

        Delete navigation property names for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_name_id: key: id of personName.
        :type person_name_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_name.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personName-id': self._serialize.url("person_name_id", person_name_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_name.metadata = {'url': '/users/{user-id}/profile/names/{personName-id}'}  # type: ignore

    def list_note(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum53"]]] = None,
        select: Optional[List[Union[str, "models.Enum54"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonAnnotation"]:
        """Get notes from users.

        Get notes from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum53]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum54]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonAnnotation or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonAnnotation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonAnnotation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_note.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonAnnotation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_note.metadata = {'url': '/users/{user-id}/profile/notes'}  # type: ignore

    async def create_note(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        detail: Optional["models.MicrosoftGraphItemBody"] = None,
        display_name: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonAnnotation":
        """Create new navigation property to notes for users.

        Create new navigation property to notes for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param detail: itemBody.
        :type detail: ~people.models.MicrosoftGraphItemBody
        :param display_name:
        :type display_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonAnnotation, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonAnnotation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonAnnotation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonAnnotation(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, detail=detail, display_name=display_name)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_note.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonAnnotation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonAnnotation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_note.metadata = {'url': '/users/{user-id}/profile/notes'}  # type: ignore

    async def get_note(
        self,
        user_id: str,
        person_annotation_id: str,
        select: Optional[List[Union[str, "models.Enum55"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonAnnotation":
        """Get notes from users.

        Get notes from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_annotation_id: key: id of personAnnotation.
        :type person_annotation_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum55]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonAnnotation, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonAnnotation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonAnnotation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_note.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAnnotation-id': self._serialize.url("person_annotation_id", person_annotation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonAnnotation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_note.metadata = {'url': '/users/{user-id}/profile/notes/{personAnnotation-id}'}  # type: ignore

    async def update_note(
        self,
        user_id: str,
        person_annotation_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        detail: Optional["models.MicrosoftGraphItemBody"] = None,
        display_name: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property notes in users.

        Update the navigation property notes in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_annotation_id: key: id of personAnnotation.
        :type person_annotation_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param detail: itemBody.
        :type detail: ~people.models.MicrosoftGraphItemBody
        :param display_name:
        :type display_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonAnnotation(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, detail=detail, display_name=display_name)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_note.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAnnotation-id': self._serialize.url("person_annotation_id", person_annotation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonAnnotation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_note.metadata = {'url': '/users/{user-id}/profile/notes/{personAnnotation-id}'}  # type: ignore

    async def delete_note(
        self,
        user_id: str,
        person_annotation_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property notes for users.

        Delete navigation property notes for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_annotation_id: key: id of personAnnotation.
        :type person_annotation_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_note.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personAnnotation-id': self._serialize.url("person_annotation_id", person_annotation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_note.metadata = {'url': '/users/{user-id}/profile/notes/{personAnnotation-id}'}  # type: ignore

    def list_patent(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum56"]]] = None,
        select: Optional[List[Union[str, "models.Enum57"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItemPatent"]:
        """Get patents from users.

        Get patents from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum56]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum57]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItemPatent or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfItemPatent]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItemPatent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_patent.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItemPatent', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_patent.metadata = {'url': '/users/{user-id}/profile/patents'}  # type: ignore

    async def create_patent(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        is_pending: Optional[bool] = None,
        issued_date: Optional[datetime.date] = None,
        issuing_authority: Optional[str] = None,
        number: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemPatent":
        """Create new navigation property to patents for users.

        Create new navigation property to patents for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param is_pending:
        :type is_pending: bool
        :param issued_date:
        :type issued_date: ~datetime.date
        :param issuing_authority:
        :type issuing_authority: str
        :param number:
        :type number: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemPatent, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemPatent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemPatent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemPatent(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, display_name=display_name, is_pending=is_pending, issued_date=issued_date, issuing_authority=issuing_authority, number=number, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_patent.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemPatent')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemPatent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_patent.metadata = {'url': '/users/{user-id}/profile/patents'}  # type: ignore

    async def get_patent(
        self,
        user_id: str,
        item_patent_id: str,
        select: Optional[List[Union[str, "models.Enum58"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemPatent":
        """Get patents from users.

        Get patents from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_patent_id: key: id of itemPatent.
        :type item_patent_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum58]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemPatent, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemPatent
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemPatent"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_patent.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPatent-id': self._serialize.url("item_patent_id", item_patent_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemPatent', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_patent.metadata = {'url': '/users/{user-id}/profile/patents/{itemPatent-id}'}  # type: ignore

    async def update_patent(
        self,
        user_id: str,
        item_patent_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        is_pending: Optional[bool] = None,
        issued_date: Optional[datetime.date] = None,
        issuing_authority: Optional[str] = None,
        number: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property patents in users.

        Update the navigation property patents in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_patent_id: key: id of itemPatent.
        :type item_patent_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param is_pending:
        :type is_pending: bool
        :param issued_date:
        :type issued_date: ~datetime.date
        :param issuing_authority:
        :type issuing_authority: str
        :param number:
        :type number: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemPatent(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, display_name=display_name, is_pending=is_pending, issued_date=issued_date, issuing_authority=issuing_authority, number=number, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_patent.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPatent-id': self._serialize.url("item_patent_id", item_patent_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemPatent')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_patent.metadata = {'url': '/users/{user-id}/profile/patents/{itemPatent-id}'}  # type: ignore

    async def delete_patent(
        self,
        user_id: str,
        item_patent_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property patents for users.

        Delete navigation property patents for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_patent_id: key: id of itemPatent.
        :type item_patent_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_patent.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPatent-id': self._serialize.url("item_patent_id", item_patent_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_patent.metadata = {'url': '/users/{user-id}/profile/patents/{itemPatent-id}'}  # type: ignore

    def list_phone(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum59"]]] = None,
        select: Optional[List[Union[str, "models.Enum60"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItemPhone"]:
        """Get phones from users.

        Get phones from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum59]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum60]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItemPhone or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfItemPhone]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItemPhone"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_phone.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItemPhone', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_phone.metadata = {'url': '/users/{user-id}/profile/phones'}  # type: ignore

    async def create_phone(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        display_name: Optional[str] = None,
        number: Optional[str] = None,
        type: Optional[Union[str, "models.MicrosoftGraphPhoneType"]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemPhone":
        """Create new navigation property to phones for users.

        Create new navigation property to phones for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param display_name:
        :type display_name: str
        :param number:
        :type number: str
        :param type:
        :type type: str or ~people.models.MicrosoftGraphPhoneType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemPhone, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemPhone
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemPhone"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemPhone(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, display_name=display_name, number=number, type=type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_phone.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemPhone')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemPhone', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_phone.metadata = {'url': '/users/{user-id}/profile/phones'}  # type: ignore

    async def get_phone(
        self,
        user_id: str,
        item_phone_id: str,
        select: Optional[List[Union[str, "models.Enum61"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemPhone":
        """Get phones from users.

        Get phones from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_phone_id: key: id of itemPhone.
        :type item_phone_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum61]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemPhone, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemPhone
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemPhone"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_phone.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPhone-id': self._serialize.url("item_phone_id", item_phone_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemPhone', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_phone.metadata = {'url': '/users/{user-id}/profile/phones/{itemPhone-id}'}  # type: ignore

    async def update_phone(
        self,
        user_id: str,
        item_phone_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        display_name: Optional[str] = None,
        number: Optional[str] = None,
        type: Optional[Union[str, "models.MicrosoftGraphPhoneType"]] = None,
        **kwargs
    ) -> None:
        """Update the navigation property phones in users.

        Update the navigation property phones in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_phone_id: key: id of itemPhone.
        :type item_phone_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param display_name:
        :type display_name: str
        :param number:
        :type number: str
        :param type:
        :type type: str or ~people.models.MicrosoftGraphPhoneType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemPhone(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, display_name=display_name, number=number, type=type)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_phone.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPhone-id': self._serialize.url("item_phone_id", item_phone_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemPhone')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_phone.metadata = {'url': '/users/{user-id}/profile/phones/{itemPhone-id}'}  # type: ignore

    async def delete_phone(
        self,
        user_id: str,
        item_phone_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property phones for users.

        Delete navigation property phones for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_phone_id: key: id of itemPhone.
        :type item_phone_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_phone.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPhone-id': self._serialize.url("item_phone_id", item_phone_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_phone.metadata = {'url': '/users/{user-id}/profile/phones/{itemPhone-id}'}  # type: ignore

    def list_position(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum62"]]] = None,
        select: Optional[List[Union[str, "models.Enum63"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfWorkPosition"]:
        """Get positions from users.

        Get positions from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum62]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum63]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfWorkPosition or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfWorkPosition]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfWorkPosition"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_position.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfWorkPosition', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_position.metadata = {'url': '/users/{user-id}/profile/positions'}  # type: ignore

    async def create_position(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        colleagues: Optional[List["models.MicrosoftGraphRelatedPerson"]] = None,
        is_current: Optional[bool] = None,
        manager: Optional["models.MicrosoftGraphRelatedPerson"] = None,
        company: Optional["models.MicrosoftGraphCompanyDetail"] = None,
        description: Optional[str] = None,
        end_month_year: Optional[datetime.date] = None,
        job_title: Optional[str] = None,
        role: Optional[str] = None,
        start_month_year: Optional[datetime.date] = None,
        summary: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphWorkPosition":
        """Create new navigation property to positions for users.

        Create new navigation property to positions for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param colleagues:
        :type colleagues: list[~people.models.MicrosoftGraphRelatedPerson]
        :param is_current:
        :type is_current: bool
        :param manager: relatedPerson.
        :type manager: ~people.models.MicrosoftGraphRelatedPerson
        :param company: companyDetail.
        :type company: ~people.models.MicrosoftGraphCompanyDetail
        :param description:
        :type description: str
        :param end_month_year:
        :type end_month_year: ~datetime.date
        :param job_title:
        :type job_title: str
        :param role:
        :type role: str
        :param start_month_year:
        :type start_month_year: ~datetime.date
        :param summary:
        :type summary: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphWorkPosition, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphWorkPosition
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphWorkPosition"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphWorkPosition(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, colleagues=colleagues, is_current=is_current, manager=manager, company=company, description=description, end_month_year=end_month_year, job_title=job_title, role=role, start_month_year=start_month_year, summary=summary)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_position.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphWorkPosition')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphWorkPosition', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_position.metadata = {'url': '/users/{user-id}/profile/positions'}  # type: ignore

    async def get_position(
        self,
        user_id: str,
        work_position_id: str,
        select: Optional[List[Union[str, "models.Enum64"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphWorkPosition":
        """Get positions from users.

        Get positions from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param work_position_id: key: id of workPosition.
        :type work_position_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum64]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphWorkPosition, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphWorkPosition
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphWorkPosition"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_position.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'workPosition-id': self._serialize.url("work_position_id", work_position_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphWorkPosition', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_position.metadata = {'url': '/users/{user-id}/profile/positions/{workPosition-id}'}  # type: ignore

    async def update_position(
        self,
        user_id: str,
        work_position_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        colleagues: Optional[List["models.MicrosoftGraphRelatedPerson"]] = None,
        is_current: Optional[bool] = None,
        manager: Optional["models.MicrosoftGraphRelatedPerson"] = None,
        company: Optional["models.MicrosoftGraphCompanyDetail"] = None,
        description: Optional[str] = None,
        end_month_year: Optional[datetime.date] = None,
        job_title: Optional[str] = None,
        role: Optional[str] = None,
        start_month_year: Optional[datetime.date] = None,
        summary: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property positions in users.

        Update the navigation property positions in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param work_position_id: key: id of workPosition.
        :type work_position_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param colleagues:
        :type colleagues: list[~people.models.MicrosoftGraphRelatedPerson]
        :param is_current:
        :type is_current: bool
        :param manager: relatedPerson.
        :type manager: ~people.models.MicrosoftGraphRelatedPerson
        :param company: companyDetail.
        :type company: ~people.models.MicrosoftGraphCompanyDetail
        :param description:
        :type description: str
        :param end_month_year:
        :type end_month_year: ~datetime.date
        :param job_title:
        :type job_title: str
        :param role:
        :type role: str
        :param start_month_year:
        :type start_month_year: ~datetime.date
        :param summary:
        :type summary: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphWorkPosition(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, colleagues=colleagues, is_current=is_current, manager=manager, company=company, description=description, end_month_year=end_month_year, job_title=job_title, role=role, start_month_year=start_month_year, summary=summary)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_position.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'workPosition-id': self._serialize.url("work_position_id", work_position_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphWorkPosition')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_position.metadata = {'url': '/users/{user-id}/profile/positions/{workPosition-id}'}  # type: ignore

    async def delete_position(
        self,
        user_id: str,
        work_position_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property positions for users.

        Delete navigation property positions for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param work_position_id: key: id of workPosition.
        :type work_position_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_position.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'workPosition-id': self._serialize.url("work_position_id", work_position_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_position.metadata = {'url': '/users/{user-id}/profile/positions/{workPosition-id}'}  # type: ignore

    def list_project(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum65"]]] = None,
        select: Optional[List[Union[str, "models.Enum66"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfProjectParticipation"]:
        """Get projects from users.

        Get projects from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum65]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum66]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfProjectParticipation or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfProjectParticipation]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfProjectParticipation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_project.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfProjectParticipation', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_project.metadata = {'url': '/users/{user-id}/profile/projects'}  # type: ignore

    async def create_project(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        collaboration_tags: Optional[List[str]] = None,
        colleagues: Optional[List["models.MicrosoftGraphRelatedPerson"]] = None,
        display_name: Optional[str] = None,
        sponsors: Optional[List["models.MicrosoftGraphRelatedPerson"]] = None,
        company: Optional["models.MicrosoftGraphCompanyDetail"] = None,
        description: Optional[str] = None,
        end_month_year: Optional[datetime.date] = None,
        job_title: Optional[str] = None,
        role: Optional[str] = None,
        start_month_year: Optional[datetime.date] = None,
        summary: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        department: Optional[str] = None,
        microsoft_graph_company_detail_display_name: Optional[str] = None,
        office_location: Optional[str] = None,
        pronunciation: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphProjectParticipation":
        """Create new navigation property to projects for users.

        Create new navigation property to projects for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param collaboration_tags:
        :type collaboration_tags: list[str]
        :param colleagues:
        :type colleagues: list[~people.models.MicrosoftGraphRelatedPerson]
        :param display_name:
        :type display_name: str
        :param sponsors:
        :type sponsors: list[~people.models.MicrosoftGraphRelatedPerson]
        :param company: companyDetail.
        :type company: ~people.models.MicrosoftGraphCompanyDetail
        :param description:
        :type description: str
        :param end_month_year:
        :type end_month_year: ~datetime.date
        :param job_title:
        :type job_title: str
        :param role:
        :type role: str
        :param start_month_year:
        :type start_month_year: ~datetime.date
        :param summary:
        :type summary: str
        :param address: physicalAddress.
        :type address: ~people.models.MicrosoftGraphPhysicalAddress
        :param department:
        :type department: str
        :param microsoft_graph_company_detail_display_name:
        :type microsoft_graph_company_detail_display_name: str
        :param office_location:
        :type office_location: str
        :param pronunciation:
        :type pronunciation: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphProjectParticipation, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphProjectParticipation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphProjectParticipation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphProjectParticipation(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, collaboration_tags=collaboration_tags, colleagues=colleagues, display_name=display_name, sponsors=sponsors, company=company, description=description, end_month_year=end_month_year, job_title=job_title, role=role, start_month_year=start_month_year, summary=summary, address=address, department=department, display_name_client_display_name=microsoft_graph_company_detail_display_name, office_location=office_location, pronunciation=pronunciation, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphProjectParticipation')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphProjectParticipation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project.metadata = {'url': '/users/{user-id}/profile/projects'}  # type: ignore

    async def get_project(
        self,
        user_id: str,
        project_participation_id: str,
        select: Optional[List[Union[str, "models.Enum67"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphProjectParticipation":
        """Get projects from users.

        Get projects from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param project_participation_id: key: id of projectParticipation.
        :type project_participation_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum67]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphProjectParticipation, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphProjectParticipation
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphProjectParticipation"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'projectParticipation-id': self._serialize.url("project_participation_id", project_participation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphProjectParticipation', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project.metadata = {'url': '/users/{user-id}/profile/projects/{projectParticipation-id}'}  # type: ignore

    async def update_project(
        self,
        user_id: str,
        project_participation_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        collaboration_tags: Optional[List[str]] = None,
        colleagues: Optional[List["models.MicrosoftGraphRelatedPerson"]] = None,
        display_name: Optional[str] = None,
        sponsors: Optional[List["models.MicrosoftGraphRelatedPerson"]] = None,
        company: Optional["models.MicrosoftGraphCompanyDetail"] = None,
        description: Optional[str] = None,
        end_month_year: Optional[datetime.date] = None,
        job_title: Optional[str] = None,
        role: Optional[str] = None,
        start_month_year: Optional[datetime.date] = None,
        summary: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        department: Optional[str] = None,
        microsoft_graph_company_detail_display_name: Optional[str] = None,
        office_location: Optional[str] = None,
        pronunciation: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property projects in users.

        Update the navigation property projects in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param project_participation_id: key: id of projectParticipation.
        :type project_participation_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param collaboration_tags:
        :type collaboration_tags: list[str]
        :param colleagues:
        :type colleagues: list[~people.models.MicrosoftGraphRelatedPerson]
        :param display_name:
        :type display_name: str
        :param sponsors:
        :type sponsors: list[~people.models.MicrosoftGraphRelatedPerson]
        :param company: companyDetail.
        :type company: ~people.models.MicrosoftGraphCompanyDetail
        :param description:
        :type description: str
        :param end_month_year:
        :type end_month_year: ~datetime.date
        :param job_title:
        :type job_title: str
        :param role:
        :type role: str
        :param start_month_year:
        :type start_month_year: ~datetime.date
        :param summary:
        :type summary: str
        :param address: physicalAddress.
        :type address: ~people.models.MicrosoftGraphPhysicalAddress
        :param department:
        :type department: str
        :param microsoft_graph_company_detail_display_name:
        :type microsoft_graph_company_detail_display_name: str
        :param office_location:
        :type office_location: str
        :param pronunciation:
        :type pronunciation: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphProjectParticipation(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, collaboration_tags=collaboration_tags, colleagues=colleagues, display_name=display_name, sponsors=sponsors, company=company, description=description, end_month_year=end_month_year, job_title=job_title, role=role, start_month_year=start_month_year, summary=summary, address=address, department=department, display_name_client_display_name=microsoft_graph_company_detail_display_name, office_location=office_location, pronunciation=pronunciation, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'projectParticipation-id': self._serialize.url("project_participation_id", project_participation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphProjectParticipation')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_project.metadata = {'url': '/users/{user-id}/profile/projects/{projectParticipation-id}'}  # type: ignore

    async def delete_project(
        self,
        user_id: str,
        project_participation_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property projects for users.

        Delete navigation property projects for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param project_participation_id: key: id of projectParticipation.
        :type project_participation_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'projectParticipation-id': self._serialize.url("project_participation_id", project_participation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_project.metadata = {'url': '/users/{user-id}/profile/projects/{projectParticipation-id}'}  # type: ignore

    def list_publication(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum68"]]] = None,
        select: Optional[List[Union[str, "models.Enum69"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfItemPublication"]:
        """Get publications from users.

        Get publications from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum68]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum69]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfItemPublication or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfItemPublication]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfItemPublication"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_publication.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfItemPublication', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_publication.metadata = {'url': '/users/{user-id}/profile/publications'}  # type: ignore

    async def create_publication(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        published_date: Optional[datetime.date] = None,
        publisher: Optional[str] = None,
        thumbnail_url: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemPublication":
        """Create new navigation property to publications for users.

        Create new navigation property to publications for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param published_date:
        :type published_date: ~datetime.date
        :param publisher:
        :type publisher: str
        :param thumbnail_url:
        :type thumbnail_url: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemPublication, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemPublication
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemPublication"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemPublication(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, display_name=display_name, published_date=published_date, publisher=publisher, thumbnail_url=thumbnail_url, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_publication.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemPublication')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemPublication', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_publication.metadata = {'url': '/users/{user-id}/profile/publications'}  # type: ignore

    async def get_publication(
        self,
        user_id: str,
        item_publication_id: str,
        select: Optional[List[Union[str, "models.Enum70"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphItemPublication":
        """Get publications from users.

        Get publications from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_publication_id: key: id of itemPublication.
        :type item_publication_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum70]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphItemPublication, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphItemPublication
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphItemPublication"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_publication.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPublication-id': self._serialize.url("item_publication_id", item_publication_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphItemPublication', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_publication.metadata = {'url': '/users/{user-id}/profile/publications/{itemPublication-id}'}  # type: ignore

    async def update_publication(
        self,
        user_id: str,
        item_publication_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        published_date: Optional[datetime.date] = None,
        publisher: Optional[str] = None,
        thumbnail_url: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property publications in users.

        Update the navigation property publications in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_publication_id: key: id of itemPublication.
        :type item_publication_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param published_date:
        :type published_date: ~datetime.date
        :param publisher:
        :type publisher: str
        :param thumbnail_url:
        :type thumbnail_url: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphItemPublication(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, display_name=display_name, published_date=published_date, publisher=publisher, thumbnail_url=thumbnail_url, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_publication.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPublication-id': self._serialize.url("item_publication_id", item_publication_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphItemPublication')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_publication.metadata = {'url': '/users/{user-id}/profile/publications/{itemPublication-id}'}  # type: ignore

    async def delete_publication(
        self,
        user_id: str,
        item_publication_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property publications for users.

        Delete navigation property publications for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param item_publication_id: key: id of itemPublication.
        :type item_publication_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_publication.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'itemPublication-id': self._serialize.url("item_publication_id", item_publication_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_publication.metadata = {'url': '/users/{user-id}/profile/publications/{itemPublication-id}'}  # type: ignore

    def list_skill(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum71"]]] = None,
        select: Optional[List[Union[str, "models.Enum72"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfSkillProficiency"]:
        """Get skills from users.

        Get skills from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum71]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum72]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfSkillProficiency or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfSkillProficiency]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfSkillProficiency"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_skill.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfSkillProficiency', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_skill.metadata = {'url': '/users/{user-id}/profile/skills'}  # type: ignore

    async def create_skill(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        collaboration_tags: Optional[List[str]] = None,
        display_name: Optional[str] = None,
        proficiency: Optional[Union[str, "models.MicrosoftGraphSkillProficiencyLevel"]] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSkillProficiency":
        """Create new navigation property to skills for users.

        Create new navigation property to skills for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param collaboration_tags:
        :type collaboration_tags: list[str]
        :param display_name:
        :type display_name: str
        :param proficiency:
        :type proficiency: str or ~people.models.MicrosoftGraphSkillProficiencyLevel
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSkillProficiency, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphSkillProficiency
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSkillProficiency"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSkillProficiency(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, collaboration_tags=collaboration_tags, display_name=display_name, proficiency=proficiency, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_skill.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSkillProficiency')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSkillProficiency', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_skill.metadata = {'url': '/users/{user-id}/profile/skills'}  # type: ignore

    async def get_skill(
        self,
        user_id: str,
        skill_proficiency_id: str,
        select: Optional[List[Union[str, "models.Enum73"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphSkillProficiency":
        """Get skills from users.

        Get skills from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param skill_proficiency_id: key: id of skillProficiency.
        :type skill_proficiency_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum73]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphSkillProficiency, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphSkillProficiency
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphSkillProficiency"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_skill.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'skillProficiency-id': self._serialize.url("skill_proficiency_id", skill_proficiency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphSkillProficiency', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_skill.metadata = {'url': '/users/{user-id}/profile/skills/{skillProficiency-id}'}  # type: ignore

    async def update_skill(
        self,
        user_id: str,
        skill_proficiency_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        collaboration_tags: Optional[List[str]] = None,
        display_name: Optional[str] = None,
        proficiency: Optional[Union[str, "models.MicrosoftGraphSkillProficiencyLevel"]] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property skills in users.

        Update the navigation property skills in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param skill_proficiency_id: key: id of skillProficiency.
        :type skill_proficiency_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param collaboration_tags:
        :type collaboration_tags: list[str]
        :param display_name:
        :type display_name: str
        :param proficiency:
        :type proficiency: str or ~people.models.MicrosoftGraphSkillProficiencyLevel
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphSkillProficiency(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, collaboration_tags=collaboration_tags, display_name=display_name, proficiency=proficiency, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_skill.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'skillProficiency-id': self._serialize.url("skill_proficiency_id", skill_proficiency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphSkillProficiency')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_skill.metadata = {'url': '/users/{user-id}/profile/skills/{skillProficiency-id}'}  # type: ignore

    async def delete_skill(
        self,
        user_id: str,
        skill_proficiency_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property skills for users.

        Delete navigation property skills for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param skill_proficiency_id: key: id of skillProficiency.
        :type skill_proficiency_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_skill.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'skillProficiency-id': self._serialize.url("skill_proficiency_id", skill_proficiency_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_skill.metadata = {'url': '/users/{user-id}/profile/skills/{skillProficiency-id}'}  # type: ignore

    def list_web_account(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum74"]]] = None,
        select: Optional[List[Union[str, "models.Enum75"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfWebAccount"]:
        """Get webAccounts from users.

        Get webAccounts from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum74]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum75]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfWebAccount or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfWebAccount]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfWebAccount"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_web_account.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfWebAccount', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_web_account.metadata = {'url': '/users/{user-id}/profile/webAccounts'}  # type: ignore

    async def create_web_account(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        service: Optional["models.MicrosoftGraphServiceInformation"] = None,
        status_message: Optional[str] = None,
        microsoft_graph_web_account_user_id: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphWebAccount":
        """Create new navigation property to webAccounts for users.

        Create new navigation property to webAccounts for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param service: serviceInformation.
        :type service: ~people.models.MicrosoftGraphServiceInformation
        :param status_message:
        :type status_message: str
        :param microsoft_graph_web_account_user_id:
        :type microsoft_graph_web_account_user_id: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphWebAccount, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphWebAccount
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphWebAccount"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphWebAccount(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, service=service, status_message=status_message, user_id=microsoft_graph_web_account_user_id, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_web_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphWebAccount')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphWebAccount', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_web_account.metadata = {'url': '/users/{user-id}/profile/webAccounts'}  # type: ignore

    async def get_web_account(
        self,
        user_id: str,
        web_account_id: str,
        select: Optional[List[Union[str, "models.Enum76"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphWebAccount":
        """Get webAccounts from users.

        Get webAccounts from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param web_account_id: key: id of webAccount.
        :type web_account_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum76]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphWebAccount, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphWebAccount
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphWebAccount"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_web_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'webAccount-id': self._serialize.url("web_account_id", web_account_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphWebAccount', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_web_account.metadata = {'url': '/users/{user-id}/profile/webAccounts/{webAccount-id}'}  # type: ignore

    async def update_web_account(
        self,
        user_id: str,
        web_account_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        description: Optional[str] = None,
        service: Optional["models.MicrosoftGraphServiceInformation"] = None,
        status_message: Optional[str] = None,
        microsoft_graph_web_account_user_id: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property webAccounts in users.

        Update the navigation property webAccounts in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param web_account_id: key: id of webAccount.
        :type web_account_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param description:
        :type description: str
        :param service: serviceInformation.
        :type service: ~people.models.MicrosoftGraphServiceInformation
        :param status_message:
        :type status_message: str
        :param microsoft_graph_web_account_user_id:
        :type microsoft_graph_web_account_user_id: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphWebAccount(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, description=description, service=service, status_message=status_message, user_id=microsoft_graph_web_account_user_id, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_web_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'webAccount-id': self._serialize.url("web_account_id", web_account_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphWebAccount')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_web_account.metadata = {'url': '/users/{user-id}/profile/webAccounts/{webAccount-id}'}  # type: ignore

    async def delete_web_account(
        self,
        user_id: str,
        web_account_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property webAccounts for users.

        Delete navigation property webAccounts for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param web_account_id: key: id of webAccount.
        :type web_account_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_web_account.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'webAccount-id': self._serialize.url("web_account_id", web_account_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_web_account.metadata = {'url': '/users/{user-id}/profile/webAccounts/{webAccount-id}'}  # type: ignore

    def list_website(
        self,
        user_id: str,
        orderby: Optional[List[Union[str, "models.Enum77"]]] = None,
        select: Optional[List[Union[str, "models.Enum78"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfPersonWebsite"]:
        """Get websites from users.

        Get websites from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param orderby: Order items by property values.
        :type orderby: list[str or ~people.models.Enum77]
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum78]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfPersonWebsite or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~people.models.CollectionOfPersonWebsite]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfPersonWebsite"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
            header_parameters['Accept'] = 'application/json'

            if not next_link:
                # Construct URL
                url = self.list_website.metadata['url']  # type: ignore
                path_format_arguments = {
                    'user-id': self._serialize.url("user_id", user_id, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfPersonWebsite', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_website.metadata = {'url': '/users/{user-id}/profile/websites'}  # type: ignore

    async def create_website(
        self,
        user_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonWebsite":
        """Create new navigation property to websites for users.

        Create new navigation property to websites for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonWebsite, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonWebsite
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonWebsite"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonWebsite(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, description=description, display_name=display_name, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_website.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonWebsite')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonWebsite', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_website.metadata = {'url': '/users/{user-id}/profile/websites'}  # type: ignore

    async def get_website(
        self,
        user_id: str,
        person_website_id: str,
        select: Optional[List[Union[str, "models.Enum79"]]] = None,
        expand: Optional[List[str]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphPersonWebsite":
        """Get websites from users.

        Get websites from users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_website_id: key: id of personWebsite.
        :type person_website_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~people.models.Enum79]
        :param expand: Expand related entities.
        :type expand: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphPersonWebsite, or the result of cls(response)
        :rtype: ~people.models.MicrosoftGraphPersonWebsite
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphPersonWebsite"]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_website.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personWebsite-id': self._serialize.url("person_website_id", person_website_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')
        header_parameters['Accept'] = 'application/json'

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphPersonWebsite', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_website.metadata = {'url': '/users/{user-id}/profile/websites/{personWebsite-id}'}  # type: ignore

    async def update_website(
        self,
        user_id: str,
        person_website_id: str,
        id: Optional[str] = None,
        allowed_audiences: Optional[Union[str, "models.MicrosoftGraphAllowedAudiences"]] = None,
        created_date_time: Optional[datetime.datetime] = None,
        inference: Optional["models.MicrosoftGraphInferenceData"] = None,
        last_modified_date_time: Optional[datetime.datetime] = None,
        source: Optional["models.MicrosoftGraphPersonDataSources"] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_application: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        categories: Optional[List[str]] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        web_url: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the navigation property websites in users.

        Update the navigation property websites in users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_website_id: key: id of personWebsite.
        :type person_website_id: str
        :param id: Read-only.
        :type id: str
        :param allowed_audiences:
        :type allowed_audiences: str or ~people.models.MicrosoftGraphAllowedAudiences
        :param created_date_time:
        :type created_date_time: ~datetime.datetime
        :param inference: inferenceData.
        :type inference: ~people.models.MicrosoftGraphInferenceData
        :param last_modified_date_time:
        :type last_modified_date_time: ~datetime.datetime
        :param source: personDataSources.
        :type source: ~people.models.MicrosoftGraphPersonDataSources
        :param application: identity.
        :type application: ~people.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~people.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_application: identity.
        :type microsoft_graph_identity_application: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_device: identity.
        :type microsoft_graph_identity_device: ~people.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~people.models.MicrosoftGraphIdentity
        :param categories:
        :type categories: list[str]
        :param description:
        :type description: str
        :param display_name:
        :type display_name: str
        :param web_url:
        :type web_url: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))

        _body = models.MicrosoftGraphPersonWebsite(id=id, allowed_audiences=allowed_audiences, created_date_time=created_date_time, inference=inference, last_modified_date_time=last_modified_date_time, source=source, application_last_modified_by_application=application, device_last_modified_by_device=device, user_last_modified_by_user=user, application_created_by_application=microsoft_graph_identity_application, device_created_by_device=microsoft_graph_identity_device, user_created_by_user=microsoft_graph_identity_user, categories=categories, description=description, display_name=display_name, web_url=web_url)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_website.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personWebsite-id': self._serialize.url("person_website_id", person_website_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'MicrosoftGraphPersonWebsite')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_website.metadata = {'url': '/users/{user-id}/profile/websites/{personWebsite-id}'}  # type: ignore

    async def delete_website(
        self,
        user_id: str,
        person_website_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property websites for users.

        Delete navigation property websites for users.

        :param user_id: key: id of user.
        :type user_id: str
        :param person_website_id: key: id of personWebsite.
        :type person_website_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {404: ResourceNotFoundError, 409: ResourceExistsError}
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_website.metadata['url']  # type: ignore
        path_format_arguments = {
            'user-id': self._serialize.url("user_id", user_id, 'str'),
            'personWebsite-id': self._serialize.url("person_website_id", person_website_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_website.metadata = {'url': '/users/{user-id}/profile/websites/{personWebsite-id}'}  # type: ignore
