# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddEmailAddresses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEmailAddresses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'address':
                d['address'] = v[0]
            elif kl == 'rank':
                d['rank'] = v[0]
        return d


class AddPeopleUserCreatePersonPhones(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserCreatePersonPhones, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'number':
                d['number'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
        return d


class AddSources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
        return d


class AddPeopleUserCreatePersonWebsites(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserCreatePersonWebsites, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'address':
                d['address'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
        return d


class AddSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'has-graph-mailbox':
                d['has_graph_mailbox'] = v[0]
            elif kl == 'has-license':
                d['has_license'] = v[0]
            elif kl == 'has-opted-out':
                d['has_opted_out'] = v[0]
        return d


class AddActivityStatistics(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddActivityStatistics, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'activity':
                d['activity'] = v[0]
            elif kl == 'duration':
                d['duration'] = v[0]
            elif kl == 'end-date':
                d['end_date'] = v[0]
            elif kl == 'start-date':
                d['start_date'] = v[0]
            elif kl == 'time-zone-used':
                d['time_zone_used'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddAnniversaries(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAnniversaries, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'date':
                d['date'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddAwards(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAwards, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'issued-date':
                d['issued_date'] = v[0]
            elif kl == 'issuing-authority':
                d['issuing_authority'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddCertifications(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCertifications, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'certification-id':
                d['certification_id'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date':
                d['end_date'] = v[0]
            elif kl == 'issued-date':
                d['issued_date'] = v[0]
            elif kl == 'issuing-authority':
                d['issuing_authority'] = v[0]
            elif kl == 'issuing-company':
                d['issuing_company'] = v[0]
            elif kl == 'start-date':
                d['start_date'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddEmails(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEmails, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'address':
                d['address'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddInterests(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddInterests, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'categories':
                d['categories'] = v
            elif kl == 'collaboration-tags':
                d['collaboration_tags'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddLanguages(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddLanguages, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'proficiency':
                d['proficiency'] = v[0]
            elif kl == 'reading':
                d['reading'] = v[0]
            elif kl == 'spoken':
                d['spoken'] = v[0]
            elif kl == 'tag':
                d['tag'] = v[0]
            elif kl == 'written':
                d['written'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddPatents(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPatents, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'is-pending':
                d['is_pending'] = v[0]
            elif kl == 'issued-date':
                d['issued_date'] = v[0]
            elif kl == 'issuing-authority':
                d['issuing_authority'] = v[0]
            elif kl == 'number':
                d['number'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddPeopleUserUpdateProfilePhones(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserUpdateProfilePhones, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'number':
                d['number'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddPublications(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPublications, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'published-date':
                d['published_date'] = v[0]
            elif kl == 'publisher':
                d['publisher'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddSkills(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSkills, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'categories':
                d['categories'] = v
            elif kl == 'collaboration-tags':
                d['collaboration_tags'] = v
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'proficiency':
                d['proficiency'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddPeopleUserUpdateProfileWebsites(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserUpdateProfileWebsites, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'categories':
                d['categories'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application_last_modified_by_application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device_last_modified_by_device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user_last_modified_by_user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application_created_by_application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device_created_by_device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user_created_by_user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddInference(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.inference = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'confidence-score':
                d['confidence_score'] = v[0]
            elif kl == 'user-has-verified-accuracy':
                d['user_has_verified_accuracy'] = v[0]
        return d


class AddSource(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.source = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v
        return d


class AddLastModifiedByApplication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.last_modified_by_application = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
        return d


class AddPreferredLanguageTag(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.preferred_language_tag = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'locale':
                d['locale'] = v[0]
        return d


class AddPeopleUserProfileCreateAddressDetail(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.detail = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'city':
                d['city'] = v[0]
            elif kl == 'country-or-region':
                d['country_or_region'] = v[0]
            elif kl == 'postal-code':
                d['postal_code'] = v[0]
            elif kl == 'post-office-box':
                d['post_office_box'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'street':
                d['street'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
        return d


class AddGeoCoordinates(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.geo_coordinates = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'altitude':
                d['altitude'] = v[0]
            elif kl == 'latitude':
                d['latitude'] = v[0]
            elif kl == 'longitude':
                d['longitude'] = v[0]
        return d


class AddProgram(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.program = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'abbreviation':
                d['abbreviation'] = v[0]
            elif kl == 'activities':
                d['activities'] = v
            elif kl == 'awards':
                d['awards'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'fields-of-study':
                d['fields_of_study'] = v
            elif kl == 'grade':
                d['grade'] = v[0]
            elif kl == 'notes':
                d['notes'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
        return d


class AddPronunciation(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.pronunciation = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'first':
                d['first'] = v[0]
            elif kl == 'last':
                d['last'] = v[0]
            elif kl == 'maiden':
                d['maiden'] = v[0]
            elif kl == 'middle':
                d['middle'] = v[0]
        return d


class AddPeopleUserProfileCreateNoteDetail(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.detail = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content':
                d['content'] = v[0]
            elif kl == 'content-type':
                d['content_type'] = v[0]
        return d


class AddPeopleUserProfileCreatePositionColleagues(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserProfileCreatePositionColleagues, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
        return d


class AddManager(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.manager = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
        return d


class AddPeopleUserProfileCreateProjectColleagues(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserProfileCreateProjectColleagues, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
        return d


class AddSponsors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSponsors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
        return d


class AddService(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.service = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
        return d
