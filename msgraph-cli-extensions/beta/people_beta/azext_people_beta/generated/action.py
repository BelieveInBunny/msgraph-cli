# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddEmailAddresses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEmailAddresses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'address':
                d['address'] = v[0]
            elif kl == 'rank':
                d['rank'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter email_addresses. All possible keys are: '
                               'address, rank'.format(k))
        return d


class AddPeopleUserCreatePersonPhones(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserCreatePersonPhones, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'number':
                d['number'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter phones. All possible keys are: number, '
                               'type'.format(k))
        return d


class AddSources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter sources. All possible keys are: type'.
                format(k))
        return d


class AddPeopleUserCreatePersonWebsites(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserCreatePersonWebsites, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'address':
                d['address'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter websites. All possible keys are: address, '
                               'display-name, type'.format(k))
        return d


class AddSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'has-graph-mailbox':
                d['has_graph_mailbox'] = v[0]
            elif kl == 'has-license':
                d['has_license'] = v[0]
            elif kl == 'has-opted-out':
                d['has_opted_out'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter settings. All possible keys are: '
                               'has-graph-mailbox, has-license, has-opted-out'.format(k))
        return d


class AddActivityStatistics(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddActivityStatistics, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'activity':
                d['activity'] = v[0]
            elif kl == 'duration':
                d['duration'] = v[0]
            elif kl == 'end-date':
                d['end_date'] = v[0]
            elif kl == 'start-date':
                d['start_date'] = v[0]
            elif kl == 'time-zone-used':
                d['time_zone_used'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter activity_statistics. All possible keys '
                               'are: activity, duration, end-date, start-date, time-zone-used, id'.format(k))
        return d


class AddAnniversaries(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAnniversaries, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'date':
                d['date'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter anniversaries. All possible keys are: '
                               'date, type, allowed-audiences, created-date-time, inference, last-modified-date-time, '
                               'source, application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddAwards(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAwards, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'issued-date':
                d['issued_date'] = v[0]
            elif kl == 'issuing-authority':
                d['issuing_authority'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter awards. All possible keys are: '
                               'description, display-name, issued-date, issuing-authority, thumbnail-url, web-url, '
                               'allowed-audiences, created-date-time, inference, last-modified-date-time, source, '
                               'application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddCertifications(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCertifications, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'certification-id':
                d['certification_id'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date':
                d['end_date'] = v[0]
            elif kl == 'issued-date':
                d['issued_date'] = v[0]
            elif kl == 'issuing-authority':
                d['issuing_authority'] = v[0]
            elif kl == 'issuing-company':
                d['issuing_company'] = v[0]
            elif kl == 'start-date':
                d['start_date'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter certifications. All possible keys are: '
                               'certification-id, description, display-name, end-date, issued-date, issuing-authority, '
                               'issuing-company, start-date, thumbnail-url, web-url, allowed-audiences, '
                               'created-date-time, inference, last-modified-date-time, source, '
                               'application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddEmails(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEmails, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'address':
                d['address'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter emails. All possible keys are: address, '
                               'display-name, type, allowed-audiences, created-date-time, inference, '
                               'last-modified-date-time, source, application-last-modified-by-application, '
                               'device-last-modified-by-device, user-last-modified-by-user, '
                               'application-created-by-application, device-created-by-device, user-created-by-user, id'
                               .format(k))
        return d


class AddInterests(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddInterests, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'categories':
                d['categories'] = v
            elif kl == 'collaboration-tags':
                d['collaboration_tags'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter interests. All possible keys are: '
                               'categories, collaboration-tags, description, display-name, web-url, allowed-audiences, '
                               'created-date-time, inference, last-modified-date-time, source, '
                               'application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddLanguages(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddLanguages, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'proficiency':
                d['proficiency'] = v[0]
            elif kl == 'reading':
                d['reading'] = v[0]
            elif kl == 'spoken':
                d['spoken'] = v[0]
            elif kl == 'tag':
                d['tag'] = v[0]
            elif kl == 'written':
                d['written'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter languages. All possible keys are: '
                               'display-name, proficiency, reading, spoken, tag, written, allowed-audiences, '
                               'created-date-time, inference, last-modified-date-time, source, '
                               'application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddPatents(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPatents, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'is-pending':
                d['is_pending'] = v[0]
            elif kl == 'issued-date':
                d['issued_date'] = v[0]
            elif kl == 'issuing-authority':
                d['issuing_authority'] = v[0]
            elif kl == 'number':
                d['number'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter patents. All possible keys are: '
                               'description, display-name, is-pending, issued-date, issuing-authority, number, '
                               'web-url, allowed-audiences, created-date-time, inference, last-modified-date-time, '
                               'source, application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddPeopleUserUpdateProfilePhones(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserUpdateProfilePhones, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'number':
                d['number'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter phones. All possible keys are: '
                               'display-name, number, type, allowed-audiences, created-date-time, inference, '
                               'last-modified-date-time, source, application-last-modified-by-application, '
                               'device-last-modified-by-device, user-last-modified-by-user, '
                               'application-created-by-application, device-created-by-device, user-created-by-user, id'
                               .format(k))
        return d


class AddPublications(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPublications, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'published-date':
                d['published_date'] = v[0]
            elif kl == 'publisher':
                d['publisher'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter publications. All possible keys are: '
                               'description, display-name, published-date, publisher, thumbnail-url, web-url, '
                               'allowed-audiences, created-date-time, inference, last-modified-date-time, source, '
                               'application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddSkills(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSkills, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'categories':
                d['categories'] = v
            elif kl == 'collaboration-tags':
                d['collaboration_tags'] = v
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'proficiency':
                d['proficiency'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter skills. All possible keys are: '
                               'categories, collaboration-tags, display-name, proficiency, web-url, allowed-audiences, '
                               'created-date-time, inference, last-modified-date-time, source, '
                               'application-last-modified-by-application, device-last-modified-by-device, '
                               'user-last-modified-by-user, application-created-by-application, '
                               'device-created-by-device, user-created-by-user, id'.format(k))
        return d


class AddPeopleUserUpdateProfileWebsites(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUserUpdateProfileWebsites, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'categories':
                d['categories'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            elif kl == 'allowed-audiences':
                d['allowed_audiences'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'inference':
                d['inference'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            elif kl == 'application-last-modified-by-application':
                d['application'] = v[0]
            elif kl == 'device-last-modified-by-device':
                d['device'] = v[0]
            elif kl == 'user-last-modified-by-user':
                d['user'] = v[0]
            elif kl == 'application-created-by-application':
                d['application'] = v[0]
            elif kl == 'device-created-by-device':
                d['device'] = v[0]
            elif kl == 'user-created-by-user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter websites. All possible keys are: '
                               'categories, description, display-name, web-url, allowed-audiences, created-date-time, '
                               'inference, last-modified-date-time, source, application-last-modified-by-application, '
                               'device-last-modified-by-device, user-last-modified-by-user, '
                               'application-created-by-application, device-created-by-device, user-created-by-user, id'
                               .format(k))
        return d


class AddInference(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.inference = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'confidence-score':
                d['confidence_score'] = v[0]
            elif kl == 'user-has-verified-accuracy':
                d['user_has_verified_accuracy'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter inference. All possible keys are: '
                               'confidence-score, user-has-verified-accuracy'.format(k))
        return d


class AddSource(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.source = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter source. All possible keys are: type'.
                format(k))
        return d


class AddApplication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.application = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter application. All possible keys are: '
                               'display-name, id'.format(k))
        return d


class AddPreferredLanguageTag(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.preferred_language_tag = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'locale':
                d['locale'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter preferred_language_tag. All possible keys '
                               'are: display-name, locale'.format(k))
        return d


class AddPeopleUsersprofileCreateAddressDetail(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.detail = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'city':
                d['city'] = v[0]
            elif kl == 'country-or-region':
                d['country_or_region'] = v[0]
            elif kl == 'postal-code':
                d['postal_code'] = v[0]
            elif kl == 'post-office-box':
                d['post_office_box'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'street':
                d['street'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter detail. All possible keys are: city, '
                               'country-or-region, postal-code, post-office-box, state, street, type'.format(k))
        return d


class AddGeoCoordinates(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.geo_coordinates = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'altitude':
                d['altitude'] = v[0]
            elif kl == 'latitude':
                d['latitude'] = v[0]
            elif kl == 'longitude':
                d['longitude'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter geo_coordinates. All possible keys are: '
                               'altitude, latitude, longitude'.format(k))
        return d


class AddPronunciation(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.pronunciation = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'first':
                d['first'] = v[0]
            elif kl == 'last':
                d['last'] = v[0]
            elif kl == 'maiden':
                d['maiden'] = v[0]
            elif kl == 'middle':
                d['middle'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter pronunciation. All possible keys are: '
                               'display-name, first, last, maiden, middle'.format(k))
        return d


class AddPeopleUsersprofileCreateNoteDetail(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.detail = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content':
                d['content'] = v[0]
            elif kl == 'content-type':
                d['content_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter detail. All possible keys are: content, '
                               'content-type'.format(k))
        return d


class AddPeopleUsersprofileCreatePositionColleagues(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUsersprofileCreatePositionColleagues, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter colleagues. All possible keys are: '
                               'display-name, relationship, user-principal-name'.format(k))
        return d


class AddManager(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.manager = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter manager. All possible keys are: '
                               'display-name, relationship, user-principal-name'.format(k))
        return d


class AddPeopleUsersprofileCreateProjectColleagues(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPeopleUsersprofileCreateProjectColleagues, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter colleagues. All possible keys are: '
                               'display-name, relationship, user-principal-name'.format(k))
        return d


class AddSponsors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSponsors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'relationship':
                d['relationship'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter sponsors. All possible keys are: '
                               'display-name, relationship, user-principal-name'.format(k))
        return d


class AddService(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.service = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'web-url':
                d['web_url'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter service. All possible keys are: name, '
                               'web-url'.format(k))
        return d
