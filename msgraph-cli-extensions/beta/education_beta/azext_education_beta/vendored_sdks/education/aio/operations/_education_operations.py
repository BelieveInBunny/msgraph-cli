# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, AsyncIterable, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class EducationOperations:
    """EducationOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~education.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_class(
        self,
        orderby: Optional[List[Union[str, "models.Get5ItemsItem"]]] = None,
        select: Optional[List[Union[str, "models.Get6ItemsItem"]]] = None,
        expand: Optional[List[Union[str, "models.Get7ItemsItem"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEducationClass"]:
        """Get classes from education.

        Get classes from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Get5ItemsItem]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Get6ItemsItem]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Get7ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationClass or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~education.models.CollectionOfEducationClass]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationClass"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_class.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationClass', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_class.metadata = {'url': '/education/classes'}  # type: ignore

    async def create_class(
        self,
        id: Optional[str] = None,
        class_code: Optional[str] = None,
        course: Optional["models.MicrosoftGraphEducationCourse"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        external_id: Optional[str] = None,
        external_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        grade: Optional[str] = None,
        mail_nickname: Optional[str] = None,
        term: Optional["models.MicrosoftGraphEducationTerm"] = None,
        assignment_categories: Optional[List["models.MicrosoftGraphEducationCategory"]] = None,
        assignments: Optional[List["models.MicrosoftGraphEducationAssignment"]] = None,
        group: Optional["models.MicrosoftGraphGroup"] = None,
        members: Optional[List["models.MicrosoftGraphEducationUser"]] = None,
        schools: Optional[List["models.MicrosoftGraphEducationSchool"]] = None,
        teachers: Optional[List["models.MicrosoftGraphEducationUser"]] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationClass":
        """Create new navigation property to classes for education.

        Create new navigation property to classes for education.

        :param id: Read-only.
        :type id: str
        :param class_code: Class code used by the school to identify the class.
        :type class_code: str
        :param course: educationCourse.
        :type course: ~education.models.MicrosoftGraphEducationCourse
        :param description: Description of the class.
        :type description: str
        :param display_name: Name of the class.
        :type display_name: str
        :param external_id: ID of the class from the syncing system.
        :type external_id: str
        :param external_name: Name of the class in the syncing system.
        :type external_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param grade:
        :type grade: str
        :param mail_nickname: Mail name for sending email to all members, if this is enabled.
        :type mail_nickname: str
        :param term: educationTerm.
        :type term: ~education.models.MicrosoftGraphEducationTerm
        :param assignment_categories:
        :type assignment_categories: list[~education.models.MicrosoftGraphEducationCategory]
        :param assignments:
        :type assignments: list[~education.models.MicrosoftGraphEducationAssignment]
        :param group: Represents an Azure Active Directory object. The directoryObject type is the base
         type for many other directory entity types.
        :type group: ~education.models.MicrosoftGraphGroup
        :param members: All users in the class. Nullable.
        :type members: list[~education.models.MicrosoftGraphEducationUser]
        :param schools: All schools that this class is associated with. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param teachers: All teachers in the class. Nullable.
        :type teachers: list[~education.models.MicrosoftGraphEducationUser]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationClass, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationClass
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationClass"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationClass(id=id, class_code=class_code, course=course, description=description, display_name=display_name, external_id=external_id, external_name=external_name, external_source=external_source, external_source_detail=external_source_detail, grade=grade, mail_nickname=mail_nickname, term=term, assignment_categories=assignment_categories, assignments=assignments, group=group, members=members, schools=schools, teachers=teachers, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_class.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationClass')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationClass', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_class.metadata = {'url': '/education/classes'}  # type: ignore

    async def get_class(
        self,
        education_class_id: str,
        select: Optional[List[Union[str, "models.Enum132"]]] = None,
        expand: Optional[List[Union[str, "models.Get2ItemsItem"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationClass":
        """Get classes from education.

        Get classes from education.

        :param education_class_id: key: id of educationClass.
        :type education_class_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum132]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Get2ItemsItem]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationClass, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationClass
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationClass"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_class.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationClass-id': self._serialize.url("education_class_id", education_class_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationClass', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_class.metadata = {'url': '/education/classes/{educationClass-id}'}  # type: ignore

    async def update_class(
        self,
        education_class_id: str,
        id: Optional[str] = None,
        class_code: Optional[str] = None,
        course: Optional["models.MicrosoftGraphEducationCourse"] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        external_id: Optional[str] = None,
        external_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        grade: Optional[str] = None,
        mail_nickname: Optional[str] = None,
        term: Optional["models.MicrosoftGraphEducationTerm"] = None,
        assignment_categories: Optional[List["models.MicrosoftGraphEducationCategory"]] = None,
        assignments: Optional[List["models.MicrosoftGraphEducationAssignment"]] = None,
        group: Optional["models.MicrosoftGraphGroup"] = None,
        members: Optional[List["models.MicrosoftGraphEducationUser"]] = None,
        schools: Optional[List["models.MicrosoftGraphEducationSchool"]] = None,
        teachers: Optional[List["models.MicrosoftGraphEducationUser"]] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property classes in education.

        Update the navigation property classes in education.

        :param education_class_id: key: id of educationClass.
        :type education_class_id: str
        :param id: Read-only.
        :type id: str
        :param class_code: Class code used by the school to identify the class.
        :type class_code: str
        :param course: educationCourse.
        :type course: ~education.models.MicrosoftGraphEducationCourse
        :param description: Description of the class.
        :type description: str
        :param display_name: Name of the class.
        :type display_name: str
        :param external_id: ID of the class from the syncing system.
        :type external_id: str
        :param external_name: Name of the class in the syncing system.
        :type external_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param grade:
        :type grade: str
        :param mail_nickname: Mail name for sending email to all members, if this is enabled.
        :type mail_nickname: str
        :param term: educationTerm.
        :type term: ~education.models.MicrosoftGraphEducationTerm
        :param assignment_categories:
        :type assignment_categories: list[~education.models.MicrosoftGraphEducationCategory]
        :param assignments:
        :type assignments: list[~education.models.MicrosoftGraphEducationAssignment]
        :param group: Represents an Azure Active Directory object. The directoryObject type is the base
         type for many other directory entity types.
        :type group: ~education.models.MicrosoftGraphGroup
        :param members: All users in the class. Nullable.
        :type members: list[~education.models.MicrosoftGraphEducationUser]
        :param schools: All schools that this class is associated with. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param teachers: All teachers in the class. Nullable.
        :type teachers: list[~education.models.MicrosoftGraphEducationUser]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationClass(id=id, class_code=class_code, course=course, description=description, display_name=display_name, external_id=external_id, external_name=external_name, external_source=external_source, external_source_detail=external_source_detail, grade=grade, mail_nickname=mail_nickname, term=term, assignment_categories=assignment_categories, assignments=assignments, group=group, members=members, schools=schools, teachers=teachers, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_class.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationClass-id': self._serialize.url("education_class_id", education_class_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationClass')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_class.metadata = {'url': '/education/classes/{educationClass-id}'}  # type: ignore

    async def delete_class(
        self,
        education_class_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property classes for education.

        Delete navigation property classes for education.

        :param education_class_id: key: id of educationClass.
        :type education_class_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_class.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationClass-id': self._serialize.url("education_class_id", education_class_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_class.metadata = {'url': '/education/classes/{educationClass-id}'}  # type: ignore

    async def get_me(
        self,
        select: Optional[List[Union[str, "models.Enum177"]]] = None,
        expand: Optional[List[Union[str, "models.Enum178"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationUser":
        """Get me from education.

        Get me from education.

        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum177]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum178]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationUser, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationUser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_me.metadata = {'url': '/education/me'}  # type: ignore

    async def update_me(
        self,
        id: Optional[str] = None,
        related_contacts: Optional[List["models.MicrosoftGraphRelatedContact"]] = None,
        account_enabled: Optional[bool] = None,
        assigned_licenses: Optional[List["models.MicrosoftGraphAssignedLicense"]] = None,
        assigned_plans: Optional[List["models.MicrosoftGraphAssignedPlan"]] = None,
        business_phones: Optional[List[str]] = None,
        department: Optional[str] = None,
        display_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        given_name: Optional[str] = None,
        mail: Optional[str] = None,
        mailing_address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        mail_nickname: Optional[str] = None,
        middle_name: Optional[str] = None,
        mobile_phone: Optional[str] = None,
        office_location: Optional[str] = None,
        password_policies: Optional[str] = None,
        password_profile: Optional["models.MicrosoftGraphPasswordProfile"] = None,
        preferred_language: Optional[str] = None,
        primary_role: Optional[Union[str, "models.MicrosoftGraphEducationUserRole"]] = None,
        provisioned_plans: Optional[List["models.MicrosoftGraphProvisionedPlan"]] = None,
        refresh_tokens_valid_from_date_time: Optional[datetime.datetime] = None,
        residence_address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        show_in_address_list: Optional[bool] = None,
        student: Optional["models.MicrosoftGraphEducationStudent"] = None,
        surname: Optional[str] = None,
        teacher: Optional["models.MicrosoftGraphEducationTeacher"] = None,
        usage_location: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        user_type: Optional[str] = None,
        assignments: Optional[List["models.MicrosoftGraphEducationAssignment"]] = None,
        rubrics: Optional[List["models.MicrosoftGraphEducationRubric"]] = None,
        classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        schools: Optional[List["models.MicrosoftGraphEducationSchool"]] = None,
        taught_classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        user: Optional["models.MicrosoftGraphUser"] = None,
        immutable_id: Optional[str] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property me in education.

        Update the navigation property me in education.

        :param id: Read-only.
        :type id: str
        :param related_contacts: Set of contacts related to the user.  This optional property must be
         specified in a $select clause and can only be retrieved for an individual user.
        :type related_contacts: list[~education.models.MicrosoftGraphRelatedContact]
        :param account_enabled: True if the account is enabled; otherwise, false. This property is
         required when a user is created. Supports $filter.
        :type account_enabled: bool
        :param assigned_licenses: The licenses that are assigned to the user. Not nullable.
        :type assigned_licenses: list[~education.models.MicrosoftGraphAssignedLicense]
        :param assigned_plans: The plans that are assigned to the user. Read-only. Not nullable.
        :type assigned_plans: list[~education.models.MicrosoftGraphAssignedPlan]
        :param business_phones: The telephone numbers for the user. Note: Although this is a string
         collection, only one number can be set for this property.
        :type business_phones: list[str]
        :param department: The name for the department in which the user works. Supports $filter.
        :type department: str
        :param display_name: The name displayed in the address book for the user. This is usually the
         combination of the user's first name, middle initial, and last name. This property is required
         when a user is created and it cannot be cleared during updates. Supports $filter and $orderby.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param given_name: The given name (first name) of the user. Supports $filter.
        :type given_name: str
        :param mail: The SMTP address for the user; for example, 'jeff@contoso.onmicrosoft.com'. Read-
         Only. Supports $filter.
        :type mail: str
        :param mailing_address: physicalAddress.
        :type mailing_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param mail_nickname: The mail alias for the user. This property must be specified when a user
         is created. Supports $filter.
        :type mail_nickname: str
        :param middle_name: The middle name of user.
        :type middle_name: str
        :param mobile_phone: The primary cellular telephone number for the user.
        :type mobile_phone: str
        :param office_location:
        :type office_location: str
        :param password_policies: Specifies password policies for the user. This value is an
         enumeration with one possible value being 'DisableStrongPassword', which allows weaker
         passwords than the default policy to be specified. 'DisablePasswordExpiration' can also be
         specified. The two can be specified together; for example: 'DisablePasswordExpiration,
         DisableStrongPassword'.
        :type password_policies: str
        :param password_profile: passwordProfile.
        :type password_profile: ~education.models.MicrosoftGraphPasswordProfile
        :param preferred_language: The preferred language for the user. Should follow ISO 639-1 Code;
         for example, 'en-US'.
        :type preferred_language: str
        :param primary_role:
        :type primary_role: str or ~education.models.MicrosoftGraphEducationUserRole
        :param provisioned_plans: The plans that are provisioned for the user. Read-only. Not nullable.
        :type provisioned_plans: list[~education.models.MicrosoftGraphProvisionedPlan]
        :param refresh_tokens_valid_from_date_time:
        :type refresh_tokens_valid_from_date_time: ~datetime.datetime
        :param residence_address: physicalAddress.
        :type residence_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param show_in_address_list:
        :type show_in_address_list: bool
        :param student: educationStudent.
        :type student: ~education.models.MicrosoftGraphEducationStudent
        :param surname: The user's surname (family name or last name). Supports $filter.
        :type surname: str
        :param teacher: educationTeacher.
        :type teacher: ~education.models.MicrosoftGraphEducationTeacher
        :param usage_location: A two-letter country code (ISO standard 3166). Required for users who
         will be assigned licenses due to a legal requirement to check for availability of services in
         countries or regions. Examples include: 'US', 'JP', and 'GB'. Not nullable. Supports $filter.
        :type usage_location: str
        :param user_principal_name: The user principal name (UPN) of the user. The UPN is an Internet-
         style login name for the user based on the Internet standard RFC 822. By convention, this
         should map to the user's email name. The general format is alias@domain, where domain must be
         present in the tenant's collection of verified domains. This property is required when a user
         is created. The verified domains for the tenant can be accessed from the verifiedDomains
         property of organization. Supports $filter and $orderby.
        :type user_principal_name: str
        :param user_type: A string value that can be used to classify user types in your directory,
         such as 'Member' and 'Guest'. Supports $filter.
        :type user_type: str
        :param assignments: List of assignments for the user. Nullable.
        :type assignments: list[~education.models.MicrosoftGraphEducationAssignment]
        :param rubrics:
        :type rubrics: list[~education.models.MicrosoftGraphEducationRubric]
        :param classes: Classes to which the user belongs. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param schools: Schools to which the user belongs. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param taught_classes:
        :type taught_classes: list[~education.models.MicrosoftGraphEducationClass]
        :param user: Represents an Azure Active Directory user object.
        :type user: ~education.models.MicrosoftGraphUser
        :param immutable_id:
        :type immutable_id: str
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationUser(id=id, related_contacts=related_contacts, account_enabled=account_enabled, assigned_licenses=assigned_licenses, assigned_plans=assigned_plans, business_phones=business_phones, department=department, display_name=display_name, external_source=external_source, external_source_detail=external_source_detail, given_name=given_name, mail=mail, mailing_address=mailing_address, mail_nickname=mail_nickname, middle_name=middle_name, mobile_phone=mobile_phone, office_location=office_location, password_policies=password_policies, password_profile=password_profile, preferred_language=preferred_language, primary_role=primary_role, provisioned_plans=provisioned_plans, refresh_tokens_valid_from_date_time=refresh_tokens_valid_from_date_time, residence_address=residence_address, show_in_address_list=show_in_address_list, student=student, surname=surname, teacher=teacher, usage_location=usage_location, user_principal_name=user_principal_name, user_type=user_type, assignments=assignments, rubrics=rubrics, classes=classes, schools=schools, taught_classes=taught_classes, user=user, immutable_id=immutable_id, application=application, device=device, user_created_by_user=microsoft_graph_identity_user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationUser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_me.metadata = {'url': '/education/me'}  # type: ignore

    async def delete_me(
        self,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property me for education.

        Delete navigation property me for education.

        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_me.metadata = {'url': '/education/me'}  # type: ignore

    def list_school(
        self,
        orderby: Optional[List[Union[str, "models.Enum222"]]] = None,
        select: Optional[List[Union[str, "models.Enum223"]]] = None,
        expand: Optional[List[Union[str, "models.Enum224"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEducationSchool1"]:
        """Get schools from education.

        Get schools from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Enum222]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum223]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum224]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationSchool1 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~education.models.CollectionOfEducationSchool1]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationSchool1"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_school.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationSchool1', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_school.metadata = {'url': '/education/schools'}  # type: ignore

    async def create_school(
        self,
        id: Optional[str] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        external_id: Optional[str] = None,
        external_principal_id: Optional[str] = None,
        fax: Optional[str] = None,
        highest_grade: Optional[str] = None,
        lowest_grade: Optional[str] = None,
        phone: Optional[str] = None,
        principal_email: Optional[str] = None,
        principal_name: Optional[str] = None,
        school_number: Optional[str] = None,
        classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        users: Optional[List["models.MicrosoftGraphEducationUser"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_administrative_unit_description: Optional[str] = None,
        microsoft_graph_administrative_unit_display_name: Optional[str] = None,
        visibility: Optional[str] = None,
        members: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        scoped_role_members: Optional[List["models.MicrosoftGraphScopedRoleMembership"]] = None,
        extensions: Optional[List["models.MicrosoftGraphExtension"]] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationSchool":
        """Create new navigation property to schools for education.

        Create new navigation property to schools for education.

        :param id: Read-only.
        :type id: str
        :param description: Organization description.
        :type description: str
        :param display_name: Organization display name.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param address: physicalAddress.
        :type address: ~education.models.MicrosoftGraphPhysicalAddress
        :param external_id: ID of school in syncing system.
        :type external_id: str
        :param external_principal_id: ID of principal in syncing system.
        :type external_principal_id: str
        :param fax:
        :type fax: str
        :param highest_grade: Highest grade taught.
        :type highest_grade: str
        :param lowest_grade: Lowest grade taught.
        :type lowest_grade: str
        :param phone: Phone number of school.
        :type phone: str
        :param principal_email: Email address of the principal.
        :type principal_email: str
        :param principal_name: Name of the principal.
        :type principal_name: str
        :param school_number: School Number.
        :type school_number: str
        :param classes: Classes taught at the school. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param users: Users in the school. Nullable.
        :type users: list[~education.models.MicrosoftGraphEducationUser]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param microsoft_graph_administrative_unit_description: An optional description for the
         administrative unit.
        :type microsoft_graph_administrative_unit_description: str
        :param microsoft_graph_administrative_unit_display_name: Display name for the administrative
         unit.
        :type microsoft_graph_administrative_unit_display_name: str
        :param visibility: Controls whether the administrative unit and its members are hidden or
         public. Can be set to HiddenMembership or Public. If not set, default behavior is Public. When
         set to HiddenMembership, only members of the administrative unit can list other members of the
         adminstrative unit.
        :type visibility: str
        :param members: Users and groups that are members of this Adminsitrative Unit. HTTP Methods:
         GET (list members), POST (add members), DELETE (remove members).
        :type members: list[~education.models.MicrosoftGraphDirectoryObject]
        :param scoped_role_members: Scoped-role members of this Administrative Unit.  HTTP Methods: GET
         (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove
         scopedRoleMembership).
        :type scoped_role_members: list[~education.models.MicrosoftGraphScopedRoleMembership]
        :param extensions:
        :type extensions: list[~education.models.MicrosoftGraphExtension]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationSchool, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationSchool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationSchool"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationSchool(id=id, description=description, display_name=display_name, external_source=external_source, external_source_detail=external_source_detail, address=address, external_id=external_id, external_principal_id=external_principal_id, fax=fax, highest_grade=highest_grade, lowest_grade=lowest_grade, phone=phone, principal_email=principal_email, principal_name=principal_name, school_number=school_number, classes=classes, users=users, id_administrative_unit_id=microsoft_graph_entity_id, deleted_date_time=deleted_date_time, description_administrative_unit_description=microsoft_graph_administrative_unit_description, display_name_administrative_unit_display_name=microsoft_graph_administrative_unit_display_name, visibility=visibility, members=members, scoped_role_members=scoped_role_members, extensions=extensions, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_school.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationSchool')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationSchool', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_school.metadata = {'url': '/education/schools'}  # type: ignore

    async def get_school(
        self,
        education_school_id: str,
        select: Optional[List[Union[str, "models.Enum225"]]] = None,
        expand: Optional[List[Union[str, "models.Enum226"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationSchool":
        """Get schools from education.

        Get schools from education.

        :param education_school_id: key: id of educationSchool.
        :type education_school_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum225]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum226]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationSchool, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationSchool
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationSchool"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_school.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSchool-id': self._serialize.url("education_school_id", education_school_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationSchool', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_school.metadata = {'url': '/education/schools/{educationSchool-id}'}  # type: ignore

    async def update_school(
        self,
        education_school_id: str,
        id: Optional[str] = None,
        description: Optional[str] = None,
        display_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        external_id: Optional[str] = None,
        external_principal_id: Optional[str] = None,
        fax: Optional[str] = None,
        highest_grade: Optional[str] = None,
        lowest_grade: Optional[str] = None,
        phone: Optional[str] = None,
        principal_email: Optional[str] = None,
        principal_name: Optional[str] = None,
        school_number: Optional[str] = None,
        classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        users: Optional[List["models.MicrosoftGraphEducationUser"]] = None,
        microsoft_graph_entity_id: Optional[str] = None,
        deleted_date_time: Optional[datetime.datetime] = None,
        microsoft_graph_administrative_unit_description: Optional[str] = None,
        microsoft_graph_administrative_unit_display_name: Optional[str] = None,
        visibility: Optional[str] = None,
        members: Optional[List["models.MicrosoftGraphDirectoryObject"]] = None,
        scoped_role_members: Optional[List["models.MicrosoftGraphScopedRoleMembership"]] = None,
        extensions: Optional[List["models.MicrosoftGraphExtension"]] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property schools in education.

        Update the navigation property schools in education.

        :param education_school_id: key: id of educationSchool.
        :type education_school_id: str
        :param id: Read-only.
        :type id: str
        :param description: Organization description.
        :type description: str
        :param display_name: Organization display name.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param address: physicalAddress.
        :type address: ~education.models.MicrosoftGraphPhysicalAddress
        :param external_id: ID of school in syncing system.
        :type external_id: str
        :param external_principal_id: ID of principal in syncing system.
        :type external_principal_id: str
        :param fax:
        :type fax: str
        :param highest_grade: Highest grade taught.
        :type highest_grade: str
        :param lowest_grade: Lowest grade taught.
        :type lowest_grade: str
        :param phone: Phone number of school.
        :type phone: str
        :param principal_email: Email address of the principal.
        :type principal_email: str
        :param principal_name: Name of the principal.
        :type principal_name: str
        :param school_number: School Number.
        :type school_number: str
        :param classes: Classes taught at the school. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param users: Users in the school. Nullable.
        :type users: list[~education.models.MicrosoftGraphEducationUser]
        :param microsoft_graph_entity_id: Read-only.
        :type microsoft_graph_entity_id: str
        :param deleted_date_time:
        :type deleted_date_time: ~datetime.datetime
        :param microsoft_graph_administrative_unit_description: An optional description for the
         administrative unit.
        :type microsoft_graph_administrative_unit_description: str
        :param microsoft_graph_administrative_unit_display_name: Display name for the administrative
         unit.
        :type microsoft_graph_administrative_unit_display_name: str
        :param visibility: Controls whether the administrative unit and its members are hidden or
         public. Can be set to HiddenMembership or Public. If not set, default behavior is Public. When
         set to HiddenMembership, only members of the administrative unit can list other members of the
         adminstrative unit.
        :type visibility: str
        :param members: Users and groups that are members of this Adminsitrative Unit. HTTP Methods:
         GET (list members), POST (add members), DELETE (remove members).
        :type members: list[~education.models.MicrosoftGraphDirectoryObject]
        :param scoped_role_members: Scoped-role members of this Administrative Unit.  HTTP Methods: GET
         (list scopedRoleMemberships), POST (add scopedRoleMembership), DELETE (remove
         scopedRoleMembership).
        :type scoped_role_members: list[~education.models.MicrosoftGraphScopedRoleMembership]
        :param extensions:
        :type extensions: list[~education.models.MicrosoftGraphExtension]
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param user: identity.
        :type user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationSchool(id=id, description=description, display_name=display_name, external_source=external_source, external_source_detail=external_source_detail, address=address, external_id=external_id, external_principal_id=external_principal_id, fax=fax, highest_grade=highest_grade, lowest_grade=lowest_grade, phone=phone, principal_email=principal_email, principal_name=principal_name, school_number=school_number, classes=classes, users=users, id_administrative_unit_id=microsoft_graph_entity_id, deleted_date_time=deleted_date_time, description_administrative_unit_description=microsoft_graph_administrative_unit_description, display_name_administrative_unit_display_name=microsoft_graph_administrative_unit_display_name, visibility=visibility, members=members, scoped_role_members=scoped_role_members, extensions=extensions, application=application, device=device, user=user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_school.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSchool-id': self._serialize.url("education_school_id", education_school_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationSchool')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_school.metadata = {'url': '/education/schools/{educationSchool-id}'}  # type: ignore

    async def delete_school(
        self,
        education_school_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property schools for education.

        Delete navigation property schools for education.

        :param education_school_id: key: id of educationSchool.
        :type education_school_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_school.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSchool-id': self._serialize.url("education_school_id", education_school_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_school.metadata = {'url': '/education/schools/{educationSchool-id}'}  # type: ignore

    def list_synchronization_profile(
        self,
        orderby: Optional[List[Union[str, "models.Enum237"]]] = None,
        select: Optional[List[Union[str, "models.Enum238"]]] = None,
        expand: Optional[List[Union[str, "models.Enum239"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEducationSynchronizationProfile"]:
        """Get synchronizationProfiles from education.

        Get synchronizationProfiles from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Enum237]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum238]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum239]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationSynchronizationProfile or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~education.models.CollectionOfEducationSynchronizationProfile]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationSynchronizationProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_synchronization_profile.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationSynchronizationProfile', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_synchronization_profile.metadata = {'url': '/education/synchronizationProfiles'}  # type: ignore

    async def create_synchronization_profile(
        self,
        id: Optional[str] = None,
        data_provider: Optional[Dict[str, object]] = None,
        display_name: Optional[str] = None,
        expiration_date: Optional[datetime.date] = None,
        handle_special_character_constraint: Optional[bool] = None,
        identity_synchronization_configuration: Optional[Dict[str, object]] = None,
        licenses_to_assign: Optional[List["models.MicrosoftGraphEducationSynchronizationLicenseAssignment"]] = None,
        state: Optional[Union[str, "models.MicrosoftGraphEducationSynchronizationProfileState"]] = None,
        errors: Optional[List["models.MicrosoftGraphEducationSynchronizationError"]] = None,
        profile_status: Optional["models.MicrosoftGraphEducationSynchronizationProfileStatus"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationSynchronizationProfile":
        """Create new navigation property to synchronizationProfiles for education.

        Create new navigation property to synchronizationProfiles for education.

        :param id: Read-only.
        :type id: str
        :param data_provider: educationSynchronizationDataProvider.
        :type data_provider: dict[str, object]
        :param display_name:
        :type display_name: str
        :param expiration_date:
        :type expiration_date: ~datetime.date
        :param handle_special_character_constraint:
        :type handle_special_character_constraint: bool
        :param identity_synchronization_configuration: educationIdentitySynchronizationConfiguration.
        :type identity_synchronization_configuration: dict[str, object]
        :param licenses_to_assign:
        :type licenses_to_assign: list[~education.models.MicrosoftGraphEducationSynchronizationLicenseAssignment]
        :param state:
        :type state: str or ~education.models.MicrosoftGraphEducationSynchronizationProfileState
        :param errors:
        :type errors: list[~education.models.MicrosoftGraphEducationSynchronizationError]
        :param profile_status: educationSynchronizationProfileStatus.
        :type profile_status: ~education.models.MicrosoftGraphEducationSynchronizationProfileStatus
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationSynchronizationProfile, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationSynchronizationProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationSynchronizationProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationSynchronizationProfile(id=id, data_provider=data_provider, display_name=display_name, expiration_date=expiration_date, handle_special_character_constraint=handle_special_character_constraint, identity_synchronization_configuration=identity_synchronization_configuration, licenses_to_assign=licenses_to_assign, state=state, errors=errors, profile_status=profile_status)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_synchronization_profile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationSynchronizationProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationSynchronizationProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_synchronization_profile.metadata = {'url': '/education/synchronizationProfiles'}  # type: ignore

    async def get_synchronization_profile(
        self,
        education_synchronization_profile_id: str,
        select: Optional[List[Union[str, "models.Enum240"]]] = None,
        expand: Optional[List[Union[str, "models.Enum241"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationSynchronizationProfile":
        """Get synchronizationProfiles from education.

        Get synchronizationProfiles from education.

        :param education_synchronization_profile_id: key: id of educationSynchronizationProfile.
        :type education_synchronization_profile_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum240]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum241]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationSynchronizationProfile, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationSynchronizationProfile
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationSynchronizationProfile"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_synchronization_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSynchronizationProfile-id': self._serialize.url("education_synchronization_profile_id", education_synchronization_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationSynchronizationProfile', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_synchronization_profile.metadata = {'url': '/education/synchronizationProfiles/{educationSynchronizationProfile-id}'}  # type: ignore

    async def update_synchronization_profile(
        self,
        education_synchronization_profile_id: str,
        id: Optional[str] = None,
        data_provider: Optional[Dict[str, object]] = None,
        display_name: Optional[str] = None,
        expiration_date: Optional[datetime.date] = None,
        handle_special_character_constraint: Optional[bool] = None,
        identity_synchronization_configuration: Optional[Dict[str, object]] = None,
        licenses_to_assign: Optional[List["models.MicrosoftGraphEducationSynchronizationLicenseAssignment"]] = None,
        state: Optional[Union[str, "models.MicrosoftGraphEducationSynchronizationProfileState"]] = None,
        errors: Optional[List["models.MicrosoftGraphEducationSynchronizationError"]] = None,
        profile_status: Optional["models.MicrosoftGraphEducationSynchronizationProfileStatus"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property synchronizationProfiles in education.

        Update the navigation property synchronizationProfiles in education.

        :param education_synchronization_profile_id: key: id of educationSynchronizationProfile.
        :type education_synchronization_profile_id: str
        :param id: Read-only.
        :type id: str
        :param data_provider: educationSynchronizationDataProvider.
        :type data_provider: dict[str, object]
        :param display_name:
        :type display_name: str
        :param expiration_date:
        :type expiration_date: ~datetime.date
        :param handle_special_character_constraint:
        :type handle_special_character_constraint: bool
        :param identity_synchronization_configuration: educationIdentitySynchronizationConfiguration.
        :type identity_synchronization_configuration: dict[str, object]
        :param licenses_to_assign:
        :type licenses_to_assign: list[~education.models.MicrosoftGraphEducationSynchronizationLicenseAssignment]
        :param state:
        :type state: str or ~education.models.MicrosoftGraphEducationSynchronizationProfileState
        :param errors:
        :type errors: list[~education.models.MicrosoftGraphEducationSynchronizationError]
        :param profile_status: educationSynchronizationProfileStatus.
        :type profile_status: ~education.models.MicrosoftGraphEducationSynchronizationProfileStatus
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationSynchronizationProfile(id=id, data_provider=data_provider, display_name=display_name, expiration_date=expiration_date, handle_special_character_constraint=handle_special_character_constraint, identity_synchronization_configuration=identity_synchronization_configuration, licenses_to_assign=licenses_to_assign, state=state, errors=errors, profile_status=profile_status)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_synchronization_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSynchronizationProfile-id': self._serialize.url("education_synchronization_profile_id", education_synchronization_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationSynchronizationProfile')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_synchronization_profile.metadata = {'url': '/education/synchronizationProfiles/{educationSynchronizationProfile-id}'}  # type: ignore

    async def delete_synchronization_profile(
        self,
        education_synchronization_profile_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property synchronizationProfiles for education.

        Delete navigation property synchronizationProfiles for education.

        :param education_synchronization_profile_id: key: id of educationSynchronizationProfile.
        :type education_synchronization_profile_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_synchronization_profile.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationSynchronizationProfile-id': self._serialize.url("education_synchronization_profile_id", education_synchronization_profile_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_synchronization_profile.metadata = {'url': '/education/synchronizationProfiles/{educationSynchronizationProfile-id}'}  # type: ignore

    def list_user(
        self,
        orderby: Optional[List[Union[str, "models.Enum246"]]] = None,
        select: Optional[List[Union[str, "models.Enum247"]]] = None,
        expand: Optional[List[Union[str, "models.Enum248"]]] = None,
        **kwargs
    ) -> AsyncIterable["models.CollectionOfEducationUser2"]:
        """Get users from education.

        Get users from education.

        :param orderby: Order items by property values.
        :type orderby: list[str or ~education.models.Enum246]
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum247]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum248]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either CollectionOfEducationUser2 or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~education.models.CollectionOfEducationUser2]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionOfEducationUser2"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_user.metadata['url']  # type: ignore
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                if self._config.top is not None:
                    query_parameters['$top'] = self._serialize.query("self._config.top", self._config.top, 'int', minimum=0)
                if self._config.skip is not None:
                    query_parameters['$skip'] = self._serialize.query("self._config.skip", self._config.skip, 'int', minimum=0)
                if self._config.search is not None:
                    query_parameters['$search'] = self._serialize.query("self._config.search", self._config.search, 'str')
                if self._config.filter is not None:
                    query_parameters['$filter'] = self._serialize.query("self._config.filter", self._config.filter, 'str')
                if self._config.count is not None:
                    query_parameters['$count'] = self._serialize.query("self._config.count", self._config.count, 'bool')
                if orderby is not None:
                    query_parameters['$orderby'] = self._serialize.query("orderby", orderby, '[str]', div=',')
                if select is not None:
                    query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
                if expand is not None:
                    query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('CollectionOfEducationUser2', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.odata_next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize(models.OdataError, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_user.metadata = {'url': '/education/users'}  # type: ignore

    async def create_user(
        self,
        id: Optional[str] = None,
        related_contacts: Optional[List["models.MicrosoftGraphRelatedContact"]] = None,
        account_enabled: Optional[bool] = None,
        assigned_licenses: Optional[List["models.MicrosoftGraphAssignedLicense"]] = None,
        assigned_plans: Optional[List["models.MicrosoftGraphAssignedPlan"]] = None,
        business_phones: Optional[List[str]] = None,
        department: Optional[str] = None,
        display_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        given_name: Optional[str] = None,
        mail: Optional[str] = None,
        mailing_address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        mail_nickname: Optional[str] = None,
        middle_name: Optional[str] = None,
        mobile_phone: Optional[str] = None,
        office_location: Optional[str] = None,
        password_policies: Optional[str] = None,
        password_profile: Optional["models.MicrosoftGraphPasswordProfile"] = None,
        preferred_language: Optional[str] = None,
        primary_role: Optional[Union[str, "models.MicrosoftGraphEducationUserRole"]] = None,
        provisioned_plans: Optional[List["models.MicrosoftGraphProvisionedPlan"]] = None,
        refresh_tokens_valid_from_date_time: Optional[datetime.datetime] = None,
        residence_address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        show_in_address_list: Optional[bool] = None,
        student: Optional["models.MicrosoftGraphEducationStudent"] = None,
        surname: Optional[str] = None,
        teacher: Optional["models.MicrosoftGraphEducationTeacher"] = None,
        usage_location: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        user_type: Optional[str] = None,
        assignments: Optional[List["models.MicrosoftGraphEducationAssignment"]] = None,
        rubrics: Optional[List["models.MicrosoftGraphEducationRubric"]] = None,
        classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        schools: Optional[List["models.MicrosoftGraphEducationSchool"]] = None,
        taught_classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        user: Optional["models.MicrosoftGraphUser"] = None,
        immutable_id: Optional[str] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationUser":
        """Create new navigation property to users for education.

        Create new navigation property to users for education.

        :param id: Read-only.
        :type id: str
        :param related_contacts: Set of contacts related to the user.  This optional property must be
         specified in a $select clause and can only be retrieved for an individual user.
        :type related_contacts: list[~education.models.MicrosoftGraphRelatedContact]
        :param account_enabled: True if the account is enabled; otherwise, false. This property is
         required when a user is created. Supports $filter.
        :type account_enabled: bool
        :param assigned_licenses: The licenses that are assigned to the user. Not nullable.
        :type assigned_licenses: list[~education.models.MicrosoftGraphAssignedLicense]
        :param assigned_plans: The plans that are assigned to the user. Read-only. Not nullable.
        :type assigned_plans: list[~education.models.MicrosoftGraphAssignedPlan]
        :param business_phones: The telephone numbers for the user. Note: Although this is a string
         collection, only one number can be set for this property.
        :type business_phones: list[str]
        :param department: The name for the department in which the user works. Supports $filter.
        :type department: str
        :param display_name: The name displayed in the address book for the user. This is usually the
         combination of the user's first name, middle initial, and last name. This property is required
         when a user is created and it cannot be cleared during updates. Supports $filter and $orderby.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param given_name: The given name (first name) of the user. Supports $filter.
        :type given_name: str
        :param mail: The SMTP address for the user; for example, 'jeff@contoso.onmicrosoft.com'. Read-
         Only. Supports $filter.
        :type mail: str
        :param mailing_address: physicalAddress.
        :type mailing_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param mail_nickname: The mail alias for the user. This property must be specified when a user
         is created. Supports $filter.
        :type mail_nickname: str
        :param middle_name: The middle name of user.
        :type middle_name: str
        :param mobile_phone: The primary cellular telephone number for the user.
        :type mobile_phone: str
        :param office_location:
        :type office_location: str
        :param password_policies: Specifies password policies for the user. This value is an
         enumeration with one possible value being 'DisableStrongPassword', which allows weaker
         passwords than the default policy to be specified. 'DisablePasswordExpiration' can also be
         specified. The two can be specified together; for example: 'DisablePasswordExpiration,
         DisableStrongPassword'.
        :type password_policies: str
        :param password_profile: passwordProfile.
        :type password_profile: ~education.models.MicrosoftGraphPasswordProfile
        :param preferred_language: The preferred language for the user. Should follow ISO 639-1 Code;
         for example, 'en-US'.
        :type preferred_language: str
        :param primary_role:
        :type primary_role: str or ~education.models.MicrosoftGraphEducationUserRole
        :param provisioned_plans: The plans that are provisioned for the user. Read-only. Not nullable.
        :type provisioned_plans: list[~education.models.MicrosoftGraphProvisionedPlan]
        :param refresh_tokens_valid_from_date_time:
        :type refresh_tokens_valid_from_date_time: ~datetime.datetime
        :param residence_address: physicalAddress.
        :type residence_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param show_in_address_list:
        :type show_in_address_list: bool
        :param student: educationStudent.
        :type student: ~education.models.MicrosoftGraphEducationStudent
        :param surname: The user's surname (family name or last name). Supports $filter.
        :type surname: str
        :param teacher: educationTeacher.
        :type teacher: ~education.models.MicrosoftGraphEducationTeacher
        :param usage_location: A two-letter country code (ISO standard 3166). Required for users who
         will be assigned licenses due to a legal requirement to check for availability of services in
         countries or regions. Examples include: 'US', 'JP', and 'GB'. Not nullable. Supports $filter.
        :type usage_location: str
        :param user_principal_name: The user principal name (UPN) of the user. The UPN is an Internet-
         style login name for the user based on the Internet standard RFC 822. By convention, this
         should map to the user's email name. The general format is alias@domain, where domain must be
         present in the tenant's collection of verified domains. This property is required when a user
         is created. The verified domains for the tenant can be accessed from the verifiedDomains
         property of organization. Supports $filter and $orderby.
        :type user_principal_name: str
        :param user_type: A string value that can be used to classify user types in your directory,
         such as 'Member' and 'Guest'. Supports $filter.
        :type user_type: str
        :param assignments: List of assignments for the user. Nullable.
        :type assignments: list[~education.models.MicrosoftGraphEducationAssignment]
        :param rubrics:
        :type rubrics: list[~education.models.MicrosoftGraphEducationRubric]
        :param classes: Classes to which the user belongs. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param schools: Schools to which the user belongs. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param taught_classes:
        :type taught_classes: list[~education.models.MicrosoftGraphEducationClass]
        :param user: Represents an Azure Active Directory user object.
        :type user: ~education.models.MicrosoftGraphUser
        :param immutable_id:
        :type immutable_id: str
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationUser, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationUser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationUser(id=id, related_contacts=related_contacts, account_enabled=account_enabled, assigned_licenses=assigned_licenses, assigned_plans=assigned_plans, business_phones=business_phones, department=department, display_name=display_name, external_source=external_source, external_source_detail=external_source_detail, given_name=given_name, mail=mail, mailing_address=mailing_address, mail_nickname=mail_nickname, middle_name=middle_name, mobile_phone=mobile_phone, office_location=office_location, password_policies=password_policies, password_profile=password_profile, preferred_language=preferred_language, primary_role=primary_role, provisioned_plans=provisioned_plans, refresh_tokens_valid_from_date_time=refresh_tokens_valid_from_date_time, residence_address=residence_address, show_in_address_list=show_in_address_list, student=student, surname=surname, teacher=teacher, usage_location=usage_location, user_principal_name=user_principal_name, user_type=user_type, assignments=assignments, rubrics=rubrics, classes=classes, schools=schools, taught_classes=taught_classes, user=user, immutable_id=immutable_id, application=application, device=device, user_created_by_user=microsoft_graph_identity_user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationUser')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_user.metadata = {'url': '/education/users'}  # type: ignore

    async def get_user(
        self,
        education_user_id: str,
        select: Optional[List[Union[str, "models.Enum249"]]] = None,
        expand: Optional[List[Union[str, "models.Enum250"]]] = None,
        **kwargs
    ) -> "models.MicrosoftGraphEducationUser":
        """Get users from education.

        Get users from education.

        :param education_user_id: key: id of educationUser.
        :type education_user_id: str
        :param select: Select properties to be returned.
        :type select: list[str or ~education.models.Enum249]
        :param expand: Expand related entities.
        :type expand: list[str or ~education.models.Enum250]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MicrosoftGraphEducationUser, or the result of cls(response)
        :rtype: ~education.models.MicrosoftGraphEducationUser
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MicrosoftGraphEducationUser"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationUser-id': self._serialize.url("education_user_id", education_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if select is not None:
            query_parameters['$select'] = self._serialize.query("select", select, '[str]', div=',')
        if expand is not None:
            query_parameters['$expand'] = self._serialize.query("expand", expand, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = self._deserialize('MicrosoftGraphEducationUser', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user.metadata = {'url': '/education/users/{educationUser-id}'}  # type: ignore

    async def update_user(
        self,
        education_user_id: str,
        id: Optional[str] = None,
        related_contacts: Optional[List["models.MicrosoftGraphRelatedContact"]] = None,
        account_enabled: Optional[bool] = None,
        assigned_licenses: Optional[List["models.MicrosoftGraphAssignedLicense"]] = None,
        assigned_plans: Optional[List["models.MicrosoftGraphAssignedPlan"]] = None,
        business_phones: Optional[List[str]] = None,
        department: Optional[str] = None,
        display_name: Optional[str] = None,
        external_source: Optional[Union[str, "models.MicrosoftGraphEducationExternalSource"]] = None,
        external_source_detail: Optional[str] = None,
        given_name: Optional[str] = None,
        mail: Optional[str] = None,
        mailing_address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        mail_nickname: Optional[str] = None,
        middle_name: Optional[str] = None,
        mobile_phone: Optional[str] = None,
        office_location: Optional[str] = None,
        password_policies: Optional[str] = None,
        password_profile: Optional["models.MicrosoftGraphPasswordProfile"] = None,
        preferred_language: Optional[str] = None,
        primary_role: Optional[Union[str, "models.MicrosoftGraphEducationUserRole"]] = None,
        provisioned_plans: Optional[List["models.MicrosoftGraphProvisionedPlan"]] = None,
        refresh_tokens_valid_from_date_time: Optional[datetime.datetime] = None,
        residence_address: Optional["models.MicrosoftGraphPhysicalAddress"] = None,
        show_in_address_list: Optional[bool] = None,
        student: Optional["models.MicrosoftGraphEducationStudent"] = None,
        surname: Optional[str] = None,
        teacher: Optional["models.MicrosoftGraphEducationTeacher"] = None,
        usage_location: Optional[str] = None,
        user_principal_name: Optional[str] = None,
        user_type: Optional[str] = None,
        assignments: Optional[List["models.MicrosoftGraphEducationAssignment"]] = None,
        rubrics: Optional[List["models.MicrosoftGraphEducationRubric"]] = None,
        classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        schools: Optional[List["models.MicrosoftGraphEducationSchool"]] = None,
        taught_classes: Optional[List["models.MicrosoftGraphEducationClass"]] = None,
        user: Optional["models.MicrosoftGraphUser"] = None,
        immutable_id: Optional[str] = None,
        application: Optional["models.MicrosoftGraphIdentity"] = None,
        device: Optional["models.MicrosoftGraphIdentity"] = None,
        microsoft_graph_identity_user: Optional["models.MicrosoftGraphIdentity"] = None,
        **kwargs
    ) -> None:
        """Update the navigation property users in education.

        Update the navigation property users in education.

        :param education_user_id: key: id of educationUser.
        :type education_user_id: str
        :param id: Read-only.
        :type id: str
        :param related_contacts: Set of contacts related to the user.  This optional property must be
         specified in a $select clause and can only be retrieved for an individual user.
        :type related_contacts: list[~education.models.MicrosoftGraphRelatedContact]
        :param account_enabled: True if the account is enabled; otherwise, false. This property is
         required when a user is created. Supports $filter.
        :type account_enabled: bool
        :param assigned_licenses: The licenses that are assigned to the user. Not nullable.
        :type assigned_licenses: list[~education.models.MicrosoftGraphAssignedLicense]
        :param assigned_plans: The plans that are assigned to the user. Read-only. Not nullable.
        :type assigned_plans: list[~education.models.MicrosoftGraphAssignedPlan]
        :param business_phones: The telephone numbers for the user. Note: Although this is a string
         collection, only one number can be set for this property.
        :type business_phones: list[str]
        :param department: The name for the department in which the user works. Supports $filter.
        :type department: str
        :param display_name: The name displayed in the address book for the user. This is usually the
         combination of the user's first name, middle initial, and last name. This property is required
         when a user is created and it cannot be cleared during updates. Supports $filter and $orderby.
        :type display_name: str
        :param external_source:
        :type external_source: str or ~education.models.MicrosoftGraphEducationExternalSource
        :param external_source_detail:
        :type external_source_detail: str
        :param given_name: The given name (first name) of the user. Supports $filter.
        :type given_name: str
        :param mail: The SMTP address for the user; for example, 'jeff@contoso.onmicrosoft.com'. Read-
         Only. Supports $filter.
        :type mail: str
        :param mailing_address: physicalAddress.
        :type mailing_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param mail_nickname: The mail alias for the user. This property must be specified when a user
         is created. Supports $filter.
        :type mail_nickname: str
        :param middle_name: The middle name of user.
        :type middle_name: str
        :param mobile_phone: The primary cellular telephone number for the user.
        :type mobile_phone: str
        :param office_location:
        :type office_location: str
        :param password_policies: Specifies password policies for the user. This value is an
         enumeration with one possible value being 'DisableStrongPassword', which allows weaker
         passwords than the default policy to be specified. 'DisablePasswordExpiration' can also be
         specified. The two can be specified together; for example: 'DisablePasswordExpiration,
         DisableStrongPassword'.
        :type password_policies: str
        :param password_profile: passwordProfile.
        :type password_profile: ~education.models.MicrosoftGraphPasswordProfile
        :param preferred_language: The preferred language for the user. Should follow ISO 639-1 Code;
         for example, 'en-US'.
        :type preferred_language: str
        :param primary_role:
        :type primary_role: str or ~education.models.MicrosoftGraphEducationUserRole
        :param provisioned_plans: The plans that are provisioned for the user. Read-only. Not nullable.
        :type provisioned_plans: list[~education.models.MicrosoftGraphProvisionedPlan]
        :param refresh_tokens_valid_from_date_time:
        :type refresh_tokens_valid_from_date_time: ~datetime.datetime
        :param residence_address: physicalAddress.
        :type residence_address: ~education.models.MicrosoftGraphPhysicalAddress
        :param show_in_address_list:
        :type show_in_address_list: bool
        :param student: educationStudent.
        :type student: ~education.models.MicrosoftGraphEducationStudent
        :param surname: The user's surname (family name or last name). Supports $filter.
        :type surname: str
        :param teacher: educationTeacher.
        :type teacher: ~education.models.MicrosoftGraphEducationTeacher
        :param usage_location: A two-letter country code (ISO standard 3166). Required for users who
         will be assigned licenses due to a legal requirement to check for availability of services in
         countries or regions. Examples include: 'US', 'JP', and 'GB'. Not nullable. Supports $filter.
        :type usage_location: str
        :param user_principal_name: The user principal name (UPN) of the user. The UPN is an Internet-
         style login name for the user based on the Internet standard RFC 822. By convention, this
         should map to the user's email name. The general format is alias@domain, where domain must be
         present in the tenant's collection of verified domains. This property is required when a user
         is created. The verified domains for the tenant can be accessed from the verifiedDomains
         property of organization. Supports $filter and $orderby.
        :type user_principal_name: str
        :param user_type: A string value that can be used to classify user types in your directory,
         such as 'Member' and 'Guest'. Supports $filter.
        :type user_type: str
        :param assignments: List of assignments for the user. Nullable.
        :type assignments: list[~education.models.MicrosoftGraphEducationAssignment]
        :param rubrics:
        :type rubrics: list[~education.models.MicrosoftGraphEducationRubric]
        :param classes: Classes to which the user belongs. Nullable.
        :type classes: list[~education.models.MicrosoftGraphEducationClass]
        :param schools: Schools to which the user belongs. Nullable.
        :type schools: list[~education.models.MicrosoftGraphEducationSchool]
        :param taught_classes:
        :type taught_classes: list[~education.models.MicrosoftGraphEducationClass]
        :param user: Represents an Azure Active Directory user object.
        :type user: ~education.models.MicrosoftGraphUser
        :param immutable_id:
        :type immutable_id: str
        :param application: identity.
        :type application: ~education.models.MicrosoftGraphIdentity
        :param device: identity.
        :type device: ~education.models.MicrosoftGraphIdentity
        :param microsoft_graph_identity_user: identity.
        :type microsoft_graph_identity_user: ~education.models.MicrosoftGraphIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        body = models.MicrosoftGraphEducationUser(id=id, related_contacts=related_contacts, account_enabled=account_enabled, assigned_licenses=assigned_licenses, assigned_plans=assigned_plans, business_phones=business_phones, department=department, display_name=display_name, external_source=external_source, external_source_detail=external_source_detail, given_name=given_name, mail=mail, mailing_address=mailing_address, mail_nickname=mail_nickname, middle_name=middle_name, mobile_phone=mobile_phone, office_location=office_location, password_policies=password_policies, password_profile=password_profile, preferred_language=preferred_language, primary_role=primary_role, provisioned_plans=provisioned_plans, refresh_tokens_valid_from_date_time=refresh_tokens_valid_from_date_time, residence_address=residence_address, show_in_address_list=show_in_address_list, student=student, surname=surname, teacher=teacher, usage_location=usage_location, user_principal_name=user_principal_name, user_type=user_type, assignments=assignments, rubrics=rubrics, classes=classes, schools=schools, taught_classes=taught_classes, user=user, immutable_id=immutable_id, application=application, device=device, user_created_by_user=microsoft_graph_identity_user)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationUser-id': self._serialize.url("education_user_id", education_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(body, 'MicrosoftGraphEducationUser')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    update_user.metadata = {'url': '/education/users/{educationUser-id}'}  # type: ignore

    async def delete_user(
        self,
        education_user_id: str,
        if_match: Optional[str] = None,
        **kwargs
    ) -> None:
        """Delete navigation property users for education.

        Delete navigation property users for education.

        :param education_user_id: key: id of educationUser.
        :type education_user_id: str
        :param if_match: ETag.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'educationUser-id': self._serialize.url("education_user_id", education_user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.OdataError, response)
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})

    delete_user.metadata = {'url': '/education/users/{educationUser-id}'}  # type: ignore
