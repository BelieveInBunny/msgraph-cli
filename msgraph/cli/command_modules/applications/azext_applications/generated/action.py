# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddApplicationsApplicationAppRoles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationAppRoles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allowed-member-types':
                d['allowed_member_types'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            elif kl == 'is-enabled':
                d['is_enabled'] = v[0]
            elif kl == 'origin':
                d['origin'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter app_roles. All possible keys are: '
                               'allowed-member-types, description, display-name, id, is-enabled, origin, value'.format(k))
        return d


class AddInfo(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.info = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'logo-url':
                d['logo_url'] = v[0]
            elif kl == 'marketing-url':
                d['marketing_url'] = v[0]
            elif kl == 'privacy-statement-url':
                d['privacy_statement_url'] = v[0]
            elif kl == 'support-url':
                d['support_url'] = v[0]
            elif kl == 'terms-of-service-url':
                d['terms_of_service_url'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter info. All possible keys are: logo-url, '
                               'marketing-url, privacy-statement-url, support-url, terms-of-service-url'.format(k))
        return d


class AddApplicationsApplicationKeyCredentials(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationKeyCredentials, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'custom-key-identifier':
                d['custom_key_identifier'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'key':
                d['key'] = v[0]
            elif kl == 'key-id':
                d['key_id'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'usage':
                d['usage'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter key_credentials. All possible keys are: '
                               'custom-key-identifier, display-name, end-date-time, key, key-id, start-date-time, '
                               'type, usage'.format(k))
        return d


class AddParentalControlSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.parental_control_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'countries-blocked-for-minors':
                d['countries_blocked_for_minors'] = v
            elif kl == 'legal-age-group-rule':
                d['legal_age_group_rule'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter parental_control_settings. All possible '
                               'keys are: countries-blocked-for-minors, legal-age-group-rule'.format(k))
        return d


class AddApplicationsApplicationPasswordCredentials(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationPasswordCredentials, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'custom-key-identifier':
                d['custom_key_identifier'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'hint':
                d['hint'] = v[0]
            elif kl == 'key-id':
                d['key_id'] = v[0]
            elif kl == 'secret-text':
                d['secret_text'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter password_credentials. All possible keys '
                               'are: custom-key-identifier, display-name, end-date-time, hint, key-id, secret-text, '
                               'start-date-time'.format(k))
        return d


class AddPublicClient(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.public_client = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'redirect-uris':
                d['redirect_uris'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter public_client. All possible keys are: '
                               'redirect-uris'.format(k))
        return d


class AddCreatedOnBehalfOf(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.created_on_behalf_of = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter created_on_behalf_of. All possible keys '
                               'are: deleted-date-time, id'.format(k))
        return d


class AddExtensionProperties(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExtensionProperties, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-display-name':
                d['app_display_name'] = v[0]
            elif kl == 'data-type':
                d['data_type'] = v[0]
            elif kl == 'is-synced-from-on-premises':
                d['is_synced_from_on_premises'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'target-objects':
                d['target_objects'] = v
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter extension_properties. All possible keys '
                               'are: app-display-name, data-type, is-synced-from-on-premises, name, target-objects, '
                               'deleted-date-time, id'.format(k))
        return d


class AddApplicationsApplicationHomeRealmDiscoveryPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationHomeRealmDiscoveryPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter home_realm_discovery_policies. All '
                               'possible keys are: definition, is-organization-default, applies-to, description, '
                               'display-name, deleted-date-time, id'.format(k))
        return d


class AddApplicationsApplicationOwners(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationOwners, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter owners. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddApplicationsApplicationTokenIssuancePolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationTokenIssuancePolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter token_issuance_policies. All possible '
                               'keys are: definition, is-organization-default, applies-to, description, display-name, '
                               'deleted-date-time, id'.format(k))
        return d


class AddApplicationsApplicationTokenLifetimePolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationTokenLifetimePolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter token_lifetime_policies. All possible '
                               'keys are: definition, is-organization-default, applies-to, description, display-name, '
                               'deleted-date-time, id'.format(k))
        return d


class AddImplicitGrantSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.implicit_grant_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'enable-access-token-issuance':
                d['enable_access_token_issuance'] = v[0]
            elif kl == 'enable-id-token-issuance':
                d['enable_id_token_issuance'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter implicit_grant_settings. All possible '
                               'keys are: enable-access-token-issuance, enable-id-token-issuance'.format(k))
        return d


class AddAccessToken(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAccessToken, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'additional-properties':
                d['additional_properties'] = v
            elif kl == 'essential':
                d['essential'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter access_token. All possible keys are: '
                               'additional-properties, essential, name, source'.format(k))
        return d


class AddIdToken(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIdToken, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'additional-properties':
                d['additional_properties'] = v
            elif kl == 'essential':
                d['essential'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter id_token. All possible keys are: '
                               'additional-properties, essential, name, source'.format(k))
        return d


class AddSaml2Token(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSaml2Token, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'additional-properties':
                d['additional_properties'] = v
            elif kl == 'essential':
                d['essential'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'source':
                d['source'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter saml2_token. All possible keys are: '
                               'additional-properties, essential, name, source'.format(k))
        return d


class AddApplicationsApplicationOauth2PermissionScopes(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddApplicationsApplicationOauth2PermissionScopes, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'admin-consent-description':
                d['admin_consent_description'] = v[0]
            elif kl == 'admin-consent-display-name':
                d['admin_consent_display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            elif kl == 'is-enabled':
                d['is_enabled'] = v[0]
            elif kl == 'origin':
                d['origin'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'user-consent-description':
                d['user_consent_description'] = v[0]
            elif kl == 'user-consent-display-name':
                d['user_consent_display_name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter oauth2_permission_scopes. All possible '
                               'keys are: admin-consent-description, admin-consent-display-name, id, is-enabled, '
                               'origin, type, user-consent-description, user-consent-display-name, value'.format(k))
        return d


class AddPreAuthorizedApplications(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPreAuthorizedApplications, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-id':
                d['app_id'] = v[0]
            elif kl == 'delegated-permission-ids':
                d['delegated_permission_ids'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter pre_authorized_applications. All possible '
                               'keys are: app-id, delegated-permission-ids'.format(k))
        return d


class AddKeyCredential(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.key_credential = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'custom-key-identifier':
                d['custom_key_identifier'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'key':
                d['key'] = v[0]
            elif kl == 'key-id':
                d['key_id'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'usage':
                d['usage'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter key_credential. All possible keys are: '
                               'custom-key-identifier, display-name, end-date-time, key, key-id, start-date-time, '
                               'type, usage'.format(k))
        return d


class AddPasswordCredential(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.password_credential = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'custom-key-identifier':
                d['custom_key_identifier'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'hint':
                d['hint'] = v[0]
            elif kl == 'key-id':
                d['key_id'] = v[0]
            elif kl == 'secret-text':
                d['secret_text'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter password_credential. All possible keys '
                               'are: custom-key-identifier, display-name, end-date-time, hint, key-id, secret-text, '
                               'start-date-time'.format(k))
        return d


class AddServiceprincipalsServiceprincipalAppRoles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalAppRoles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allowed-member-types':
                d['allowed_member_types'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            elif kl == 'is-enabled':
                d['is_enabled'] = v[0]
            elif kl == 'origin':
                d['origin'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter app_roles. All possible keys are: '
                               'allowed-member-types, description, display-name, id, is-enabled, origin, value'.format(k))
        return d


class AddServiceprincipalsServiceprincipalKeyCredentials(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalKeyCredentials, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'custom-key-identifier':
                d['custom_key_identifier'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'key':
                d['key'] = v[0]
            elif kl == 'key-id':
                d['key_id'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'usage':
                d['usage'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter key_credentials. All possible keys are: '
                               'custom-key-identifier, display-name, end-date-time, key, key-id, start-date-time, '
                               'type, usage'.format(k))
        return d


class AddServiceprincipalsServiceprincipalOauth2PermissionScopes(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalOauth2PermissionScopes, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'admin-consent-description':
                d['admin_consent_description'] = v[0]
            elif kl == 'admin-consent-display-name':
                d['admin_consent_display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            elif kl == 'is-enabled':
                d['is_enabled'] = v[0]
            elif kl == 'origin':
                d['origin'] = v[0]
            elif kl == 'type':
                d['type'] = v[0]
            elif kl == 'user-consent-description':
                d['user_consent_description'] = v[0]
            elif kl == 'user-consent-display-name':
                d['user_consent_display_name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter oauth2_permission_scopes. All possible '
                               'keys are: admin-consent-description, admin-consent-display-name, id, is-enabled, '
                               'origin, type, user-consent-description, user-consent-display-name, value'.format(k))
        return d


class AddServiceprincipalsServiceprincipalPasswordCredentials(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalPasswordCredentials, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'custom-key-identifier':
                d['custom_key_identifier'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'hint':
                d['hint'] = v[0]
            elif kl == 'key-id':
                d['key_id'] = v[0]
            elif kl == 'secret-text':
                d['secret_text'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter password_credentials. All possible keys '
                               'are: custom-key-identifier, display-name, end-date-time, hint, key-id, secret-text, '
                               'start-date-time'.format(k))
        return d


class AddAppRoleAssignedTo(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppRoleAssignedTo, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-role-id':
                d['app_role_id'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'principal-display-name':
                d['principal_display_name'] = v[0]
            elif kl == 'principal-id':
                d['principal_id'] = v[0]
            elif kl == 'principal-type':
                d['principal_type'] = v[0]
            elif kl == 'resource-display-name':
                d['resource_display_name'] = v[0]
            elif kl == 'resource-id':
                d['resource_id'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter app_role_assigned_to. All possible keys '
                               'are: app-role-id, created-date-time, principal-display-name, principal-id, '
                               'principal-type, resource-display-name, resource-id, deleted-date-time, id'.format(k))
        return d


class AddAppRoleAssignments(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppRoleAssignments, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-role-id':
                d['app_role_id'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'principal-display-name':
                d['principal_display_name'] = v[0]
            elif kl == 'principal-id':
                d['principal_id'] = v[0]
            elif kl == 'principal-type':
                d['principal_type'] = v[0]
            elif kl == 'resource-display-name':
                d['resource_display_name'] = v[0]
            elif kl == 'resource-id':
                d['resource_id'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter app_role_assignments. All possible keys '
                               'are: app-role-id, created-date-time, principal-display-name, principal-id, '
                               'principal-type, resource-display-name, resource-id, deleted-date-time, id'.format(k))
        return d


class AddClaimsMappingPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddClaimsMappingPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter claims_mapping_policies. All possible '
                               'keys are: definition, is-organization-default, applies-to, description, display-name, '
                               'deleted-date-time, id'.format(k))
        return d


class AddCreatedObjects(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCreatedObjects, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter created_objects. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddEndpoints(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEndpoints, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'capability':
                d['capability'] = v[0]
            elif kl == 'provider-id':
                d['provider_id'] = v[0]
            elif kl == 'provider-name':
                d['provider_name'] = v[0]
            elif kl == 'provider-resource-id':
                d['provider_resource_id'] = v[0]
            elif kl == 'uri':
                d['uri'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter endpoints. All possible keys are: '
                               'capability, provider-id, provider-name, provider-resource-id, uri, deleted-date-time, '
                               'id'.format(k))
        return d


class AddServiceprincipalsServiceprincipalHomeRealmDiscoveryPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalHomeRealmDiscoveryPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter home_realm_discovery_policies. All '
                               'possible keys are: definition, is-organization-default, applies-to, description, '
                               'display-name, deleted-date-time, id'.format(k))
        return d


class AddMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMemberOf, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter member_of. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddOauth2PermissionGrants(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOauth2PermissionGrants, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'client-id':
                d['client_id'] = v[0]
            elif kl == 'consent-type':
                d['consent_type'] = v[0]
            elif kl == 'principal-id':
                d['principal_id'] = v[0]
            elif kl == 'resource-id':
                d['resource_id'] = v[0]
            elif kl == 'scope':
                d['scope'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter oauth2_permission_grants. All possible '
                               'keys are: client-id, consent-type, principal-id, resource-id, scope, id'.format(k))
        return d


class AddOwnedObjects(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOwnedObjects, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter owned_objects. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddServiceprincipalsServiceprincipalOwners(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalOwners, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter owners. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddServiceprincipalsServiceprincipalTokenIssuancePolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalTokenIssuancePolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter token_issuance_policies. All possible '
                               'keys are: definition, is-organization-default, applies-to, description, display-name, '
                               'deleted-date-time, id'.format(k))
        return d


class AddServiceprincipalsServiceprincipalTokenLifetimePolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddServiceprincipalsServiceprincipalTokenLifetimePolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'definition':
                d['definition'] = v
            elif kl == 'is-organization-default':
                d['is_organization_default'] = v[0]
            elif kl == 'applies-to':
                d['applies_to'] = v
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter token_lifetime_policies. All possible '
                               'keys are: definition, is-organization-default, applies-to, description, display-name, '
                               'deleted-date-time, id'.format(k))
        return d


class AddTransitiveMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTransitiveMemberOf, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter transitive_member_of. All possible keys '
                               'are: deleted-date-time, id'.format(k))
        return d
