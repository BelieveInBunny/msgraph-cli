# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddMobileAppCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMobileAppCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter mobile_app_categories. All possible keys '
                               'are: display-name, last-modified-date-time, id'.format(k))
        return d


class AddVppTokens(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddVppTokens, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'apple-id':
                d['apple_id'] = v[0]
            elif kl == 'automatically-update-apps':
                d['automatically_update_apps'] = v[0]
            elif kl == 'country-or-region':
                d['country_or_region'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            elif kl == 'last-sync-status':
                d['last_sync_status'] = v[0]
            elif kl == 'organization-name':
                d['organization_name'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'token':
                d['token'] = v[0]
            elif kl == 'vpp-token-account-type':
                d['vpp_token_account_type'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter vpp_tokens. All possible keys are: '
                               'apple-id, automatically-update-apps, country-or-region, expiration-date-time, '
                               'last-modified-date-time, last-sync-date-time, last-sync-status, organization-name, '
                               'state, token, vpp-token-account-type, id'.format(k))
        return d


class AddManagedAppPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddManagedAppPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter managed_app_policies. All possible keys '
                               'are: created-date-time, description, display-name, last-modified-date-time, version, '
                               'id'.format(k))
        return d


class AddManagedAppStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddManagedAppStatuses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter managed_app_statuses. All possible keys '
                               'are: display-name, version, id'.format(k))
        return d


class AddMdmWindowsInformationProtectionPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMdmWindowsInformationProtectionPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'azure-rights-management-services-allowed':
                d['azure_rights_management_services_allowed'] = v[0]
            elif kl == 'data-recovery-certificate':
                d['data_recovery_certificate'] = v[0]
            elif kl == 'enforcement-level':
                d['enforcement_level'] = v[0]
            elif kl == 'enterprise-domain':
                d['enterprise_domain'] = v[0]
            elif kl == 'enterprise-internal-proxy-servers':
                d['enterprise_internal_proxy_servers'] = v
            elif kl == 'enterprise-ip-ranges':
                d['enterprise_ip_ranges'] = v
            elif kl == 'enterprise-ip-ranges-are-authoritative':
                d['enterprise_ip_ranges_are_authoritative'] = v[0]
            elif kl == 'enterprise-network-domain-names':
                d['enterprise_network_domain_names'] = v
            elif kl == 'enterprise-protected-domain-names':
                d['enterprise_protected_domain_names'] = v
            elif kl == 'enterprise-proxied-domains':
                d['enterprise_proxied_domains'] = v
            elif kl == 'enterprise-proxy-servers':
                d['enterprise_proxy_servers'] = v
            elif kl == 'enterprise-proxy-servers-are-authoritative':
                d['enterprise_proxy_servers_are_authoritative'] = v[0]
            elif kl == 'exempt-apps':
                d['exempt_apps'] = v
            elif kl == 'icons-visible':
                d['icons_visible'] = v[0]
            elif kl == 'indexing-encrypted-stores-or-items-blocked':
                d['indexing_encrypted_stores_or_items_blocked'] = v[0]
            elif kl == 'is-assigned':
                d['is_assigned'] = v[0]
            elif kl == 'neutral-domain-resources':
                d['neutral_domain_resources'] = v
            elif kl == 'protected-apps':
                d['protected_apps'] = v
            elif kl == 'protection-under-lock-config-required':
                d['protection_under_lock_config_required'] = v[0]
            elif kl == 'revoke-on-unenroll-disabled':
                d['revoke_on_unenroll_disabled'] = v[0]
            elif kl == 'rights-management-services-template-id':
                d['rights_management_services_template_id'] = v[0]
            elif kl == 'smb-auto-encrypted-file-extensions':
                d['smb_auto_encrypted_file_extensions'] = v
            elif kl == 'assignments':
                d['assignments'] = v
            elif kl == 'exempt-app-locker-files':
                d['exempt_app_locker_files'] = v
            elif kl == 'protected-app-locker-files':
                d['protected_app_locker_files'] = v
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter mdm_windows_information_protection_policie'
                               's. All possible keys are: azure-rights-management-services-allowed, '
                               'data-recovery-certificate, enforcement-level, enterprise-domain, '
                               'enterprise-internal-proxy-servers, enterprise-ip-ranges, '
                               'enterprise-ip-ranges-are-authoritative, enterprise-network-domain-names, '
                               'enterprise-protected-domain-names, enterprise-proxied-domains, '
                               'enterprise-proxy-servers, enterprise-proxy-servers-are-authoritative, exempt-apps, '
                               'icons-visible, indexing-encrypted-stores-or-items-blocked, is-assigned, '
                               'neutral-domain-resources, protected-apps, protection-under-lock-config-required, '
                               'revoke-on-unenroll-disabled, rights-management-services-template-id, '
                               'smb-auto-encrypted-file-extensions, assignments, exempt-app-locker-files, '
                               'protected-app-locker-files, created-date-time, description, display-name, '
                               'last-modified-date-time, version, id'.format(k))
        return d


class AddWindowsInformationProtectionPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddWindowsInformationProtectionPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'days-without-contact-before-unenroll':
                d['days_without_contact_before_unenroll'] = v[0]
            elif kl == 'mdm-enrollment-url':
                d['mdm_enrollment_url'] = v[0]
            elif kl == 'minutes-of-inactivity-before-device-lock':
                d['minutes_of_inactivity_before_device_lock'] = v[0]
            elif kl == 'number-of-past-pins-remembered':
                d['number_of_past_pins_remembered'] = v[0]
            elif kl == 'password-maximum-attempt-count':
                d['password_maximum_attempt_count'] = v[0]
            elif kl == 'pin-expiration-days':
                d['pin_expiration_days'] = v[0]
            elif kl == 'pin-lowercase-letters':
                d['pin_lowercase_letters'] = v[0]
            elif kl == 'pin-minimum-length':
                d['pin_minimum_length'] = v[0]
            elif kl == 'pin-special-characters':
                d['pin_special_characters'] = v[0]
            elif kl == 'pin-uppercase-letters':
                d['pin_uppercase_letters'] = v[0]
            elif kl == 'revoke-on-mdm-handoff-disabled':
                d['revoke_on_mdm_handoff_disabled'] = v[0]
            elif kl == 'windows-hello-for-business-blocked':
                d['windows_hello_for_business_blocked'] = v[0]
            elif kl == 'azure-rights-management-services-allowed':
                d['azure_rights_management_services_allowed'] = v[0]
            elif kl == 'data-recovery-certificate':
                d['data_recovery_certificate'] = v[0]
            elif kl == 'enforcement-level':
                d['enforcement_level'] = v[0]
            elif kl == 'enterprise-domain':
                d['enterprise_domain'] = v[0]
            elif kl == 'enterprise-internal-proxy-servers':
                d['enterprise_internal_proxy_servers'] = v
            elif kl == 'enterprise-ip-ranges':
                d['enterprise_ip_ranges'] = v
            elif kl == 'enterprise-ip-ranges-are-authoritative':
                d['enterprise_ip_ranges_are_authoritative'] = v[0]
            elif kl == 'enterprise-network-domain-names':
                d['enterprise_network_domain_names'] = v
            elif kl == 'enterprise-protected-domain-names':
                d['enterprise_protected_domain_names'] = v
            elif kl == 'enterprise-proxied-domains':
                d['enterprise_proxied_domains'] = v
            elif kl == 'enterprise-proxy-servers':
                d['enterprise_proxy_servers'] = v
            elif kl == 'enterprise-proxy-servers-are-authoritative':
                d['enterprise_proxy_servers_are_authoritative'] = v[0]
            elif kl == 'exempt-apps':
                d['exempt_apps'] = v
            elif kl == 'icons-visible':
                d['icons_visible'] = v[0]
            elif kl == 'indexing-encrypted-stores-or-items-blocked':
                d['indexing_encrypted_stores_or_items_blocked'] = v[0]
            elif kl == 'is-assigned':
                d['is_assigned'] = v[0]
            elif kl == 'neutral-domain-resources':
                d['neutral_domain_resources'] = v
            elif kl == 'protected-apps':
                d['protected_apps'] = v
            elif kl == 'protection-under-lock-config-required':
                d['protection_under_lock_config_required'] = v[0]
            elif kl == 'revoke-on-unenroll-disabled':
                d['revoke_on_unenroll_disabled'] = v[0]
            elif kl == 'rights-management-services-template-id':
                d['rights_management_services_template_id'] = v[0]
            elif kl == 'smb-auto-encrypted-file-extensions':
                d['smb_auto_encrypted_file_extensions'] = v
            elif kl == 'assignments':
                d['assignments'] = v
            elif kl == 'exempt-app-locker-files':
                d['exempt_app_locker_files'] = v
            elif kl == 'protected-app-locker-files':
                d['protected_app_locker_files'] = v
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter windows_information_protection_policies. '
                               'All possible keys are: days-without-contact-before-unenroll, mdm-enrollment-url, '
                               'minutes-of-inactivity-before-device-lock, number-of-past-pins-remembered, '
                               'password-maximum-attempt-count, pin-expiration-days, pin-lowercase-letters, '
                               'pin-minimum-length, pin-special-characters, pin-uppercase-letters, '
                               'revoke-on-mdm-handoff-disabled, windows-hello-for-business-blocked, '
                               'azure-rights-management-services-allowed, data-recovery-certificate, '
                               'enforcement-level, enterprise-domain, enterprise-internal-proxy-servers, '
                               'enterprise-ip-ranges, enterprise-ip-ranges-are-authoritative, '
                               'enterprise-network-domain-names, enterprise-protected-domain-names, '
                               'enterprise-proxied-domains, enterprise-proxy-servers, enterprise-proxy-servers-are-auth'
                               'oritative, exempt-apps, icons-visible, indexing-encrypted-stores-or-items-blocked, '
                               'is-assigned, neutral-domain-resources, protected-apps, protection-under-lock-config-req'
                               'uired, revoke-on-unenroll-disabled, rights-management-services-template-id, '
                               'smb-auto-encrypted-file-extensions, assignments, exempt-app-locker-files, '
                               'protected-app-locker-files, created-date-time, description, display-name, '
                               'last-modified-date-time, version, id'.format(k))
        return d


class AddDevicescorpmgtDeviceAppManagementCreateDefaultManagedAppProtectionCustomSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDevicescorpmgtDeviceAppManagementCreateDefaultManagedAppProtectionCustomSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter custom_settings. All possible keys are: '
                               'name, value'.format(k))
        return d


class AddAppliedPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppliedPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter applied_policies. All possible keys are: '
                               'created-date-time, description, display-name, last-modified-date-time, version, id'.
                               format(k))
        return d


class AddIntendedPolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddIntendedPolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter intended_policies. All possible keys are: '
                               'created-date-time, description, display-name, last-modified-date-time, version, id'.
                               format(k))
        return d


class AddOperations(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOperations, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter operations. All possible keys are: '
                               'display-name, last-modified-date-time, state, version, id'.format(k))
        return d


class AddLargeCover(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.large_cover = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter large_cover. All possible keys are: type, '
                               'value'.format(k))
        return d


class AddDeviceappmanagementDeviceStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceappmanagementDeviceStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'device-id':
                d['device_id'] = v[0]
            elif kl == 'device-name':
                d['device_name'] = v[0]
            elif kl == 'error-code':
                d['error_code'] = v[0]
            elif kl == 'install-state':
                d['install_state'] = v[0]
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            elif kl == 'os-description':
                d['os_description'] = v[0]
            elif kl == 'os-version':
                d['os_version'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_states. All possible keys are: '
                               'device-id, device-name, error-code, install-state, last-sync-date-time, '
                               'os-description, os-version, user-name, id'.format(k))
        return d


class AddInstallSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.install_summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'failed-device-count':
                d['failed_device_count'] = v[0]
            elif kl == 'failed-user-count':
                d['failed_user_count'] = v[0]
            elif kl == 'installed-device-count':
                d['installed_device_count'] = v[0]
            elif kl == 'installed-user-count':
                d['installed_user_count'] = v[0]
            elif kl == 'not-installed-device-count':
                d['not_installed_device_count'] = v[0]
            elif kl == 'not-installed-user-count':
                d['not_installed_user_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter install_summary. All possible keys are: '
                               'failed-device-count, failed-user-count, installed-device-count, installed-user-count, '
                               'not-installed-device-count, not-installed-user-count, id'.format(k))
        return d


class AddDataRecoveryCertificate(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.data_recovery_certificate = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'certificate':
                d['certificate'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'subject-name':
                d['subject_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter data_recovery_certificate. All possible '
                               'keys are: certificate, description, expiration-date-time, subject-name'.format(k))
        return d


class AddEnterpriseInternalProxyServers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseInternalProxyServers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise_internal_proxy_servers. All '
                               'possible keys are: display-name, resources'.format(k))
        return d


class AddEnterpriseNetworkDomainNames(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseNetworkDomainNames, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise_network_domain_names. All '
                               'possible keys are: display-name, resources'.format(k))
        return d


class AddEnterpriseProtectedDomainNames(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProtectedDomainNames, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise_protected_domain_names. All '
                               'possible keys are: display-name, resources'.format(k))
        return d


class AddEnterpriseProxyServers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddEnterpriseProxyServers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter enterprise_proxy_servers. All possible '
                               'keys are: display-name, resources'.format(k))
        return d


class AddExemptApps(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExemptApps, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'denied':
                d['denied'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'product-name':
                d['product_name'] = v[0]
            elif kl == 'publisher-name':
                d['publisher_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter exempt_apps. All possible keys are: '
                               'denied, description, display-name, product-name, publisher-name'.format(k))
        return d


class AddNeutralDomainResources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddNeutralDomainResources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter neutral_domain_resources. All possible '
                               'keys are: display-name, resources'.format(k))
        return d


class AddProtectedApps(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProtectedApps, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'denied':
                d['denied'] = v[0]
            elif kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'product-name':
                d['product_name'] = v[0]
            elif kl == 'publisher-name':
                d['publisher_name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter protected_apps. All possible keys are: '
                               'denied, description, display-name, product-name, publisher-name'.format(k))
        return d


class AddSmbAutoEncryptedFileExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSmbAutoEncryptedFileExtensions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'resources':
                d['resources'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter smb_auto_encrypted_file_extensions. All '
                               'possible keys are: display-name, resources'.format(k))
        return d


class AddExemptAppLockerFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExemptAppLockerFiles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'file':
                d['file'] = v[0]
            elif kl == 'file-hash':
                d['file_hash'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter exempt_app_locker_files. All possible '
                               'keys are: display-name, file, file-hash, version, id'.format(k))
        return d


class AddProtectedAppLockerFiles(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddProtectedAppLockerFiles, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'file':
                d['file'] = v[0]
            elif kl == 'file-hash':
                d['file_hash'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter protected_app_locker_files. All possible '
                               'keys are: display-name, file, file-hash, version, id'.format(k))
        return d


class AddCategories(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCategories, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter categories. All possible keys are: '
                               'display-name, last-modified-date-time, id'.format(k))
        return d


class AddDeviceStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceStatuses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'compliance-grace-period-expiration-date-time':
                d['compliance_grace_period_expiration_date_time'] = v[0]
            elif kl == 'device-display-name':
                d['device_display_name'] = v[0]
            elif kl == 'device-model':
                d['device_model'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_statuses. All possible keys are: '
                               'compliance-grace-period-expiration-date-time, device-display-name, device-model, '
                               'last-reported-date-time, status, user-name, user-principal-name, id'.format(k))
        return d


class AddDeviceStatusSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.device_status_summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'configuration-version':
                d['configuration_version'] = v[0]
            elif kl == 'error-count':
                d['error_count'] = v[0]
            elif kl == 'failed-count':
                d['failed_count'] = v[0]
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            elif kl == 'not-applicable-count':
                d['not_applicable_count'] = v[0]
            elif kl == 'pending-count':
                d['pending_count'] = v[0]
            elif kl == 'success-count':
                d['success_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_status_summary. All possible keys '
                               'are: configuration-version, error-count, failed-count, last-update-date-time, '
                               'not-applicable-count, pending-count, success-count, id'.format(k))
        return d


class AddUserStatuses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddUserStatuses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'devices-count':
                d['devices_count'] = v[0]
            elif kl == 'last-reported-date-time':
                d['last_reported_date_time'] = v[0]
            elif kl == 'status':
                d['status'] = v[0]
            elif kl == 'user-display-name':
                d['user_display_name'] = v[0]
            elif kl == 'user-principal-name':
                d['user_principal_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user_statuses. All possible keys are: '
                               'devices-count, last-reported-date-time, status, user-display-name, '
                               'user-principal-name, id'.format(k))
        return d


class AddUserStatusSummary(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.user_status_summary = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'configuration-version':
                d['configuration_version'] = v[0]
            elif kl == 'error-count':
                d['error_count'] = v[0]
            elif kl == 'failed-count':
                d['failed_count'] = v[0]
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            elif kl == 'not-applicable-count':
                d['not_applicable_count'] = v[0]
            elif kl == 'pending-count':
                d['pending_count'] = v[0]
            elif kl == 'success-count':
                d['success_count'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter user_status_summary. All possible keys '
                               'are: configuration-version, error-count, failed-count, last-update-date-time, '
                               'not-applicable-count, pending-count, success-count, id'.format(k))
        return d


class AddDevicescorpmgtDeviceAppManagementCreateTargetedManagedAppConfigurationCustomSettings(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDevicescorpmgtDeviceAppManagementCreateTargetedManagedAppConfigurationCustomSettings, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter custom_settings. All possible keys are: '
                               'name, value'.format(k))
        return d


class AddDeviceappmanagementManagedebooksDeviceStates(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceappmanagementManagedebooksDeviceStates, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'device-id':
                d['device_id'] = v[0]
            elif kl == 'device-name':
                d['device_name'] = v[0]
            elif kl == 'error-code':
                d['error_code'] = v[0]
            elif kl == 'install-state':
                d['install_state'] = v[0]
            elif kl == 'last-sync-date-time':
                d['last_sync_date_time'] = v[0]
            elif kl == 'os-description':
                d['os_description'] = v[0]
            elif kl == 'os-version':
                d['os_version'] = v[0]
            elif kl == 'user-name':
                d['user_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_states. All possible keys are: '
                               'device-id, device-name, error-code, install-state, last-sync-date-time, '
                               'os-description, os-version, user-name, id'.format(k))
        return d


class AddConfigurationManagerClientEnabledFeatures(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.configuration_manager_client_enabled_features = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'compliance-policy':
                d['compliance_policy'] = v[0]
            elif kl == 'device-configuration':
                d['device_configuration'] = v[0]
            elif kl == 'inventory':
                d['inventory'] = v[0]
            elif kl == 'modern-apps':
                d['modern_apps'] = v[0]
            elif kl == 'resource-access':
                d['resource_access'] = v[0]
            elif kl == 'windows-update-for-business':
                d['windows_update_for_business'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter configuration_manager_client_enabled_featu'
                               'res. All possible keys are: compliance-policy, device-configuration, inventory, '
                               'modern-apps, resource-access, windows-update-for-business'.format(k))
        return d


class AddDeviceActionResults(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddDeviceActionResults, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'action-name':
                d['action_name'] = v[0]
            elif kl == 'action-state':
                d['action_state'] = v[0]
            elif kl == 'last-updated-date-time':
                d['last_updated_date_time'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_action_results. All possible keys '
                               'are: action-name, action-state, last-updated-date-time, start-date-time'.format(k))
        return d


class AddDeviceHealthAttestationState(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.device_health_attestation_state = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'attestation-identity-key':
                d['attestation_identity_key'] = v[0]
            elif kl == 'bit-locker-status':
                d['bit_locker_status'] = v[0]
            elif kl == 'boot-app-security-version':
                d['boot_app_security_version'] = v[0]
            elif kl == 'boot-debugging':
                d['boot_debugging'] = v[0]
            elif kl == 'boot-manager-security-version':
                d['boot_manager_security_version'] = v[0]
            elif kl == 'boot-manager-version':
                d['boot_manager_version'] = v[0]
            elif kl == 'boot-revision-list-info':
                d['boot_revision_list_info'] = v[0]
            elif kl == 'code-integrity':
                d['code_integrity'] = v[0]
            elif kl == 'code-integrity-check-version':
                d['code_integrity_check_version'] = v[0]
            elif kl == 'code-integrity-policy':
                d['code_integrity_policy'] = v[0]
            elif kl == 'content-namespace-url':
                d['content_namespace_url'] = v[0]
            elif kl == 'content-version':
                d['content_version'] = v[0]
            elif kl == 'data-excution-policy':
                d['data_excution_policy'] = v[0]
            elif kl == 'device-health-attestation-status':
                d['device_health_attestation_status'] = v[0]
            elif kl == 'early-launch-anti-malware-driver-protection':
                d['early_launch_anti_malware_driver_protection'] = v[0]
            elif kl == 'health-attestation-supported-status':
                d['health_attestation_supported_status'] = v[0]
            elif kl == 'health-status-mismatch-info':
                d['health_status_mismatch_info'] = v[0]
            elif kl == 'issued-date-time':
                d['issued_date_time'] = v[0]
            elif kl == 'last-update-date-time':
                d['last_update_date_time'] = v[0]
            elif kl == 'operating-system-kernel-debugging':
                d['operating_system_kernel_debugging'] = v[0]
            elif kl == 'operating-system-rev-list-info':
                d['operating_system_rev_list_info'] = v[0]
            elif kl == 'pcr0':
                d['pcr0'] = v[0]
            elif kl == 'pcr-hash-algorithm':
                d['pcr_hash_algorithm'] = v[0]
            elif kl == 'reset-count':
                d['reset_count'] = v[0]
            elif kl == 'restart-count':
                d['restart_count'] = v[0]
            elif kl == 'safe-mode':
                d['safe_mode'] = v[0]
            elif kl == 'secure-boot':
                d['secure_boot'] = v[0]
            elif kl == 'secure-boot-configuration-policy-finger-print':
                d['secure_boot_configuration_policy_finger_print'] = v[0]
            elif kl == 'test-signing':
                d['test_signing'] = v[0]
            elif kl == 'tpm-version':
                d['tpm_version'] = v[0]
            elif kl == 'virtual-secure-mode':
                d['virtual_secure_mode'] = v[0]
            elif kl == 'windows-pe':
                d['windows_pe'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_health_attestation_state. All '
                               'possible keys are: attestation-identity-key, bit-locker-status, '
                               'boot-app-security-version, boot-debugging, boot-manager-security-version, '
                               'boot-manager-version, boot-revision-list-info, code-integrity, '
                               'code-integrity-check-version, code-integrity-policy, content-namespace-url, '
                               'content-version, data-excution-policy, device-health-attestation-status, '
                               'early-launch-anti-malware-driver-protection, health-attestation-supported-status, '
                               'health-status-mismatch-info, issued-date-time, last-update-date-time, '
                               'operating-system-kernel-debugging, operating-system-rev-list-info, pcr0, '
                               'pcr-hash-algorithm, reset-count, restart-count, safe-mode, secure-boot, '
                               'secure-boot-configuration-policy-finger-print, test-signing, tpm-version, '
                               'virtual-secure-mode, windows-pe'.format(k))
        return d


class AddDeviceCategory(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.device_category = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'description':
                d['description'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter device_category. All possible keys are: '
                               'description, display-name, id'.format(k))
        return d
