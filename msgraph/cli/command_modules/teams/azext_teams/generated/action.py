# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------
# pylint: disable=protected-access

import argparse
from collections import defaultdict
from knack.util import CLIError


class AddFunSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.fun_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allow-custom-memes':
                d['allow_custom_memes'] = v[0]
            elif kl == 'allow-giphy':
                d['allow_giphy'] = v[0]
            elif kl == 'allow-stickers-and-memes':
                d['allow_stickers_and_memes'] = v[0]
            elif kl == 'giphy-content-rating':
                d['giphy_content_rating'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter fun_settings. All possible keys are: '
                               'allow-custom-memes, allow-giphy, allow-stickers-and-memes, giphy-content-rating'.
                               format(k))
        return d


class AddGuestSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.guest_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allow-create-update-channels':
                d['allow_create_update_channels'] = v[0]
            elif kl == 'allow-delete-channels':
                d['allow_delete_channels'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter guest_settings. All possible keys are: '
                               'allow-create-update-channels, allow-delete-channels'.format(k))
        return d


class AddMemberSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.member_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allow-add-remove-apps':
                d['allow_add_remove_apps'] = v[0]
            elif kl == 'allow-create-private-channels':
                d['allow_create_private_channels'] = v[0]
            elif kl == 'allow-create-update-channels':
                d['allow_create_update_channels'] = v[0]
            elif kl == 'allow-create-update-remove-connectors':
                d['allow_create_update_remove_connectors'] = v[0]
            elif kl == 'allow-create-update-remove-tabs':
                d['allow_create_update_remove_tabs'] = v[0]
            elif kl == 'allow-delete-channels':
                d['allow_delete_channels'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter member_settings. All possible keys are: '
                               'allow-add-remove-apps, allow-create-private-channels, allow-create-update-channels, '
                               'allow-create-update-remove-connectors, allow-create-update-remove-tabs, '
                               'allow-delete-channels'.format(k))
        return d


class AddMessagingSettings(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.messaging_settings = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'allow-channel-mentions':
                d['allow_channel_mentions'] = v[0]
            elif kl == 'allow-owner-delete-messages':
                d['allow_owner_delete_messages'] = v[0]
            elif kl == 'allow-team-mentions':
                d['allow_team_mentions'] = v[0]
            elif kl == 'allow-user-delete-messages':
                d['allow_user_delete_messages'] = v[0]
            elif kl == 'allow-user-edit-messages':
                d['allow_user_edit_messages'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter messaging_settings. All possible keys '
                               'are: allow-channel-mentions, allow-owner-delete-messages, allow-team-mentions, '
                               'allow-user-delete-messages, allow-user-edit-messages'.format(k))
        return d


class AddGroupsMembers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsMembers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'roles':
                d['roles'] = v
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter members. All possible keys are: '
                               'display-name, roles, id'.format(k))
        return d


class AddAssignedLabels(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAssignedLabels, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'label-id':
                d['label_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter assigned_labels. All possible keys are: '
                               'display-name, label-id'.format(k))
        return d


class AddAssignedLicenses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAssignedLicenses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'disabled-plans':
                d['disabled_plans'] = v
            elif kl == 'sku-id':
                d['sku_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter assigned_licenses. All possible keys are: '
                               'disabled-plans, sku-id'.format(k))
        return d


class AddLicenseProcessingState(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.license_processing_state = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'state':
                d['state'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter license_processing_state. All possible '
                               'keys are: state'.format(k))
        return d


class AddOnPremisesProvisioningErrors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOnPremisesProvisioningErrors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'category':
                d['category'] = v[0]
            elif kl == 'occurred-date-time':
                d['occurred_date_time'] = v[0]
            elif kl == 'property-causing-error':
                d['property_causing_error'] = v[0]
            elif kl == 'value':
                d['value'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter on_premises_provisioning_errors. All '
                               'possible keys are: category, occurred-date-time, property-causing-error, value'.format(k))
        return d


class AddAppRoleAssignments(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppRoleAssignments, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'app-role-id':
                d['app_role_id'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'principal-display-name':
                d['principal_display_name'] = v[0]
            elif kl == 'principal-id':
                d['principal_id'] = v[0]
            elif kl == 'principal-type':
                d['principal_type'] = v[0]
            elif kl == 'resource-display-name':
                d['resource_display_name'] = v[0]
            elif kl == 'resource-id':
                d['resource_id'] = v[0]
            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter app_role_assignments. All possible keys '
                               'are: app-role-id, created-date-time, principal-display-name, principal-id, '
                               'principal-type, resource-display-name, resource-id, deleted-date-time, id'.format(k))
        return d


class AddCreatedOnBehalfOf(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.created_on_behalf_of = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter created_on_behalf_of. All possible keys '
                               'are: deleted-date-time, id'.format(k))
        return d


class AddMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMemberOf, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter member_of. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddMicrosoftGraphGroupMembers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMicrosoftGraphGroupMembers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter microsoft_graph_group_members. All '
                               'possible keys are: deleted-date-time, id'.format(k))
        return d


class AddMembersWithLicenseErrors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMembersWithLicenseErrors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter members_with_license_errors. All possible '
                               'keys are: deleted-date-time, id'.format(k))
        return d


class AddOwners(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOwners, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter owners. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddTransitiveMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTransitiveMemberOf, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter transitive_member_of. All possible keys '
                               'are: deleted-date-time, id'.format(k))
        return d


class AddTransitiveMembers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTransitiveMembers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter transitive_members. All possible keys '
                               'are: deleted-date-time, id'.format(k))
        return d


class AddAcceptedSenders(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAcceptedSenders, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter accepted_senders. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddGroupsPhoto(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.photo = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'height':
                d['height'] = v[0]
            elif kl == 'width':
                d['width'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter photo. All possible keys are: height, '
                               'width, id'.format(k))
        return d


class AddPhotos(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPhotos, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'height':
                d['height'] = v[0]
            elif kl == 'width':
                d['width'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter photos. All possible keys are: height, '
                               'width, id'.format(k))
        return d


class AddRejectedSenders(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddRejectedSenders, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter rejected_senders. All possible keys are: '
                               'deleted-date-time, id'.format(k))
        return d


class AddExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddExtensions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter extensions. All possible keys are: id'.
                format(k))
        return d


class AddGroupLifecyclePolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupLifecyclePolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'alternate-notification-emails':
                d['alternate_notification_emails'] = v[0]
            elif kl == 'group-lifetime-in-days':
                d['group_lifetime_in_days'] = v[0]
            elif kl == 'managed-group-types':
                d['managed_group_types'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter group_lifecycle_policies. All possible '
                               'keys are: alternate-notification-emails, group-lifetime-in-days, managed-group-types, '
                               'id'.format(k))
        return d


class AddOfferShiftRequests(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOfferShiftRequests, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'recipient-action-date-time':
                d['recipient_action_date_time'] = v[0]
            elif kl == 'recipient-action-message':
                d['recipient_action_message'] = v[0]
            elif kl == 'recipient-user-id':
                d['recipient_user_id'] = v[0]
            elif kl == 'sender-shift-id':
                d['sender_shift_id'] = v[0]
            elif kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'manager-action-date-time':
                d['manager_action_date_time'] = v[0]
            elif kl == 'manager-action-message':
                d['manager_action_message'] = v[0]
            elif kl == 'manager-user-id':
                d['manager_user_id'] = v[0]
            elif kl == 'sender-date-time':
                d['sender_date_time'] = v[0]
            elif kl == 'sender-message':
                d['sender_message'] = v[0]
            elif kl == 'sender-user-id':
                d['sender_user_id'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'application':
                d['application'] = v[0]
            elif kl == 'device':
                d['device'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter offer_shift_requests. All possible keys '
                               'are: recipient-action-date-time, recipient-action-message, recipient-user-id, '
                               'sender-shift-id, assigned-to, manager-action-date-time, manager-action-message, '
                               'manager-user-id, sender-date-time, sender-message, sender-user-id, state, '
                               'created-date-time, last-modified-date-time, application, device, user, id'.format(k))
        return d


class AddOpenShiftChangeRequests(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOpenShiftChangeRequests, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'open-shift-id':
                d['open_shift_id'] = v[0]
            elif kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'manager-action-date-time':
                d['manager_action_date_time'] = v[0]
            elif kl == 'manager-action-message':
                d['manager_action_message'] = v[0]
            elif kl == 'manager-user-id':
                d['manager_user_id'] = v[0]
            elif kl == 'sender-date-time':
                d['sender_date_time'] = v[0]
            elif kl == 'sender-message':
                d['sender_message'] = v[0]
            elif kl == 'sender-user-id':
                d['sender_user_id'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'application':
                d['application'] = v[0]
            elif kl == 'device':
                d['device'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter open_shift_change_requests. All possible '
                               'keys are: open-shift-id, assigned-to, manager-action-date-time, '
                               'manager-action-message, manager-user-id, sender-date-time, sender-message, '
                               'sender-user-id, state, created-date-time, last-modified-date-time, application, '
                               'device, user, id'.format(k))
        return d


class AddSchedulingGroups(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSchedulingGroups, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'user-ids':
                d['user_ids'] = v
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'application':
                d['application'] = v[0]
            elif kl == 'device':
                d['device'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter scheduling_groups. All possible keys are: '
                               'display-name, is-active, user-ids, created-date-time, last-modified-date-time, '
                               'application, device, user, id'.format(k))
        return d


class AddSwapShiftsChangeRequests(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSwapShiftsChangeRequests, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'recipient-shift-id':
                d['recipient_shift_id'] = v[0]
            elif kl == 'recipient-action-date-time':
                d['recipient_action_date_time'] = v[0]
            elif kl == 'recipient-action-message':
                d['recipient_action_message'] = v[0]
            elif kl == 'recipient-user-id':
                d['recipient_user_id'] = v[0]
            elif kl == 'sender-shift-id':
                d['sender_shift_id'] = v[0]
            elif kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'manager-action-date-time':
                d['manager_action_date_time'] = v[0]
            elif kl == 'manager-action-message':
                d['manager_action_message'] = v[0]
            elif kl == 'manager-user-id':
                d['manager_user_id'] = v[0]
            elif kl == 'sender-date-time':
                d['sender_date_time'] = v[0]
            elif kl == 'sender-message':
                d['sender_message'] = v[0]
            elif kl == 'sender-user-id':
                d['sender_user_id'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'application':
                d['application'] = v[0]
            elif kl == 'device':
                d['device'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter swap_shifts_change_requests. All possible '
                               'keys are: recipient-shift-id, recipient-action-date-time, recipient-action-message, '
                               'recipient-user-id, sender-shift-id, assigned-to, manager-action-date-time, '
                               'manager-action-message, manager-user-id, sender-date-time, sender-message, '
                               'sender-user-id, state, created-date-time, last-modified-date-time, application, '
                               'device, user, id'.format(k))
        return d


class AddTimeOffReasons(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTimeOffReasons, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'icon-type':
                d['icon_type'] = v[0]
            elif kl == 'is-active':
                d['is_active'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'application':
                d['application'] = v[0]
            elif kl == 'device':
                d['device'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter time_off_reasons. All possible keys are: '
                               'display-name, icon-type, is-active, created-date-time, last-modified-date-time, '
                               'application, device, user, id'.format(k))
        return d


class AddTimeOffRequests(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTimeOffRequests, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'time-off-reason-id':
                d['time_off_reason_id'] = v[0]
            elif kl == 'assigned-to':
                d['assigned_to'] = v[0]
            elif kl == 'manager-action-date-time':
                d['manager_action_date_time'] = v[0]
            elif kl == 'manager-action-message':
                d['manager_action_message'] = v[0]
            elif kl == 'manager-user-id':
                d['manager_user_id'] = v[0]
            elif kl == 'sender-date-time':
                d['sender_date_time'] = v[0]
            elif kl == 'sender-message':
                d['sender_message'] = v[0]
            elif kl == 'sender-user-id':
                d['sender_user_id'] = v[0]
            elif kl == 'state':
                d['state'] = v[0]
            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'application':
                d['application'] = v[0]
            elif kl == 'device':
                d['device'] = v[0]
            elif kl == 'user':
                d['user'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter time_off_requests. All possible keys are: '
                               'end-date-time, start-date-time, time-off-reason-id, assigned-to, '
                               'manager-action-date-time, manager-action-message, manager-user-id, sender-date-time, '
                               'sender-message, sender-user-id, state, created-date-time, last-modified-date-time, '
                               'application, device, user, id'.format(k))
        return d


class AddTeamsMembers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTeamsMembers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'roles':
                d['roles'] = v
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter members. All possible keys are: '
                               'display-name, roles, id'.format(k))
        return d


class AddTeamsAppDefinition(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.teams_app_definition = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'teams-app-id':
                d['teams_app_id'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter teams_app_definition. All possible keys '
                               'are: display-name, teams-app-id, version, id'.format(k))
        return d


class AddAppDefinitions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppDefinitions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'teams-app-id':
                d['teams_app_id'] = v[0]
            elif kl == 'version':
                d['version'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter app_definitions. All possible keys are: '
                               'display-name, teams-app-id, version, id'.format(k))
        return d


class AddError(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.error = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'code':
                d['code'] = v[0]
            elif kl == 'message':
                d['message'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter error. All possible keys are: code, '
                               'message'.format(k))
        return d


class AddAttachments(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAttachments, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content':
                d['content'] = v[0]
            elif kl == 'content-type':
                d['content_type'] = v[0]
            elif kl == 'content-url':
                d['content_url'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            elif kl == 'thumbnail-url':
                d['thumbnail_url'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter attachments. All possible keys are: '
                               'content, content-type, content-url, id, name, thumbnail-url'.format(k))
        return d


class AddBody(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.body = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content':
                d['content'] = v[0]
            elif kl == 'content-type':
                d['content_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter body. All possible keys are: content, '
                               'content-type'.format(k))
        return d


class AddHostedContents(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddHostedContents, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter hosted_contents. All possible keys are: '
                               'id'.format(k))
        return d


class AddPolicyTip(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.policy_tip = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'compliance-url':
                d['compliance_url'] = v[0]
            elif kl == 'general-text':
                d['general_text'] = v[0]
            elif kl == 'matched-condition-descriptions':
                d['matched_condition_descriptions'] = v
            else:
                raise CLIError('Unsupported Key {} is provided for parameter policy_tip. All possible keys are: '
                               'compliance-url, general-text, matched-condition-descriptions'.format(k))
        return d


class AddApplication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.application = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter application. All possible keys are: '
                               'display-name, id'.format(k))
        return d


class AddConfiguration(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.configuration = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content-url':
                d['content_url'] = v[0]
            elif kl == 'entity-id':
                d['entity_id'] = v[0]
            elif kl == 'remove-url':
                d['remove_url'] = v[0]
            elif kl == 'website-url':
                d['website_url'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter configuration. All possible keys are: '
                               'content-url, entity-id, remove-url, website-url'.format(k))
        return d


class AddSharepointIds(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.sharepoint_ids = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'list-id':
                d['list_id'] = v[0]
            elif kl == 'list-item-id':
                d['list_item_id'] = v[0]
            elif kl == 'list-item-unique-id':
                d['list_item_unique_id'] = v[0]
            elif kl == 'site-id':
                d['site_id'] = v[0]
            elif kl == 'site-url':
                d['site_url'] = v[0]
            elif kl == 'tenant-id':
                d['tenant_id'] = v[0]
            elif kl == 'web-id':
                d['web_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter sharepoint_ids. All possible keys are: '
                               'list-id, list-item-id, list-item-unique-id, site-id, site-url, tenant-id, web-id'.
                               format(k))
        return d


class AddAudio(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.audio = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'album':
                d['album'] = v[0]
            elif kl == 'album-artist':
                d['album_artist'] = v[0]
            elif kl == 'artist':
                d['artist'] = v[0]
            elif kl == 'bitrate':
                d['bitrate'] = v[0]
            elif kl == 'composers':
                d['composers'] = v[0]
            elif kl == 'copyright':
                d['copyright'] = v[0]
            elif kl == 'disc':
                d['disc'] = v[0]
            elif kl == 'disc-count':
                d['disc_count'] = v[0]
            elif kl == 'duration':
                d['duration'] = v[0]
            elif kl == 'genre':
                d['genre'] = v[0]
            elif kl == 'has-drm':
                d['has_drm'] = v[0]
            elif kl == 'is-variable-bitrate':
                d['is_variable_bitrate'] = v[0]
            elif kl == 'title':
                d['title'] = v[0]
            elif kl == 'track':
                d['track'] = v[0]
            elif kl == 'track-count':
                d['track_count'] = v[0]
            elif kl == 'year':
                d['year'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter audio. All possible keys are: album, '
                               'album-artist, artist, bitrate, composers, copyright, disc, disc-count, duration, '
                               'genre, has-drm, is-variable-bitrate, title, track, track-count, year'.format(k))
        return d


class AddFileSystemInfo(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.file_system_info = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'created-date-time':
                d['created_date_time'] = v[0]
            elif kl == 'last-accessed-date-time':
                d['last_accessed_date_time'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter file_system_info. All possible keys are: '
                               'created-date-time, last-accessed-date-time, last-modified-date-time'.format(k))
        return d


class AddImage(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.image = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'height':
                d['height'] = v[0]
            elif kl == 'width':
                d['width'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter image. All possible keys are: height, '
                               'width'.format(k))
        return d


class AddLocation(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.location = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'altitude':
                d['altitude'] = v[0]
            elif kl == 'latitude':
                d['latitude'] = v[0]
            elif kl == 'longitude':
                d['longitude'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter location. All possible keys are: '
                               'altitude, latitude, longitude'.format(k))
        return d


class AddTeamsChannelsPhoto(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.photo = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'camera-make':
                d['camera_make'] = v[0]
            elif kl == 'camera-model':
                d['camera_model'] = v[0]
            elif kl == 'exposure-denominator':
                d['exposure_denominator'] = v[0]
            elif kl == 'exposure-numerator':
                d['exposure_numerator'] = v[0]
            elif kl == 'f-number':
                d['f_number'] = v[0]
            elif kl == 'focal-length':
                d['focal_length'] = v[0]
            elif kl == 'iso':
                d['iso'] = v[0]
            elif kl == 'orientation':
                d['orientation'] = v[0]
            elif kl == 'taken-date-time':
                d['taken_date_time'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter photo. All possible keys are: '
                               'camera-make, camera-model, exposure-denominator, exposure-numerator, f-number, '
                               'focal-length, iso, orientation, taken-date-time'.format(k))
        return d


class AddPublication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.publication = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'level':
                d['level'] = v[0]
            elif kl == 'version-id':
                d['version_id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter publication. All possible keys are: '
                               'level, version-id'.format(k))
        return d


class AddVideo(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.video = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'audio-bits-per-sample':
                d['audio_bits_per_sample'] = v[0]
            elif kl == 'audio-channels':
                d['audio_channels'] = v[0]
            elif kl == 'audio-format':
                d['audio_format'] = v[0]
            elif kl == 'audio-samples-per-second':
                d['audio_samples_per_second'] = v[0]
            elif kl == 'bitrate':
                d['bitrate'] = v[0]
            elif kl == 'duration':
                d['duration'] = v[0]
            elif kl == 'four-cc':
                d['four_cc'] = v[0]
            elif kl == 'frame-rate':
                d['frame_rate'] = v[0]
            elif kl == 'height':
                d['height'] = v[0]
            elif kl == 'width':
                d['width'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter video. All possible keys are: '
                               'audio-bits-per-sample, audio-channels, audio-format, audio-samples-per-second, '
                               'bitrate, duration, four-cc, frame-rate, height, width'.format(k))
        return d


class AddSubscriptions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSubscriptions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'application-id':
                d['application_id'] = v[0]
            elif kl == 'change-type':
                d['change_type'] = v[0]
            elif kl == 'client-state':
                d['client_state'] = v[0]
            elif kl == 'creator-id':
                d['creator_id'] = v[0]
            elif kl == 'encryption-certificate':
                d['encryption_certificate'] = v[0]
            elif kl == 'encryption-certificate-id':
                d['encryption_certificate_id'] = v[0]
            elif kl == 'expiration-date-time':
                d['expiration_date_time'] = v[0]
            elif kl == 'include-resource-data':
                d['include_resource_data'] = v[0]
            elif kl == 'latest-supported-tls-version':
                d['latest_supported_tls_version'] = v[0]
            elif kl == 'lifecycle-notification-url':
                d['lifecycle_notification_url'] = v[0]
            elif kl == 'notification-url':
                d['notification_url'] = v[0]
            elif kl == 'resource':
                d['resource'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter subscriptions. All possible keys are: '
                               'application-id, change-type, client-state, creator-id, encryption-certificate, '
                               'encryption-certificate-id, expiration-date-time, include-resource-data, '
                               'latest-supported-tls-version, lifecycle-notification-url, notification-url, resource, '
                               'id'.format(k))
        return d


class AddVersions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddVersions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'content':
                d['content'] = v[0]
            elif kl == 'size':
                d['size'] = v[0]
            elif kl == 'last-modified-by':
                d['last_modified_by'] = v[0]
            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]
            elif kl == 'publication':
                d['publication'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter versions. All possible keys are: content, '
                               'size, last-modified-by, last-modified-date-time, publication, id'.format(k))
        return d


class AddContentType(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.content_type = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'id':
                d['id'] = v[0]
            elif kl == 'name':
                d['name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter content_type. All possible keys are: id, '
                               'name'.format(k))
        return d


class AddFields(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.fields = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter fields. All possible keys are: id'.format(k))
        return d


class AddMicrosoftGraphWorkbookApplication(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.microsoft_graph_workbook_application = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'calculation-mode':
                d['calculation_mode'] = v[0]
            elif kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter microsoft_graph_workbook_application. All '
                               'possible keys are: calculation-mode, id'.format(k))
        return d


class AddFunctions(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.functions = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'id':
                d['id'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter functions. All possible keys are: id'.
                format(k))
        return d


class AddPackage(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.package = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'type':
                d['type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter package. All possible keys are: type'.
                format(k))
        return d


class AddSpecialFolder(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.special_folder = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'name':
                d['name'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter special_folder. All possible keys are: '
                               'name'.format(k))
        return d


class AddView(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.view = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'sort-by':
                d['sort_by'] = v[0]
            elif kl == 'sort-order':
                d['sort_order'] = v[0]
            elif kl == 'view-type':
                d['view_type'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter view. All possible keys are: sort-by, '
                               'sort-order, view-type'.format(k))
        return d


class AddHashes(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.hashes = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'crc32-hash':
                d['crc32_hash'] = v[0]
            elif kl == 'quick-xor-hash':
                d['quick_xor_hash'] = v[0]
            elif kl == 'sha1-hash':
                d['sha1_hash'] = v[0]
            elif kl == 'sha256-hash':
                d['sha256_hash'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter hashes. All possible keys are: '
                               'crc32-hash, quick-xor-hash, sha1-hash, sha256-hash'.format(k))
        return d


class AddDraftOpenShift(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.draft_open_shift = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'open-slot-count':
                d['open_slot_count'] = v[0]
            elif kl == 'activities':
                d['activities'] = v
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'notes':
                d['notes'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'theme':
                d['theme'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter draft_open_shift. All possible keys are: '
                               'open-slot-count, activities, display-name, notes, end-date-time, start-date-time, '
                               'theme'.format(k))
        return d


class AddActivities(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddActivities, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'code':
                d['code'] = v[0]
            elif kl == 'display-name':
                d['display_name'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'is-paid':
                d['is_paid'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'theme':
                d['theme'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter activities. All possible keys are: code, '
                               'display-name, end-date-time, is-paid, start-date-time, theme'.format(k))
        return d


class AddDraftTimeOff(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.draft_time_off = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'time-off-reason-id':
                d['time_off_reason_id'] = v[0]
            elif kl == 'end-date-time':
                d['end_date_time'] = v[0]
            elif kl == 'start-date-time':
                d['start_date_time'] = v[0]
            elif kl == 'theme':
                d['theme'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter draft_time_off. All possible keys are: '
                               'time-off-reason-id, end-date-time, start-date-time, theme'.format(k))
        return d


class AddEncryption(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.encryption = action

    def get_action(self, values, option_string):  # pylint: disable=no-self-use
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]
            if kl == 'protocol':
                d['protocol'] = v[0]
            elif kl == 'secret':
                d['secret'] = v[0]
            else:
                raise CLIError('Unsupported Key {} is provided for parameter encryption. All possible keys are: '
                               'protocol, secret'.format(k))
        return d
