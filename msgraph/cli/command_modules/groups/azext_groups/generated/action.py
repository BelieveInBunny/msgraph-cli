# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------


# pylint: disable=protected-access

# pylint: disable=no-self-use


import argparse
from collections import defaultdict
from knack.util import CLIError


class AddAssignedLabels(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAssignedLabels, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'display-name':
                d['display_name'] = v[0]

            elif kl == 'label-id':
                d['label_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter assigned-labels. All possible keys are: display-name,'
                    ' label-id'.format(k)
                )

        return d


class AddAssignedLicenses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAssignedLicenses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'disabled-plans':
                d['disabled_plans'] = v

            elif kl == 'sku-id':
                d['sku_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter assigned-licenses. All possible keys are:'
                    ' disabled-plans, sku-id'.format(k)
                )

        return d


class AddOnPremisesProvisioningErrors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOnPremisesProvisioningErrors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'category':
                d['category'] = v[0]

            elif kl == 'occurred-date-time':
                d['occurred_date_time'] = v[0]

            elif kl == 'property-causing-error':
                d['property_causing_error'] = v[0]

            elif kl == 'value':
                d['value'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter on-premises-provisioning-errors. All possible keys'
                    ' are: category, occurred-date-time, property-causing-error, value'.format(k)
                )

        return d


class AddAppRoleAssignments(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAppRoleAssignments, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'app-role-id':
                d['app_role_id'] = v[0]

            elif kl == 'created-date-time':
                d['created_date_time'] = v[0]

            elif kl == 'principal-display-name':
                d['principal_display_name'] = v[0]

            elif kl == 'principal-id':
                d['principal_id'] = v[0]

            elif kl == 'principal-type':
                d['principal_type'] = v[0]

            elif kl == 'resource-display-name':
                d['resource_display_name'] = v[0]

            elif kl == 'resource-id':
                d['resource_id'] = v[0]

            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter app-role-assignments. All possible keys are:'
                    ' app-role-id, created-date-time, principal-display-name, principal-id, principal-type,'
                    ' resource-display-name, resource-id, deleted-date-time, id'.format(k)
                )

        return d


class AddCreatedOnBehalfOf(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.created_on_behalf_of = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter created-on-behalf-of. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMemberOf, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter member-of. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddMembers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMembers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter members. All possible keys are: deleted-date-time, id'
                    .format(k)
                )

        return d


class AddMembersWithLicenseErrors(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMembersWithLicenseErrors, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter members-with-license-errors. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddOwners(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddOwners, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter owners. All possible keys are: deleted-date-time, id'
                    .format(k)
                )

        return d


class AddPermissionGrants(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPermissionGrants, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'client-app-id':
                d['client_app_id'] = v[0]

            elif kl == 'client-id':
                d['client_id'] = v[0]

            elif kl == 'permission':
                d['permission'] = v[0]

            elif kl == 'permission-type':
                d['permission_type'] = v[0]

            elif kl == 'resource-app-id':
                d['resource_app_id'] = v[0]

            elif kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter permission-grants. All possible keys are:'
                    ' client-app-id, client-id, permission, permission-type, resource-app-id, deleted-date-time, id'
                    .format(k)
                )

        return d


class AddTransitiveMemberOf(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTransitiveMemberOf, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter transitive-member-of. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddTransitiveMembers(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddTransitiveMembers, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter transitive-members. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddAcceptedSenders(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAcceptedSenders, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter accepted-senders. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddPhoto(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.photo = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'height':
                d['height'] = v[0]

            elif kl == 'width':
                d['width'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter photo. All possible keys are: height, width, id'
                    .format(k)
                )

        return d


class AddPhotos(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddPhotos, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'height':
                d['height'] = v[0]

            elif kl == 'width':
                d['width'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter photos. All possible keys are: height, width, id'
                    .format(k)
                )

        return d


class AddRejectedSenders(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddRejectedSenders, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'deleted-date-time':
                d['deleted_date_time'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter rejected-senders. All possible keys are:'
                    ' deleted-date-time, id'.format(k)
                )

        return d


class AddGroupsGroupExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsGroupExtensions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter extensions. All possible keys are: id'.format(k)
                )

        return d


class AddGroupLifecyclePolicies(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupLifecyclePolicies, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'alternate-notification-emails':
                d['alternate_notification_emails'] = v[0]

            elif kl == 'group-lifetime-in-days':
                d['group_lifetime_in_days'] = v[0]

            elif kl == 'managed-group-types':
                d['managed_group_types'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter group-lifecycle-policies. All possible keys are:'
                    ' alternate-notification-emails, group-lifetime-in-days, managed-group-types, id'.format(k)
                )

        return d


class AddResources(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddResources, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'content':
                d['content'] = v[0]

            elif kl == 'content-url':
                d['content_url'] = v[0]

            elif kl == 'self':
                d['self_property'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter resources. All possible keys are: content,'
                    ' content-url, self, id'.format(k)
                )

        return d


class AddAddLicenses(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAddLicenses, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'disabled-plans':
                d['disabled_plans'] = v

            elif kl == 'sku-id':
                d['sku_id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter add-licenses. All possible keys are: disabled-plans,'
                    ' sku-id'.format(k)
                )

        return d


class AddAttachmentItem(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.attachment_item = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'attachment-type':
                d['attachment_type'] = v[0]

            elif kl == 'content-type':
                d['content_type'] = v[0]

            elif kl == 'is-inline':
                d['is_inline'] = v[0]

            elif kl == 'name':
                d['name'] = v[0]

            elif kl == 'size':
                d['size'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter attachment-item. All possible keys are:'
                    ' attachment-type, content-type, is-inline, name, size'.format(k)
                )

        return d


class AddEndTime(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.end_time = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'date-time':
                d['date_time'] = v[0]

            elif kl == 'time-zone':
                d['time_zone'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter end-time. All possible keys are: date-time, time-zone'
                    .format(k)
                )

        return d


class AddBody(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.body = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'content':
                d['content'] = v[0]

            elif kl == 'content-type':
                d['content_type'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter body. All possible keys are: content, content-type'
                    .format(k)
                )

        return d


class AddAttachments(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddAttachments, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'content-type':
                d['content_type'] = v[0]

            elif kl == 'is-inline':
                d['is_inline'] = v[0]

            elif kl == 'last-modified-date-time':
                d['last_modified_date_time'] = v[0]

            elif kl == 'name':
                d['name'] = v[0]

            elif kl == 'size':
                d['size'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter attachments. All possible keys are: content-type,'
                    ' is-inline, last-modified-date-time, name, size, id'.format(k)
                )

        return d


class AddGroupsConversationsThreadsExtensions(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsConversationsThreadsExtensions, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter extensions. All possible keys are: id'.format(k)
                )

        return d


class AddMultiValueExtendedProperties(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddMultiValueExtendedProperties, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'value':
                d['value'] = v

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter multi-value-extended-properties. All possible keys'
                    ' are: value, id'.format(k)
                )

        return d


class AddSingleValueExtendedProperties(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddSingleValueExtendedProperties, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'value':
                d['value'] = v[0]

            elif kl == 'id':
                d['id'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter single-value-extended-properties. All possible keys'
                    ' are: value, id'.format(k)
                )

        return d


class AddEmailAddress(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        namespace.email_address = action

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'address':
                d['address'] = v[0]

            elif kl == 'name':
                d['name'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter email-address. All possible keys are: address, name'
                    .format(k)
                )

        return d


class AddGroupsOnenoteNotebooksSectiongroupsSectionsPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenoteNotebooksSectiongroupsSectionsPagesCommands, self).__call__(
            parser, namespace, action, option_string
        )

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenoteNotebooksSectionsPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenoteNotebooksSectionsPagesCommands, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenotePagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenotePagesCommands, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenotePagesParentnotebookSectiongroupsSectionsPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenotePagesParentnotebookSectiongroupsSectionsPagesCommands, self).__call__(
            parser, namespace, action, option_string
        )

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenotePagesParentnotebookSectionsPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenotePagesParentnotebookSectionsPagesCommands, self).__call__(
            parser, namespace, action, option_string
        )

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenotePagesParentsectionPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenotePagesParentsectionPagesCommands, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenoteSectiongroupsParentnotebookSectionsPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenoteSectiongroupsParentnotebookSectionsPagesCommands, self).__call__(
            parser, namespace, action, option_string
        )

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddGroupsOnenoteSectiongroupsSectionsPagesCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddGroupsOnenoteSectiongroupsSectionsPagesCommands, self).__call__(
            parser, namespace, action, option_string
        )

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d


class AddCommands(argparse._AppendAction):
    def __call__(self, parser, namespace, values, option_string=None):
        action = self.get_action(values, option_string)
        super(AddCommands, self).__call__(parser, namespace, action, option_string)

    def get_action(self, values, option_string):
        try:
            properties = defaultdict(list)
            for (k, v) in (x.split('=', 1) for x in values):
                properties[k].append(v)
            properties = dict(properties)
        except ValueError:
            raise CLIError('usage error: {} [KEY=VALUE ...]'.format(option_string))
        d = {}
        for k in properties:
            kl = k.lower()
            v = properties[k]

            if kl == 'action':
                d['action'] = v[0]

            elif kl == 'content':
                d['content'] = v[0]

            elif kl == 'position':
                d['position'] = v[0]

            elif kl == 'target':
                d['target'] = v[0]

            else:
                raise CLIError(
                    'Unsupported Key {} is provided for parameter commands. All possible keys are: action, content,'
                    ' position, target'.format(k)
                )

        return d
